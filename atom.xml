<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月刊少女野崎君のBlog</title>
  
  
  <link href="https://monthlygirl.github.io/atom.xml" rel="self"/>
  
  <link href="https://monthlygirl.github.io/"/>
  <updated>2024-01-28T08:37:07.000Z</updated>
  <id>https://monthlygirl.github.io/</id>
  
  <author>
    <name>月刊少女野崎君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CORS</title>
    <link href="https://monthlygirl.github.io/2024/01/cors.html"/>
    <id>https://monthlygirl.github.io/2024/01/cors.html</id>
    <published>2024-01-28T08:37:07.000Z</published>
    <updated>2024-01-28T08:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>跨域资源共享，是基于 HTTP 上一个用来解决跨域的方法，需要服务端和浏览器端同时支持</p><p>CORS 分为简单请求和非简单请求<br>简单请求：简单请求只要满足以下两大条件就是简单请求</p><ol><li>请求方法只能是 GET、POST、HEAD</li><li>请求头中不超出以下几个字段<br> accept，<br> accept-language，<br> context-type, 其中 content-type 只能是 application/x-www-form-urlencoded、text/plain、multipart/form-data，<br> Last-Event-ID</li></ol><p>否则就视为非简单请求，浏览器对于两种请求处理是不一样的</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 origin 字段，用来标识是哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span>/cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//baidu.com</span></span><br><span class="line"><span class="title class_">Host</span>: baidu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>上面头信息中，origin字段用来说明，本次请求来自哪个源。服务器根据这个值决定是否同意这次请求</p><p>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现 这个回应的头信息没有包含 Access-Control-Allow-Origin 字段就知道出错了，从而抛出错误。</p><p>如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:baidu.<span class="property">com</span> <span class="comment">// 该字段是必须的，它的值要么是请求时的 Origin 字段，要么是 *</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credential</span>: <span class="literal">true</span> <span class="comment">// 可选值，表示是否允许发送 Cookie， 默认情况下，Cookie 不包括在 CORS 请求之中，设为 true，cookie 可以包含在请求中，也可以设为 true 如果服务器不要浏览器发送 cookie 就删除该字段。</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="title class_">FooBar</span> <span class="comment">// 可选，cors 请求时，XMLHttpRequest 的只能拿到响应头中 6个基本字段（cache-control、content-language、content-type、expires、last-modified、Pragma），如果想拿其他的，就必须在 Access-Control-Expose-Headers 中指定。</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的，比如请求方法是 PUT、DELETE，或者 Content-type 是 application/json</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检”请求</p><p>预检请求：浏览器会先询问服务器，当前网页域名是否在服务器许可名单之中。以及可以使用哪些 HTTP 头部信息，只有得到肯定答复，浏览器才会正式发出请求，否则就报错</p><p>预检请求 是通过 OPTIONS 发的，表示这个请求是个询问请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:baidu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">PUT</span>  <span class="comment">//表示CORS 会用到哪些请求方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span> <span class="comment">// 额外发送的头部信息</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><h3 id="回应预检请求"><a href="#回应预检请求" class="headerlink" title="回应预检请求"></a>回应预检请求</h3><p>服务器收到“预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段后，确认允许跨域请求，就会做出回应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> ok</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Mon</span>, <span class="number">01</span> <span class="title class_">Dec</span> <span class="number">2024</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Apache</span>/<span class="number">2.0</span><span class="number">.61</span>(<span class="title class_">Unix</span>)</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//baidu.com // 表示允许 baidu.com 的跨域请求</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Encoding</span>: gzip</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Keep</span>-<span class="title class_">Alive</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头部信息，那么浏览器就会认为 服务器不同意预检请求</p><p>正常响应 CORS 相关字段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">PUT</span> <span class="comment">// 返回服务器支持的所有请求方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span></span><br></pre></td></tr></table></figure><h2 id="通过预检请求"><a href="#通过预检请求" class="headerlink" title="通过预检请求"></a>通过预检请求</h2><p>通过预检请求后，浏览器每次发起都会带有 Origin 字段，服务器响应 也会返回相应的 Access-Control-Allow-Origin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h1&gt;&lt;p&gt;跨域资源共享，是基于 HTTP 上一个用来解决跨域的方法，需要服务端和浏览器端同时支持&lt;/p&gt;
&lt;p&gt;CORS 分为简单请求</summary>
      
    
    
    
    
    <category term="cors" scheme="https://monthlygirl.github.io/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>CDN 缓存是什么</title>
    <link href="https://monthlygirl.github.io/2024/01/CDN.html"/>
    <id>https://monthlygirl.github.io/2024/01/CDN.html</id>
    <published>2024-01-28T02:43:27.000Z</published>
    <updated>2024-01-28T02:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDN-缓存是什么？"><a href="#CDN-缓存是什么？" class="headerlink" title="CDN 缓存是什么？"></a>CDN 缓存是什么？</h1><p>首先来了解下什么是 CDN</p><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><p>CDN 内容分发网络，CDN 是 Content Deliver Network 的简称。常说的 CDN 加速指的网站加速或是用户下载资源加速，CDN加速通常是和域名绑定的，会通过 DNS 分离查找找到最近的 CDN 边缘节点 IP</p><p>CDN 可以理解为分布在每个县城的火车票代售点，用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样广东的移动用户请求就不会千里迢迢跑到北京的电信机房（假设源站部署在北京的电信机房上）的服务器上了</p><h2 id="CDN-的优势"><a href="#CDN-的优势" class="headerlink" title="CDN 的优势"></a>CDN 的优势</h2><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li><li>大部分请求在CDN边缘节点完成，CDN 起到了分流作用，减轻了源站的负载压力</li></ol><h2 id="CDN-缓存是什么？-1"><a href="#CDN-缓存是什么？-1" class="headerlink" title="CDN 缓存是什么？"></a>CDN 缓存是什么？</h2><p>用户浏览器和服务器交互，没有接入 CDN 时：<br>用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度</p><p>用户浏览器和服务交互，接入 CDN 时：<br>客户端浏览器会先检查是否有本地缓存是否过期，如果过期，则向 CDN 边缘节点发起请求，CDN 边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个HTTP 请求结束；<br>如果数据已经过期，那么CDN 还需要向源站发起回源请求，来拉取最新的数据</p><h2 id="客户端缓存的缺点"><a href="#客户端缓存的缺点" class="headerlink" title="客户端缓存的缺点"></a>客户端缓存的缺点</h2><p>虽然说浏览器的缓存可以帮助我们提高页面访问速度，但也存在一个缺陷，缓存的CSS、JS、IMAGE 等资源更新了之后浏览器并不知道，还在使用旧资源。<br>这种则需要用户手动强制刷新才能访问新资源</p><p>手动刷新也有以下几个区别</p><ol><li><p>在地址拦中输入网址后按回车<br>这种方式 浏览器会以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存，从而减少浏览器的请求，所以，我们设置的 HTTP 强缓存 Cache-control、Expires 中的 max-age 标记方式只会这种方式有效。</p></li><li><p>按 F5 或 浏览器刷新按钮<br>这种方式，浏览器会在请求中附加必要的协商缓存，但不允许浏览器直接使用本地缓存，所以这种方式它对 ETag、Last-Modified 起作用，对 Cache-control、Expires 无效</p></li><li><p>按 Ctrl + F5<br>这是一种强刷的方式，不使用任何缓存</p></li></ol><h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p>浏览器本地缓存失效后，浏览器会向 CDN 边缘节点发起请求。跟浏览器一样，CDN 边缘节点也存在着一套缓存机制。</p><h2 id="CDN-缓存策略"><a href="#CDN-缓存策略" class="headerlink" title="CDN 缓存策略"></a>CDN 缓存策略</h2><p>CDN 边缘节点的缓存策略因服务商不同而不同，但一般都会遵循 HTTP 标准协议，通过 HTTP 响应头中的 Cache-Control: max-age 字段来设置 CDN 边缘节点数据的缓存时间</p><p>当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据没有过期，则直接将缓存数据返回给客户端，否则 CDN 会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><p>CDN 缓存主要是通过 文件目录和文件后缀名配置 多个维度来指定 CDN 缓存时间。</p><p>CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源。若 CDN 缓存时间太长，会带来数据更新时间慢的问题。</p><h2 id="CDN-缓存刷新"><a href="#CDN-缓存刷新" class="headerlink" title="CDN 缓存刷新"></a>CDN 缓存刷新</h2><p>CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl + F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的 “刷新缓存” 接口来达到清理 CDN 边缘节点缓存的目的。这样开发这更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端子啊访问时，拉取到最新的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CDN-缓存是什么？&quot;&gt;&lt;a href=&quot;#CDN-缓存是什么？&quot; class=&quot;headerlink&quot; title=&quot;CDN 缓存是什么？&quot;&gt;&lt;/a&gt;CDN 缓存是什么？&lt;/h1&gt;&lt;p&gt;首先来了解下什么是 CDN&lt;/p&gt;
&lt;h2 id=&quot;CDN-是什么&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="CDN、内容分发网络" scheme="https://monthlygirl.github.io/tags/CDN%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vite 构建原理</title>
    <link href="https://monthlygirl.github.io/2024/01/vite-build.html"/>
    <id>https://monthlygirl.github.io/2024/01/vite-build.html</id>
    <published>2024-01-21T08:29:27.000Z</published>
    <updated>2024-01-21T08:29:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vite-构建原理"><a href="#Vite-构建原理" class="headerlink" title="Vite 构建原理"></a>Vite 构建原理</h1><ul><li>快速的冷启动：No Bundle + esbuild 预构建</li><li>即时的模块热更新： 基于 ESM 的 HMR，同时利用浏览器缓存策略提升速度</li><li>真正的按需加载： 利用浏览器的 ESM 支持，实现真正的按需加载</li></ul><p>Vite 其核心原理是利用浏览器现在已经支持 ES6 这一特性，碰见 ES6 的 import 就会发送一个 HTTP 请求去加载文件，Vite 启动一个 Koa 服务器拦截这些请求，并在后端进行相应的处理 将项目中使用的文件通过简单的分解与整合，然后再 ESM 格式返回给浏览器。Vite 整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的 webpack 开发编译速度快出许多！</p><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="基于-ESM-的-Dev-server"><a href="#基于-ESM-的-Dev-server" class="headerlink" title="基于 ESM 的 Dev server"></a>基于 ESM 的 Dev server</h3><p>在  Vite 出来之前，传统的 打包工具 如 webpack 是先解析依赖、打包构建再启动开发服务器，Dev server 必须等所有的模块构建完成，当我们修改了 bundle 模块中的一个子模块，整个 bundle 文件都会重新打包然后输出。项目应用越大，启动时间越长。<br>而 Vite 利用浏览器对 ESM 的支持，当 import 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上实现了动态加载。暂时没有用到的路由代码不会参与构建过程。项目应用增多，也不会影响其构建速度</p><h3 id="基于-ESM-的-HMR-热更新"><a href="#基于-ESM-的-HMR-热更新" class="headerlink" title="基于 ESM 的 HMR 热更新"></a>基于 ESM 的 HMR 热更新</h3><p>目前所有的打包工具实现热更新的思路都大同小异，主要是通过 websocket 创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作更新。</p><ul><li>Webpack： 重新编译，请求变更后模块的代码，客户端重新加载</li><li>Vite: 请求变更的模块，再重新加载</li></ul><p>Vite 通过 chokidar 来监听文件系统的变更，只用对发送生变更的模块重新加载，只需要精确的使相关模块与其临近的 HMR 边界连接失效即可，这样 HMR 更新速度就不会因为应用体积的增加而变慢。<br>而 Webpack 还要经历一次打包构建。所以 HMR 场景下，Vite 表现也比 Webpack 好</p><p>Vite 的整个热更新分为 4 步：</p><ol><li>创建一个 websocket 服务端和 client 文件，启动服务</li><li>通过 chokidar 监听文件变更</li><li>当代码变更后，服务端进行判断并推送到客户端</li><li>客户端根据推送的信息执行不同操作的更新。</li></ol><p>Vite本地启动时会创建一个WebSocket连接，同时去监听本地的文件变化<br>当用户修改了本地的文件时，WebSocket的服务端会拿到变化的文件的ID或者其他标识，并推送给客户端<br>客户端获取到变化的文件信息之后，便去请求最新的文件并刷新页面</p><p>客户端：websocket 通信和更新处理<br>当我们配置了热更新且不是 ssr 的时候，Vite 底层在处理 html的时候会把 HMR 相关的客户端代码写入到我们的代码中，当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如（connected、update、custom…）在实际开发热更新中使用最频繁的是 update和full-reload 事件。</p><p>优化：浏览器的缓存策略提高响应速度：**Vite 还利用HTTP加速整个页面的重新加载。设置响应头使得依赖模块(dependency module)进行强缓存，而源码文件通过设置 304 Not Modified 而变成可依据条件而进行更新。</p><h2 id="基于-esbuild-的依赖预编译优化"><a href="#基于-esbuild-的依赖预编译优化" class="headerlink" title="基于 esbuild 的依赖预编译优化"></a>基于 esbuild 的依赖预编译优化</h2><p><strong>为什么需要预构建 ？</strong></p><ol><li>支持 common JS 依赖</li><li>上面提到 Vite 是基于浏览器原生支持 ESM 的能力实现的，但要求用户的代码模块必须是 ESM 模块，因此必须将 common JS 的文件提前处理，转成 ESM 模块并缓存如 node_modules/.vite</li><li>减少模块和请求数量</li></ol><p>Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面性能加载。</p><p><strong>为什么使用 esbuild</strong></p><ol><li><p>编译运行 VS 解释运行<br>大多数前端打包工具都是基于 JavaScript 实现的，大家都知道 JavaScript 是解释型语言，边运行边解释。而 ESBuild 采用 go 编写，该语言可以编译成原生代码，在编译的时候都将语言转为机器语言，在启动时直接执行，更具性能优势。</p></li><li><p>多线程 VS 单线程</p></li></ol><p>JavaScript 本质上是一门单线程语言，直到引入 webworker 之后才有可能在浏览器、Node 中实现多线程操作。<br>Go 天生具有多线程优势</p><ol start="3"><li>对构建流程进行了优化 充分利用 CPU 资源</li></ol><p><strong>实现原理</strong><br>Vite 预编译之后，将文件缓存在 node_modules/.vite 文件夹下。根据以下地方来决定是否需要重新执行预构建</p><ul><li>package.json 中 dependencies 发送变化</li><li>包管理器的 lockfile</li></ul><p>如果想强制让 Vite 重新预构建依赖，可以使用 –force 启动开发服务器，或者直接删掉 node_modules/.vite 文件夹</p><h2 id="基于-Rollup-的-Plugins"><a href="#基于-Rollup-的-Plugins" class="headerlink" title="基于 Rollup 的 Plugins"></a>基于 Rollup 的 Plugins</h2><p>Vite 从 preat 的 WMR 中得到启发，将 Vite Plugins 继承 Rollup Plugins API，在其基础上进行一些扩展，同时 Vite 也基于 Rollup plugins 机制提供了强大的插件 API </p><p><strong>vite 插件是什么</strong><br>使用 vite 插件可以扩展 vite 能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义写一些配置代码，执行在打包过程中。比如解析用户自定义的文件输入，在打包代码前转译代码</p><p>在实际的实现中，vite 只需要基于 rollup 设计的接口进行扩展。</p><p><strong>Vite 钩子函数</strong></p><ul><li>config: 可以在 Vite 被解析之前修改 Vite 的相关配置</li><li>configResolved: 解析Vite 配置后调用，配置确认</li><li>configureserverL: 主要用来转换 index.html，为 dev-server 添加自定义的中间件</li><li>transformindexhmlt: 主要用来转换 index.html，钩子接收当前的 HTML 字符串和转换上下文</li><li>handlehotupdate: 执行自定义 HMR 更新，可以通过 ws 往客户端发送自定义事件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vite-构建原理&quot;&gt;&lt;a href=&quot;#Vite-构建原理&quot; class=&quot;headerlink&quot; title=&quot;Vite 构建原理&quot;&gt;&lt;/a&gt;Vite 构建原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;快速的冷启动：No Bundle + esbuild 预构建&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Vite 构建原理" scheme="https://monthlygirl.github.io/categories/Vite-%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Vite" scheme="https://monthlygirl.github.io/tags/Vite/"/>
    
    <category term="Vue3" scheme="https://monthlygirl.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue 模板编译和渲染</title>
    <link href="https://monthlygirl.github.io/2024/01/vue-template-compile-render.html"/>
    <id>https://monthlygirl.github.io/2024/01/vue-template-compile-render.html</id>
    <published>2024-01-13T12:38:22.000Z</published>
    <updated>2024-01-13T12:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板编译与渲染"><a href="#模板编译与渲染" class="headerlink" title="模板编译与渲染"></a>模板编译与渲染</h1><h2 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h2><p>在 Vue 中推崇 使用.vue 文件，在.vue 文件中使用 <template></template> 标签来编写 vue 语法。</p><ul><li>  Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。</li><li>  render 函数 会把模板内容生成对应的 VNode， VNode 经过 patch 过程 从而得到 可渲染的视图中的 VNode</li><li>  最后根据 VNode 创建 真实的 DOM 节点，并插入到视图中，最终完成视图的渲染更新。</li></ul><p>其中，【Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。】 这一过程称之为模版编译。</p><h2 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h2><ul><li>  Vue.js 通过编译将 template 模板转换成渲染函数 render，执行渲染函数就可以得到一个虚拟节点树。</li><li>  在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对于的 update 来修改视图。这个视图主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。</li></ul><p>简单点来说，在 Vue 的底层实现上，Vue 将模版编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应式系统。在状态改变时，Vue 会计算出重新渲染组件的最小代价并应用到 DOM 操作上</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/o0pdzflrj8alc6.png" alt="模板转换过程"></p><p>通过以上图帮助理解模板转换成视图的过程，由此也可得出，模板转换视图的关键词：模板函数（render）、VNode、patch</p><ul><li>  渲染函数：用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板（template）编译成渲染函数（render），当然我们也可以不写模板，直接写渲染函数，以获得更好的性能。</li><li>  VNode 虚拟节点：它可以代表一个真实的 DOM 节点。通过 createElement 方法能将 VNode 渲染成 DOM 节点。简单来说 vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。</li><li>  patch： 虚拟 DOM 最核心的部分，它可以将 Vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于 Snabbdom 实现的。并在其基础上做了很多调整和改进。</li></ul><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/kaypjulrj8zejg.png" alt="视图转换"></p><h2 id="模板编译原理"><a href="#模板编译原理" class="headerlink" title="模板编译原理"></a>模板编译原理</h2><p>模板编译中有个环节是将模板编译成 render 函数，这个过程我们把它称作为<strong>编译</strong>。虽然我们可以为组件编写 render 函数，但使用 template 模板更加直观，也更符合我们的开发习惯。</p><p>Vue.js 提供了两个版本，一个是 Runtime + Compiler，一个是 Runtime Only。前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render 函数</p><h3 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\platforms\web\entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="title function_">warn</span>(<span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">    <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span>;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">                    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">                template,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                    shouldDecodeNewlines,</span><br><span class="line">                    shouldDecodeNewlinesForHref,</span><br><span class="line">                    <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                    <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="variable language_">this</span></span><br><span class="line">            );</span><br><span class="line">            options.<span class="property">render</span> = render;</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码之前分析过，由此也可知编译入口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">    template,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable language_">this</span></span><br><span class="line">);</span><br><span class="line">options.<span class="property">render</span> = render;</span><br><span class="line">options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br></pre></td></tr></table></figure><p>compileToFunctions 方法就是把模板 template 编译生成 render 以及 staticRenderFns。</p><p>进入 compileToFunctions 方法中可以看到，compileToFunctions 实际上是 createCompiler 方法的返回值，该方法接受一个编译配置参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: string,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看 crateCompiler 方法 看到，它实际又是通过调用 crateCompilerCreator 方法返回的。<br>这个方法中 有个 baseCompile，真正的编译过程都在这个函数。 所以 baseCompile 才是真正的模板编译流程及原理所在。<br>接下来我们从 createCompilerCreator 开始分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompilerCreator</span> (<span class="attr">baseCompile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createCompiler</span> (<span class="attr">baseOptions</span>: <span class="title class_">CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">compile</span> (</span><br><span class="line">      <span class="attr">template</span>: string,</span><br><span class="line">      options?: <span class="title class_">CompilerOptions</span></span><br><span class="line">    ): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> finalOptions = <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions)</span><br><span class="line">      <span class="keyword">const</span> errors = []</span><br><span class="line">      <span class="keyword">const</span> tips = []</span><br><span class="line">      finalOptions.<span class="property">warn</span> = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">        (tip ? tips : errors).<span class="title function_">push</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="comment">// merge custom modules</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">modules</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">modules</span> =</span><br><span class="line">            (baseOptions.<span class="property">modules</span> || []).<span class="title function_">concat</span>(options.<span class="property">modules</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge custom directives</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">directives</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">directives</span> = <span class="title function_">extend</span>(</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions.<span class="property">directives</span> || <span class="literal">null</span>),</span><br><span class="line">            options.<span class="property">directives</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy other options</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="string">&#x27;modules&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;directives&#x27;</span>) &#123;</span><br><span class="line">            finalOptions[key] = options[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> compiled = <span class="title function_">baseCompile</span>(template, finalOptions)</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        errors.<span class="property">push</span>.<span class="title function_">apply</span>(errors, <span class="title function_">detectErrors</span>(compiled.<span class="property">ast</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      compiled.<span class="property">errors</span> = errors</span><br><span class="line">      compiled.<span class="property">tips</span> = tips</span><br><span class="line">      <span class="keyword">return</span> compiled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compile,</span><br><span class="line">      <span class="attr">compileToFunctions</span>: <span class="title function_">createCompileToFunctionFn</span>(compile)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCompilerCreator 方法返回了一个 createCOmpiler 的函数，接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法 和 compileToFunctions 属性，这个 compileToFunctions 就是对应 $mount 函数调用的 compileToFunctions 方法， 它又是调用 createCompileToFunction 方法的返回值。<br>接下来看下 createCompileToFunction 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompileToFunctionFn</span> (<span class="attr">compile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">compileToFunctions</span> (</span><br><span class="line">    <span class="attr">template</span>: string,</span><br><span class="line">    options?: <span class="title class_">CompilerOptions</span>,</span><br><span class="line">    vm?: <span class="title class_">Component</span></span><br><span class="line">  ): <span class="title class_">CompiledFunctionResult</span> &#123;</span><br><span class="line">    options = <span class="title function_">extend</span>(&#123;&#125;, options)</span><br><span class="line">    <span class="keyword">const</span> warn = options.<span class="property">warn</span> || baseWarn</span><br><span class="line">    <span class="keyword">delete</span> options.<span class="property">warn</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return 1&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">&#x27;It seems you are using the standalone build of Vue.js in an &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;The template compiler cannot work in this environment. Consider &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;templates into render functions.&#x27;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check cache</span></span><br><span class="line">    <span class="keyword">const</span> key = options.<span class="property">delimiters</span></span><br><span class="line">      ? <span class="title class_">String</span>(options.<span class="property">delimiters</span>) + template</span><br><span class="line">      : template</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile</span></span><br><span class="line">    <span class="keyword">const</span> compiled = <span class="title function_">compile</span>(template, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check compilation errors/tips</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">errors</span> &amp;&amp; compiled.<span class="property">errors</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Error compiling template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">          compiled.<span class="property">errors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">`- <span class="subst">$&#123;e&#125;</span>`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">tips</span> &amp;&amp; compiled.<span class="property">tips</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        compiled.<span class="property">tips</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="title function_">tip</span>(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn code into functions</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> fnGenErrors = []</span><br><span class="line">    res.<span class="property">render</span> = <span class="title function_">createFunction</span>(compiled.<span class="property">render</span>, fnGenErrors)</span><br><span class="line">    res.<span class="property">staticRenderFns</span> = compiled.<span class="property">staticRenderFns</span>.<span class="title function_">map</span>(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createFunction</span>(code, fnGenErrors)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check function generation errors.</span></span><br><span class="line">    <span class="comment">// this should only happen if there is a bug in the compiler itself.</span></span><br><span class="line">    <span class="comment">// mostly for codegen development use</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((!compiled.<span class="property">errors</span> || !compiled.<span class="property">errors</span>.<span class="property">length</span>) &amp;&amp; fnGenErrors.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed to generate render function:\n\n`</span> +</span><br><span class="line">          fnGenErrors.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; err, code &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;err.toString()&#125;</span> in\n\n<span class="subst">$&#123;code&#125;</span>\n`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compilerToFunctions 接收3个参数：编译模板 template，编译配置 options 和 Vue 实例 vm<br>最终返回 render 和 staticRenderFns 函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>模板编译过程：template —&gt; compiler(parse,optimize, generate) —&gt; render 函数（VNode）</p><p>模板编译是通过 Compiler 完成，compiler 可以分成 parse、optimize 和 generate 三个阶段，最终得到 render function。</p><p>compile 函数在执行 createCompilerToFunction 的时候作为参数传入，它是 createCompiler 函数中定义的 compile  函数。</p><p>Vue 在实现 compile 的过程中 利用函数柯里化技巧把基础的编译过程函数抽出来，通过 createCompilerCreator(baseCompile) 的方式把真正编译的过程和其他逻辑如对编译配置处理、缓存处理等剥离开。很巧妙的设计</p><p>编译入口最终终于找到了，主要就是执行了如下几个逻辑：</p><ol><li>Parse 解析：解析模板字符串生成 AST<br> Parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成 AST</li><li>Optimize优化：优化语法树<br> Optimize 主要作用是标记 static 静态节点，这是Vue 在编译过程中做优化，后面当 update 视图更新时，patch 过程中 diff 算法会直接跳过静态节点，从而减少 比较的过程 优化 patch 的性能。</li><li>Generate 生成：生成 render<br> Generate 是将 AST 转换成 render function 字符串的过程，得到的结果是 render 字符串已经 staticRenderFns 字符串。<br>最终 baseCompile 的返回值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">ast</span>: ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span></span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终返回了 ast、render、staticRenderFns, 且通过 generate 处理 ast 之后得到的是个对象。</li></ol><p>经历了这三个阶段后，vue 的 模板 template 就转换成 它 渲染 Vnode 所需的 render 函数了。</p><h2 id="Parse-解析"><a href="#Parse-解析" class="headerlink" title="Parse 解析"></a>Parse 解析</h2><p>解析整个模板的时候它的流程应该是这样子的</p><ul><li>HTML 解析器是主线，先用 HTML 解析器进行解析整个模板，在解析过程中如果碰到文本内容，那么就调用文本解析器来解析文本，如果碰到文本中包含过滤器的那就调用过滤器解析器来解析</li></ul><p>parse 解析流程：</p><ol><li>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML解析器、文本解析器和过滤器解析器。</li><li>文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数 parse 中先调用 HTML 解析器 parseHTML 函数对模板字符串进行解析。</li><li>解析器内维护了一个栈，用来保证构建的 AST 节点层级与真正 DOM 层级一致。</li><li>文本解析器的作用就是将 HTML 解析器解析得到的文本内容进行二次解析，解析文本内容中是否包含变量，如果包含变量，则将变量提取出来进行加工，为后续生成 render 函数做准备。</li></ol><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/9s93vdlrjcbzzg.png" alt="parse解析"></p><h2 id="Optimize-优化"><a href="#Optimize-优化" class="headerlink" title="Optimize 优化"></a>Optimize 优化</h2><p>有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点。</p><p>模板编译的最终目的是用模板生成一个 render 函数，而用 render 函数就可以生成与模板对应的 VNode,之后再进行 patch 算法 完成视图渲染。</p><p>patch 算法 用来对比新旧 VNOde 之间的差异。</p><p>在上面我们还说了，静态节点不管状态怎么变化它是不会变的，因此，我们可以在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，告诉后面 patch 过程 打了标记的节点是不需要对比的，只需要 克隆 一份。</p><p>优化阶段实际上就干了两件事：</p><ol><li>在 AST 中找出所有静态节点并打上标记</li><li>在 AST 中找出所有的静态根节点打上标记<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">optimize</span>(<span class="params">root: ?ASTElement, options:CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    isStaticKey = <span class="title function_">genStaticKeysCached</span>(options.<span class="property">staticKey</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    isPlatformReservedTag = options.<span class="property">isReservedTag</span> || no</span><br><span class="line">    <span class="title function_">markStatic</span>(root)</span><br><span class="line">    <span class="title function_">markStaticRoots</span>(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="标记静态节点"><a href="#标记静态节点" class="headerlink" title="标记静态节点"></a>标记静态节点</h3><p>首先先从根节点开始写，先标记根节点是否为静态美蒂娜，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点还有子节点就继续递归，直到标记完所有节点</p><p>静态节点需满足一下几点要求：</p><ul><li>如果使用了 v-pre，那么他就是静态节点</li><li>如果没有使用 v-pre 那么它需要满足<ul><li>不能使用动态绑定语法 即 v-、@、：开头的属性</li><li>不能使用 v-if、v-else 这些</li><li>不能是内置组件，即标签名不能是slot、component</li><li>不能是自定义组件</li><li>节点的所有属性的key 都必须是静态节点才有的key,</li></ul></li></ul><h3 id="标记静态根节点"><a href="#标记静态根节点" class="headerlink" title="标记静态根节点"></a>标记静态根节点</h3><p>和静态节点类似，都是从 AST 根节点向下递归寻找，它要想成为静态根节点，必须满足</p><ul><li>节点本身必须是静态节点</li><li>必须拥有子节点</li><li>子节点不能是只有一个文本节点</li></ul><h2 id="Generate-生成"><a href="#Generate-生成" class="headerlink" title="Generate 生成"></a>Generate 生成</h2><p>根据模板对应的抽象语法树 AST 生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟DOM。</p><h1 id="模板编译整体流程"><a href="#模板编译整体流程" class="headerlink" title="模板编译整体流程"></a>模板编译整体流程</h1><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/x8odshlrjcc69i.jpg" alt="模板编译"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板编译与渲染&quot;&gt;&lt;a href=&quot;#模板编译与渲染&quot; class=&quot;headerlink&quot; title=&quot;模板编译与渲染&quot;&gt;&lt;/a&gt;模板编译与渲染&lt;/h1&gt;&lt;h2 id=&quot;什么是模板编译&quot;&gt;&lt;a href=&quot;#什么是模板编译&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="模板编译和渲染" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%92%8C%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue 的构建和初始化</title>
    <link href="https://monthlygirl.github.io/2024/01/vue-build-init.html"/>
    <id>https://monthlygirl.github.io/2024/01/vue-build-init.html</id>
    <published>2024-01-13T08:06:14.000Z</published>
    <updated>2024-01-13T08:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-的构建和初始化"><a href="#Vue-的构建和初始化" class="headerlink" title="Vue 的构建和初始化"></a>Vue 的构建和初始化</h1><h1 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h1><p>通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本</p><h2 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a>Runtime Only</h2><p>编译时转化，离线编译。</p><p>Runtime Only 版本通常需要借助如  webpack 的 vue-loader工具 把 .vue 文件 编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更 轻量，性能更优。</p><h2 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a>Runtime + Compiler</h2><p>运行时，客户端编译</p><p>如果没对代码做预编译，但又使用了 Vue 的 template 属性 并传入一个字符串，则需要在客户端编译模板，即运行时编译。因为在 Vue2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本，很显然，这个编译过程对性能有一定的损耗。所以我们通常更推荐使用 Runtime- Only 的 Vue.js</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>当代码执行 import Vue from ‘vue’ 的时候，是从这个入口执行代码来初始化 Vue。 Vue 实际 是一个用 Function 实现的类，只能通过 <strong>new Vue()</strong> 实例化。</p><p>为什么 Vue 不用 ES6 的 Class 去实现呢？</p><p>在 Vue 初始化文件中，有很多 xxxMin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，<strong>Vue 按功能把这些扩展分散都多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的</strong>。 这么做的好处就是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p><p>Vue.js 在整改初始化过程中，除了给它的原型 prototype 上扩展方法，还会通过 initGlobal API 给 Vue 这个对象本身扩展全局的静态方法，即 Vue 的全局 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>,<span class="variable constant_">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span></span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了以下几件事情：<br>合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化 data、props、computed、watcher等等。在初始化的最后，如果有检测到 el 属性，则调用 vm.$mount 方法挂在 vm, 挂载的目标就是把模版渲染成最终的 DOM</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p><h2 id="new-Vue-发生了什么-init"><a href="#new-Vue-发生了什么-init" class="headerlink" title="new Vue 发生了什么 - init"></a>new Vue 发生了什么 - init</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        endTag = <span class="string">`vuw-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponents</span>) &#123;</span><br><span class="line">        <span class="comment">// 每个子组件初始化时走这里，这里只做了一些性能优化，</span></span><br><span class="line">        <span class="comment">// 将组建配置对象上的一些深层次属性 放到 vm.$options 选项中，以提高代码的执行效率</span></span><br><span class="line">        <span class="title function_">initInternalComponents</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 初始化根组件时走到这里，合并 Vue 的全局配置到根组件的局部配置，如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中</span></span><br><span class="line"><span class="comment">         * 至于每个子组件的选项合并则发生在两个地方：</span></span><br><span class="line"><span class="comment">         * 1. Vue.component 方法注册的全局组件在注册时做了选项合并</span></span><br><span class="line"><span class="comment">         * 2. &#123; component: &#123; xx &#125;&#125; 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并,包括根组件中的 components 配置</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">       )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> ) &#123;</span><br><span class="line">        <span class="comment">// 设置代理，将 vm 实例上的属性代理到 vm._renderProxy</span></span><br><span class="line">        <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化组件实例关系属性，比如 $parent $children $root $refs 等</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化自定义事件，这里需要注意一点，所以我们在 &lt;comp <span class="doctag">@click</span>=&quot;handleClick&quot; /&gt; 上注册的事件，监听者不是父组件， 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件的插槽信息，得到 vm.$slot， 处理渲染函数，得到 vm.$createElement 方法,即 h 函数，将 render函数转为 vnode 的方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="comment">// 调用 beforeCreate 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化组件的 inject 配置，得到 result[key] = val 形式的配置对象，然后对结果数据进行相应式处理，并代理每个 key 到 vm 实例</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm)</span><br><span class="line">    <span class="comment">// 数据响应式的重点，处理 props、method、data、computed、watch</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件配置项上的 provide 对象，挂载到 vm._provided 属性上</span></span><br><span class="line">    <span class="title function_">initProvide</span>(vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 created 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">        <span class="title function_">mark</span>(endTag)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 配置项上 有 el ，则自动调用 $mount 方法，如果没有需要手动调用</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">        vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了几件事情，合并配置、初始化生命周期、初始化事件、初始化渲染、执行 beforeCrate 钩子、初始化依赖注入内容、初始化 prop、methods、data、computed、watcher，解析组件配置上的 provide 对象，执行 created 钩子，最后 mount 挂载真实 DOM</p><h2 id="Vue-实例挂载-mount"><a href="#Vue-实例挂载-mount" class="headerlink" title="Vue 实例挂载 - $mount"></a>Vue 实例挂载 - $mount</h2><p>Vue 中是通过 $mount 实例方法去挂在 vm 的，$mount 方法的实现是和平台、构建方式相关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idToTemplate = <span class="title function_">cached</span>(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="title function_">query</span>(id)</span><br><span class="line">    <span class="keyword">return</span> el &amp;&amp; el.<span class="property">innerHTML</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydration?: boolean</span>): <span class="title class_">Components</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span> </span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> template, <span class="variable language_">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">                <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                shouldDecodeNewLines,</span><br><span class="line">                shouldDecodeNewlinesForHref,</span><br><span class="line">                <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">            &#125;, <span class="variable language_">this</span>)</span><br><span class="line">            options.<span class="property">render</span> = render</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原先原型上的 $mount 方法</span></span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对 el 做了现在， Vue 不能挂在在 body、html 这样的根节点上，接下来的关键逻辑 — 如果没有定义 render 方法，则会把 el 或 template 字符串转换成 render 方法。在 vue2.0 版本中，所以 vue 的组件渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或 template 属性。最终都会转换成 render 方法， 那么这个过程是 vue 的一个 “在线编译” 的过程，他是调用 compileToFunctions 方法实现的。最后调用原先原型上的 $mount 方法挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el): <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mountComponents</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>$mount</em> 方法支持传入 2 个参数，第一个是 el, 它表示挂载的元素，可以是字符串，也可以说 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。<br>*<em>$mount</em> 方式的实质是调用 mountComponent 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountComponent 核心就是先实例化一个渲染 watcher，在它的回调函数中调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成 虚拟 Node，最终调用 vm._update 更新 DOM。 Watcher 在这里起到两个作用，一个是初始化的时候会执行毁掉你函数，另一个是当 vm 实例中的监测数据发生变化时执行的回调呢函数。<br>函数最后判断为根节点的时候 设置 vm._isMounted 为true，表示这个实例已经挂载了，同时执行 mounted 钩子函数。<br>这里 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 null 则表示当前是根 vue 实例</p><p>mountComponent 会完成整个渲染工作，包含最核心的 2 个 方法： vm._render 和 vm._update</p><h2 id="渲染-DOM-render"><a href="#渲染-DOM-render" class="headerlink" title="渲染 DOM - render"></a>渲染 DOM - render</h2><p>Vue 的 _render 方法是实例的一个私有方法，他用来把实例渲染成一个虚拟 Node</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">        _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">        vm.<span class="property">$slots</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">          vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>vm._render 最终是通过 执行 createElement 方法并返回的是 vnode，它是一个虚拟 node</p><h2 id="生成虚拟-DOM-createElement"><a href="#生成虚拟-DOM-createElement" class="headerlink" title="生成虚拟 DOM - createElement"></a>生成虚拟 DOM - createElement</h2><p>Vue 利用 createElement 方法创建 VNode，createElement 方法实际上是对 _createElement 方法的封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\vdom\create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: any,</span><br><span class="line">  <span class="attr">data</span>: any,</span><br><span class="line">  <span class="attr">children</span>: any,</span><br><span class="line">  <span class="attr">normalizationType</span>: any,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: boolean</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((<span class="attr">data</span>: any).<span class="property">__ob__</span>)) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">is</span>)) &#123;</span><br><span class="line">    tag = data.<span class="property">is</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">key</span>) &amp;&amp; !<span class="title function_">isPrimitive</span>(data.<span class="property">key</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.<span class="property">key</span>)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-primitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instead.&#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.<span class="property">scopedSlots</span> = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.<span class="property">pre</span>) &amp;&amp; <span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_createElement 方法有 5个参数：</p><ul><li>context 表示 VNode 的上下文环境，它是 Component 类型</li><li>tag 表示标签，它可以是一个 字符串，也可以是一个 Component</li><li>data 表示 VNode 的数据，它是一个 VNodeData 类型</li><li>children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准版 的 VNode 数组</li><li>normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的，经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array</li></ul><p>每个 VNode 有 children，children 的每个元素也是一个 VNode，这样就形成了一个 Vnode tree，它很好的描述了我们的 DOM tree</p><p>回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 Vnode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成。</p><h2 id="渲染真实-DOM-update"><a href="#渲染真实-DOM-update" class="headerlink" title="渲染真实 DOM - update"></a>渲染真实 DOM - update</h2><p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。_update 方法的作用是把 VNode 渲染成真实的 DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\lifecycle.js</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>_update 的核心就是调用 vm.patch 方法，这个方法实际上在不同的平台上有不同的实现方式。比如，服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器渲染中，它指向了 patch 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules form <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = platformModules.<span class="title function_">contact</span>(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">Function</span> = <span class="title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中 nodeOps 封装了一系列 DOM 操作的方法， modules 定义了一些模块的钩子函数的实现。</p><p>createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法。具体源码位置src\core\vdom\patch.js，源码过长就不放出来。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>了解了 Vue 的整个初始化过程，得出</p><ul><li><p>Vue 初始化过程是怎样的(new Vue() 发生了什么)</p><ol><li>_init() 初始化数据、状态等<ul><li>处理组件配置项<ul><li>初始化组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</li><li>初始化每个子组件做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</li></ul></li><li>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs等</li><li>处理自定义事件</li><li>调用 beforeCreate 钩子函数</li><li>初始化组件的 inject配置，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应处理，并代理每个 key 到 vm 实例上</li><li>数据响应式，处理 props、methods、data、computed、watch 等选项</li><li>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</li><li>调用 created 钩子函数</li><li>如果有 el 配置，自动 $mount </li><li>进入挂载阶段</li></ul></li></ol></li><li><p>生命周期过程是什么<br><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-的构建和初始化&quot;&gt;&lt;a href=&quot;#Vue-的构建和初始化&quot; class=&quot;headerlink&quot; title=&quot;Vue 的构建和初始化&quot;&gt;&lt;/a&gt;Vue 的构建和初始化&lt;/h1&gt;&lt;h1 id=&quot;构建版本&quot;&gt;&lt;a href=&quot;#构建版本&quot; class=&quot;</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="构建和初始化" scheme="https://monthlygirl.github.io/tags/%E6%9E%84%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>复杂异步嵌套的执行机制</title>
    <link href="https://monthlygirl.github.io/2024/01/Interview-event-loop&amp;async/await.html"/>
    <id>https://monthlygirl.github.io/2024/01/Interview-event-loop&amp;async/await.html</id>
    <published>2024-01-11T13:41:30.000Z</published>
    <updated>2024-01-11T13:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂异步嵌套逻辑分析"><a href="#复杂异步嵌套逻辑分析" class="headerlink" title="复杂异步嵌套逻辑分析"></a>复杂异步嵌套逻辑分析</h1><hr><h2 id="async-await-在事件循环中的表现"><a href="#async-await-在事件循环中的表现" class="headerlink" title="async/await 在事件循环中的表现"></a>async/await 在事件循环中的表现</h2><hr><p>对于不同Chrome 版本，<strong>async/await</strong> 会有两种表现，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不同的 Chrome 版本，会输出两种结果</p><ul><li><strong>1 3 4 2 5</strong></li><li><strong>1 3 4 5 2</strong></li></ul><blockquote><p>根据 最新的 ECMAScript 规范下，第一种为正确表现</p></blockquote><h2 id="最新的-ECMAScript-规范"><a href="#最新的-ECMAScript-规范" class="headerlink" title="最新的 ECMAScript 规范"></a>最新的 ECMAScript 规范</h2><p>最新的 ECMAScript 规范中，await 直接使用 Promise.resolve() 相同的语义，也就是说，如果 await 后面跟的是一个 Promise，则直接返回 Promise 本身。如果不是，则使用 Promise.resolve 包裹后返回。<br>所以上面的代码我们可以理解为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>console.log(2) 在第一轮事件循环时就加入微任务队列，然后 console.log(5) 才加入微任务队列，所以 2 的打印顺序在前。</p><h2 id="老版的-ECMAScript-规范"><a href="#老版的-ECMAScript-规范" class="headerlink" title="老版的 ECMAScript 规范"></a>老版的 ECMAScript 规范</h2><p>await 后不论是否为 Promise，都会产生一个新的 Promise，再将后面的内容 resolve 出去</p><blockquote><p> 其实最初关于 async/await 的相关规范和上述最新规范中行为是一致的，但是中间有一段时间 ECMA 规范有一些变化，最后又变回来了。</p></blockquote><p>根据老版规范，上述代码又可以理解成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve1</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="title function_">resolve2</span>()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 resolve1 内又 resolve 了 一个 Promise，所以在这里已经是异步任务了，而不是立即变为 fulfilled 的状态，所以 console.log(2) 并不是在第一轮事件循环中被加入微任务队列，而console.log(5) 是第一轮事件循环中就被加入到任务队列，最终打印顺序为 1 3 4 5 2</p><h1 id="复杂异步嵌套"><a href="#复杂异步嵌套" class="headerlink" title="复杂异步嵌套"></a>复杂异步嵌套</h1><p>根据上面的分析来做套题，帮助理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;),<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：script start、async1 start、async2、promise1、script end、async2 end、promise2、setTimeout</p><ol><li>定义了 async1、async2 函数，打印 script start </li><li>执行 setTimeout 回调，交由 web API, web API 将它挂入宏任务队列</li><li>执行 async1 函数，打印 async1 start</li><li>执行 async2 函数，打印 async2，将 async2 end 挂入 微任务队列</li><li>执行 new Promise ，同步执行传入构造函数的函数， 打印 promise1，将 promise2 挂入 微任务队列</li><li>打印 script end，宏任务 执行完毕</li><li>执行微任务 打印 async2 end</li><li>执行微任务 打印 promise2，微任务执行完毕，一次事件循环结束</li><li>执行下一个宏任务，查看宏任务队列，打印 setTimeout。</li><li>宏任务和 微任务都执行完毕</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;a href=&quot;#复杂异步嵌套逻辑分析&quot; class=&quot;headerlink&quot; title=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;/a&gt;复杂异步嵌套逻辑分析&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;async-await-在事件循环中的表现&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="事件循环" scheme="https://monthlygirl.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
    <category term="async await" scheme="https://monthlygirl.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>重排（reflow）和重绘（repaint）</title>
    <link href="https://monthlygirl.github.io/2024/01/Interview-reflow-repaint.html"/>
    <id>https://monthlygirl.github.io/2024/01/Interview-reflow-repaint.html</id>
    <published>2024-01-09T13:21:16.000Z</published>
    <updated>2024-01-09T13:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h1><ol><li>HTML -&gt; 被 HTML 解析器解析成 DOM 树</li><li>CSS -&gt; 被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树 生成一颗渲染树（Render Tree） 这一个过程称之为 Attachment</li><li>生成布局（flow），浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制（paint）在屏幕上，显示出整个页面</li></ol><p>4和5 结合起来也就是我们所说的渲染，同时也是最耗时的部分</p><h1 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h1><p>在网页生成时，至少会渲染一次。在用户访问的过程中，还会不断触发重绘和重排，从而影响性能。所以在开发过程中应该避免页面的重排重绘。</p><h1 id="什么是重绘、重排？"><a href="#什么是重绘、重排？" class="headerlink" title="什么是重绘、重排？"></a>什么是重绘、重排？</h1><p>什么是重绘、重排？从字面意思就可以理解</p><ul><li>重绘：重新绘制，一般发生在布局不变，视觉上变化的时候，比如阴影颜色</li><li>重排：重新排列，一般发生在布局变化或元素大小发生变化时</li></ul><p>如上概念可以得出： </p><ol><li>单单改变元素的外观，肯定不会引起网页的重新生成布局。</li><li>改变元素大小和布局变化时，那元素乃至周边的 DOM 可能都需要重新绘制。</li></ol><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h1 id="重排（reflow）："><a href="#重排（reflow）：" class="headerlink" title="重排（reflow）："></a>重排（reflow）：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><pre><code>当 DOM 的变化影响了元素的几何信息（如位置、大小等），浏览器都需要重新计算元素的几何属性。这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素</code></pre><h2 id="下面的情况会发生重排："><a href="#下面的情况会发生重排：" class="headerlink" title="下面的情况会发生重排："></a>下面的情况会发生重排：</h2><pre><code>+ 页面初始渲染，这是开销最大的一次重排+ 添加/删除可见的 DOM 元素+ 改变元素位置+ 改变元素尺寸，比如 边距、填充、边框、宽度高度等+ 改变元素内容，比如文字数量、图片大小等+ 改变元素字体大小+ 改变浏览器窗口尺寸，比如 resize 事件发生时+ 激活 css 伪类 比如 :hover+ 设置 style 属性的值，+ 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等</code></pre><table><thead><tr><th>常见引起重排的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewNeeded()</td><td></td><td></td></tr></tbody></table><h2 id="重排的影响范围："><a href="#重排的影响范围：" class="headerlink" title="重排的影响范围："></a>重排的影响范围：</h2><pre><code>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围 DOM 重新排列，影响范围有两种：+ 全局范围：从根节点 html 开始对整个渲染树进行重新渲染+ 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</code></pre><h3 id="全局范围重排"><a href="#全局范围重排" class="headerlink" title="全局范围重排"></a>全局范围重排</h3><pre><code>一般情况下当根节点 或 子节点发生重大布局变化时，往往会发生全局范围的重排</code></pre><h3 id="局部范围重排"><a href="#局部范围重排" class="headerlink" title="局部范围重排"></a>局部范围重排</h3><pre><code>只在某个 DOM 内部触发重排，一个元素形成 BFC 后，这个元素内部发生变化不会影响到外部的其他元素，只会影响该元素内部的其他元素</code></pre><h2 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h2><pre><code>重排的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓。通过减少重排的负面影响来提供用户体验的最简单方式就是尽可能的减少重排次数</code></pre><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><pre><code>尽量以局部布局的形式组织 html 结构，尽可能小的影响重排范围+ 不要使用 table 布局，可能一个小改动会造成整个 table 的重新布局。不得已的情况下，可以设置 table-layout: auto; 或者是 table-layout: fixed 这样可以让 table 一行一行的渲染。这样的做法是为了限制 reflow 的影响范围。+ 减少 DOM 嵌套</code></pre><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><ul><li>样式集中改变， 不频繁的操作样式。</li><li>分离 DOM 读写操作，DOM 的多个读写操作，应该放在一起，不要两个读操作之间，加入一个写操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>原来的操作会触发四次重排，修改后只会触发一次，这是因为我们的浏览器的渲染机制。<br>当我们修改元素的几何属性，导致浏览器发生重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定数量或到了一定的时间间隔，浏览器就会批量操作。</p><ul><li><p>将 元素 形成 BFC</p></li><li><p>优化动画<br>  将动画效果应用在 BFC 元素上，减少重排范围。动画效果可以牺牲一些平滑，来换取速度，这中间的度自己衡量。比如实现一个动画 以1个像素单位移动这样最平滑，但是 layout 会过于频繁，大量消耗 CPU 资源，如果以3个像素为单位移动则会好很多</p><ul><li><p>启用 GPU 加速，GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图像操作交给 GPU 来完成。因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p>GPU 加速通常包括以下几个部分： Canvas2D，布局合成， CSS3 转换（transitions），CSS3 3D 变换（transform），WebGl 视频</p></li></ul></li></ul><h1 id="重绘（repaints）"><a href="#重绘（repaints）" class="headerlink" title="重绘（repaints）"></a>重绘（repaints）</h1><p>当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，就叫重绘</p><h2 id="常见引起重绘的属性"><a href="#常见引起重绘的属性" class="headerlink" title="常见引起重绘的属性"></a>常见引起重绘的属性</h2><table><thead><tr><th>常见引起重绘的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td></td><td>background-size</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。Layout： 重排，又叫回流。Paint：重绘，重绘重排这些步骤都是在 CPU 中发生的。 Composite Layers：CPU 把生成的 BitMap 传输到 GPU ，渲染到屏幕上</li><li>CSS3 就是在 GPU 发生的： Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;页面生成的过程：&quot;&gt;&lt;a href=&quot;#页面生成的过程：&quot; class=&quot;headerlink&quot; title=&quot;页面生成的过程：&quot;&gt;&lt;/a&gt;页面生成的过程：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HTML -&amp;gt; 被 HTML 解析器解析成 DOM 树&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="reflow、repaint" scheme="https://monthlygirl.github.io/tags/reflow%E3%80%81repaint/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-JavaScript.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-JavaScript.html</id>
    <published>2023-12-24T12:19:58.000Z</published>
    <updated>2023-12-24T12:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonJS、AMD、CMD-和-ESM"><a href="#CommonJS、AMD、CMD-和-ESM" class="headerlink" title="CommonJS、AMD、CMD 和 ESM"></a>CommonJS、AMD、CMD 和 ESM</h1><h2 id="一、Common-JS"><a href="#一、Common-JS" class="headerlink" title="一、Common JS"></a>一、Common JS</h2><ol><li>CommonJS 它是通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务端的解决方案，它是以同步的方式来引入模块的。（因为服务端的文件都存储在本地磁盘，所以读取起来非常快，用同步的方式没有问题，但在浏览器端，由于模块加载是使用网络请求的，所以使用 异步的方式更合适）</li><li>CommonJS 输出的是一个只的拷贝，会有缓存，这个值一旦输出，模块内部更新， 对于输出的这个值不会有影响</li><li>CommonJS 是在运行时加载的，CommonJS 模块是个对象，输入时会先加载一整个模块生成一个对象，从这个对象上取值</li></ol><h2 id="二、AMD"><a href="#二、AMD" class="headerlink" title="二、AMD"></a>二、AMD</h2><ol><li><p>AMD 采用 异步方式来加载模块的，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成再去执行回调函数。require.js 实现了 AMD 规范</p></li><li><p>AMD 在使用模块依赖时，必须先声明依赖，并且依赖模块加载完成就立即执行，依赖模块的顺序可能和我们书写的并不一致</p></li></ol><h2 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h2><ol><li>CMD 和 AMD 一样都是为了解决异步模块加载问题。它和 AMD 的区别在于 模块定义时对依赖的处理不同 和依赖模块的执行时机处理不同。</li><li>CMD 模块依赖可以就近声明，使用时再去声明</li><li>CMD 会先将模块依赖下好，等待代码执行时再去执行，所以模块依赖执行顺序和我们书写的顺序一致。</li></ol><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><ol><li><p>ESM 是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</p></li><li><p>ESM 输出的是一个值的引用，即模块内部值更新，所有引用该值的地方都会更新</p></li><li><p>ESM 是在代码解析时生成的，采用静态优化 是静态执行的，因此不能有变量、表达式等这些只有在代码运行时才能得到结果写法。</p></li><li><p>ESM 对外输出的是一个接口，必须和模块内部建议一对一的关系。</p></li></ol><p>5 ESM import 输入的变量都是只读的，并且import 会有提升效果，提升到首部提前执行</p><ol start="6"><li>ESM import 多个重复语句，只会执行一次。</li></ol><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">executor</span>(resolve, reject) </span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span>  <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>))</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol 表示一个独一无二的值，它引入的原因是 由于 ES5 的对象属性都是字符串，我们再去使用别人提供的对象时，如果要在这个对象上添加属于 有可能会有属性冲突， 如果对象中的每个值都是独一无二的，那么就没有这种问题了，于是引入了 Symbol</p><p>Symbol 是原始数据类型中独一无二的值, js 一共有五种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。<br>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h1 id="cookie、sessionStorage、localStorage-的区别"><a href="#cookie、sessionStorage、localStorage-的区别" class="headerlink" title="cookie、sessionStorage、localStorage 的区别"></a>cookie、sessionStorage、localStorage 的区别</h1><p>这三种 都是浏览器存储信息的一种手段， 共同点：都是保存在浏览器端，且是同源的</p><ol><li><p>cookie：</p><ul><li>存储容量限制，一般是在 几 kb （4kb\5kb）</li><li>cookie 可以设置具体的过期时间，可以是会话级（浏览器关闭时失效）或者具体的过期日期</li><li>cookie 用于客户端和服务器之间传输，每次请求都会被发送到服务器端，因此对于跨域请求和安全性有一定的限制</li><li>可以通过设置域名路径来控制 cookie 的作用域，实现跨子域和跨路径的共享</li></ul></li><li><p>Session Storage</p><ul><li>存储容量可以达几M，5M左右，但是会话级别的，浏览器一关闭 就自动清除</li><li>它只存储在客户端，每次请求不会被发送到服务器端</li><li>仅限于当前源，不同页面间不能共享数据</li></ul></li><li><p>localStorage</p><ul><li>存储容量比 sessionStorage 更大，且数据可以长期保存</li><li>可以持久化存储数据，关闭浏览器会话不会数据被清除</li><li>仅限于当前源，不同页面间不能共享数据</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CommonJS、AMD、CMD-和-ESM&quot;&gt;&lt;a href=&quot;#CommonJS、AMD、CMD-和-ESM&quot; class=&quot;headerlink&quot; title=&quot;CommonJS、AMD、CMD 和 ESM&quot;&gt;&lt;/a&gt;CommonJS、AMD、CMD 和 E</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-Webpack.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-Webpack.html</id>
    <published>2023-12-24T09:28:17.000Z</published>
    <updated>2023-12-24T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js</p><h2 id="1-有哪些常用的-loader"><a href="#1-有哪些常用的-loader" class="headerlink" title="1. 有哪些常用的 loader"></a>1. 有哪些常用的 loader</h2><ul><li>file-loader: 处理文件的 loader,处理文件导入地址并替换成其访问地址，并把文件输出到相应位置</li><li>babel-loader: 将 es6 转 es5</li><li>sass-loader: 将 sass 转 css</li><li>css-loader: 处理样式间的相互引用</li><li>ts-loader: 处理 TS 文件</li><li>vue-loader： 处理 .vue 文件<br>….</li></ul><p>loader 的作用就是用于处理源文件代码，将它们转换成 webpack 可处理的模块，处理源码文件时，针对不同的源码模块使用 不同的 loader 处理</p><p>loader 的执行顺序是从右往左，从下往上，</p><blockquote><p>modules: {<br>    rules: [{<br>        use: [<br>            ‘style-loader’<br>            ‘css-loader’, ‘postcss-loader’, ‘sass-loader’]<br>    }]<br>}</p></blockquote><h2 id="2-常见的-Plugin"><a href="#2-常见的-Plugin" class="headerlink" title="2.常见的 Plugin"></a>2.常见的 Plugin</h2><ul><li>html-webpack-plugin: dist 下生成 html 文件，依赖于 html-loader</li><li>clean-webpack-plugin: 清除目录文件</li><li>mini-css-extract-plugin: 分离样式，提取css 文件，按需加载</li><li>webpack-bundle-analyzer: webpack打包分析插件<br>….</li></ul><h2 id="3-loader-和-plugin-间的区别"><a href="#3-loader-和-plugin-间的区别" class="headerlink" title="3.loader 和 plugin 间的区别"></a>3.loader 和 plugin 间的区别</h2><p>loader 是一个文件转换器，因为 webpack 只能识别 js 和 json 文件，所以其他类型的文件需要通过 loader 进行转换<br>比如： a.scss 转 b.css， 单纯的就是一个 文件转换的过程<br>loader 只运行在打包文件前</p><p>plugin 用于扩展 webpack 的功能，用于执行任意类型的任务，所有 loader 解决不了的事都可以使用 plugin 来解决。如：代码分割、代码压缩<br>plugin 在整个项目编译周期都起作用</p><h2 id="4-plugin-的组成部分"><a href="#4-plugin-的组成部分" class="headerlink" title="4.plugin 的组成部分"></a>4.plugin 的组成部分</h2><ul><li>plugin 本质是一个 node 模块，这个模块到处一个 js 类</li><li>它的原型需要定义一个 apply 方法</li><li>通过 compiler 来获取 webpack 内部钩子，获取打包阶段的各个流程。webpack 的内部钩子 分为 异步 构字 和同步构子，异步钩子需要执行对应回调</li><li>通过 compilation 操作 webpack 内部实例特定的数据</li></ul><h1 id="webpack-和-gulp-的不同"><a href="#webpack-和-gulp-的不同" class="headerlink" title="webpack 和 gulp 的不同"></a>webpack 和 gulp 的不同</h1><ul><li><p>webpack 基于入口，会自动解析入口所需加载的所有资源文件，用不同的loader 来处理不同的文件</p></li><li><p>gulp 是基于任务和流的，找到一个文件模块 对其做一系列的链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web 的构建流程</p></li><li><p>gulp 需要将整个构建 拆成多个 task 并合理控制所有的 task 的调用关系</p></li><li><p>webpack 只需找到入口，并且清楚对不同资源应用什么 loader 进行加工处理</p></li><li><p>gulp 常见 api: gulp.src, gulp.dest, gulp.pipe, gulp.watch 等</p></li></ul><h1 id="npm、yarn、pnpm"><a href="#npm、yarn、pnpm" class="headerlink" title="npm、yarn、pnpm"></a>npm、yarn、pnpm</h1><h2 id="1-npm-3-0之前"><a href="#1-npm-3-0之前" class="headerlink" title="1. npm 3.0之前"></a>1. npm 3.0之前</h2><p>在 npm 3.0 之前，安装项目的 node_modules 包，会出现嵌套结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">  ｜--- foo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br><span class="line">  ｜--- zoo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br></pre></td></tr></table></figure><p>这种嵌套结构会出现 2 个问题</p><ol><li>层级嵌套太深，导致文件路径过长</li><li>重复安装包，导致项目体积变大</li></ol><p>为了解决这些问题，于是 yarn 横空出世</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn采用 扁平化依赖项来解决 npm 的问题</p><p>扁平化依赖项就是将所有依赖铺平，放在同一级的依赖目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    |-- foo</span><br><span class="line">        |-- index</span><br><span class="line">    |-- bar</span><br><span class="line">        |-- index</span><br><span class="line">    |-- zoo</span><br><span class="line">        |-- index</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这种层级依赖的管理下， node_modules 中不会有层级深的情况，并且在安装依赖时，会先查找当前 node_modules 中是否有这个包，所有也解决了重复安装包 体积变大的问题。<br>解决了 npm 3.0 之前的问题，后续npm 也延用了 yarn 的方案。</p><p>但同时引进了新的问题 – 幽灵依赖 </p><h2 id="幽灵依赖依赖"><a href="#幽灵依赖依赖" class="headerlink" title="幽灵依赖依赖"></a>幽灵依赖依赖</h2><p>幽灵依赖指的是：当前项目中的package.json 并没有该依赖，在代码中确可以引用。<br>这个原因是因为 npm 包被铺平了，依赖中的依赖也被安装了，所以在当前项目 package.json  没有声明该依赖也可以引用。</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>pnpm 中解决了幽灵依赖的问题。<br>使用 pnpm 管理项目依赖，pnpm 不允许安装 package.json 中没有声明的依赖。</p><p>同时 pnpm 还做了另一个优化，使用 软链接和硬链接 来管理依赖，减少了磁盘空间。</p><h2 id="什么是软链接"><a href="#什么是软链接" class="headerlink" title="什么是软链接"></a>什么是软链接</h2><p>软链接： 相当于一个符号链接，指向目标文件地址，类似 window 电脑的快捷方式。<br>修改软链接，不会影响到目标文件</p><h2 id="什么是硬链接"><a href="#什么是硬链接" class="headerlink" title="什么是硬链接"></a>什么是硬链接</h2><p>硬链接：链接符号存储了引用地址，类似 js 中的对象引用。<br>修改硬链接的内容，引用的目标文件会受到影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"></span><br><span class="line">b.<span class="property">age</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="pnpm-原理"><a href="#pnpm-原理" class="headerlink" title="pnpm 原理"></a>pnpm 原理</h2><p>根据软硬链接实现的<br>使用 pnpm 安装依赖时，在 node_modules 中会出现一个.pnpm 的文件和其他依赖文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">|-- .<span class="property">pnpm</span>/</span><br><span class="line">|-- element/</span><br><span class="line">|-- and</span><br></pre></td></tr></table></figure><p>此时，依赖文件 如 element 中实际是一个软链接，指向了 .pnpm 中的 element<br>即 真实路径是 .pnpm/element.3.2.1/node_modules/element<br><code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules&lt;/name&gt;</code></p><p>在由 pnpm/<name>@<version>/node_modules</name> 硬链接到 .pnpm/store 中去</p><p>所以 pnpm 通过这种方式 不仅解决了幽灵依赖的问题，还减少了磁盘空间，下载速度快。</p><h1 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h1><p>CSS 预处理器本质是为 CSS 增加一些可编程的特性，使 CSS 更加强大。</p><ol><li><p>postcss<br> 提供了可以用 JS 代码来处理 CSS，负责把 CSS 代码解析成 AST，再由插件对 AST 进行处理，插件可以实现多样化，如：支持变量和混入，增加浏览器前缀等</p><p> postcss 的作用</p><ul><li>将 css 解析为 JS 可操作的 AST</li><li>调用差距处理 AST 并等到结果</li></ul></li></ol><p>postcss 一般配合 构建工具使用<br>常用的有：<br>    auto prefixer<br>    postcss-px-to-viewport<br>    cassnano 压缩css 等</p><ol start="2"><li><p>sass 在完全兼容 css 的前提下，提供变量、嵌套、混合 自定义函数等编程能力，less 同理</p></li><li><p>sass 和 less 的区别</p><ul><li>sass 和 less 在语法上有些共性，如：嵌套规则、运算、作用域等</li><li>主要的不同在于它们的实现方式<br>less 基于 js， sass 基于 ruby<br>变量的区别： less 用 @， sass 用 $<br>sass 支持条件语句 if{} else{} for{}，less 不支持</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js&lt;/</summary>
      
    
    
    
    
    <category term="Webpack" scheme="https://monthlygirl.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-CSS.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-CSS.html</id>
    <published>2023-12-22T10:09:53.000Z</published>
    <updated>2023-12-22T10:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Css-的优先级"><a href="#Css-的优先级" class="headerlink" title="Css 的优先级"></a>Css 的优先级</h1><p>important &gt; 内联样式 &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器</p><h1 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别"></a>页面导入样式时，使用 link 和 @import 有什么区别</h1><ol><li><p>link 属于 XHTML 标签，除了加载 CSS 外 还能用于定义 rel 等属性； @import 是提供给 css 的，只能用于加载 css</p></li><li><p>页面被加载时 link 会同时被加载，而 import 引用的 css 会等到页面加载完后在加载</p></li><li><p>import 有兼容性问题，只有在 IE5以上才能被识别，link 是 XHTML 标签，没有兼容性问题</p></li><li><p>link 支持使用 js 控制 DOM 去改变样式，import 不支持</p></li></ol><h1 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h1><p>css 盒模型 分为 IE 盒模型(border-box) + W3C 盒模型(content-box)<br>盒模型包括：content + padding + border + margin<br>IE 盒模型 和 W3C 盒模型的区别是 IE 盒模型的 content 包含 padding + border</p><h1 id="CSS-选择器有哪些？-哪些属性可以继承"><a href="#CSS-选择器有哪些？-哪些属性可以继承" class="headerlink" title="CSS 选择器有哪些？ 哪些属性可以继承"></a>CSS 选择器有哪些？ 哪些属性可以继承</h1><ol><li>id 选择器</li><li>class 选择器</li><li>标签选择器</li><li>相邻选择器</li><li>子代选择器</li><li>属性选择器</li><li>通配符选择器</li><li>伪类选择器</li></ol><p>可继承属性：font-size,font-family, color 等<br>不可继承：border、padding、margin、width、height 等</p><h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p>区别：<br>    1. 伪类本质上是为了祢补常规css 选择器不足<br>    2. 伪元素的本质是创建了一个有内容的虚拟元素<br>    3. css3 中 伪类和伪元素的写法不同</p><p>伪类有： :active, :hover, :checked :nth-child 等<br>伪元素： ::after、::before、::first-letter 等</p><h1 id="css-的-content-属性的作用"><a href="#css-的-content-属性的作用" class="headerlink" title="css 的 content 属性的作用"></a>css 的 content 属性的作用</h1><p>css 的 content 属性 专门应用在 before / after 上，用来插入生成内容</p><h1 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h1><p>BFC 指的是 块级格式化的上下文，一个元素形成了BFC 后，那么它的内部元素变化不会影响到外部元素，同样外部元素变化也不会影响到内部元素。<br>一个 BFC 就像是一个隔离区域，和其他区域互不影响。<br>一般来说，一个根元素就是一个 BFC，浮动和绝对定位也会形成 BFC， display 属性为 inline-block、flex 时也会创建 BFC 。overflow 的值不为 visible 时也会创建 BFC</p><h1 id="什么是-IFC"><a href="#什么是-IFC" class="headerlink" title="什么是 IFC"></a>什么是 IFC</h1><p>IFC 指的是 行级格式化上下文，它有着一些布局规则：</p><ol><li>行级上下文内部的盒子会在水平方向一个一个的方知</li><li>当一行不够时，会自动切换下一行</li><li>行级上下文的高度有内部高度最高的内联盒子决定。</li></ol><h1 id="什么是浮动、高度塌陷？如何清除浮动"><a href="#什么是浮动、高度塌陷？如何清除浮动" class="headerlink" title="什么是浮动、高度塌陷？如何清除浮动"></a>什么是浮动、高度塌陷？如何清除浮动</h1><p>在文档流中，父元素的高度默认是由子元素撑开的<br>也就是子元素多高，父元素就多高<br>但是当为 子元素设置浮动后 float ，子元素会脱离文档流<br>此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷</p><p>父元素高度塌陷，父元素下的所有元素都会向上移动。</p><p>通过清除浮动、设定父元素高度可以解决此问题，但我们一般不推荐写死父元素的高度来解决。</p><p>清除浮动的方式：</p><ol><li>使用 clear 来清除浮动</li></ol><p>clear 一般配合伪元素来一起使用</p><p>.div::before {<br>    content: ‘’;<br>    display: block;<br>    clear: both;<br>}</p><ol start="2"><li><p>使用 BFC 来清除浮动（BFC 中可以使用影响最小的 overflow: hidden 来清除浮动）</p></li><li><p>BFC 有兼容性问题，对于I E也可以使用 zoom: 1 来清除浮动<br>zoom 属性是 IE 浏览器专有属性，它可以设置或检索对象的缩放比例，解决 ie 下比较奇葩的bug。触发ie 的haslayout 属性</p></li></ol><p>原理是所设置的元素会被扩大和缩小，高度和宽度会重新计算，触发重新渲染。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Css-的优先级&quot;&gt;&lt;a href=&quot;#Css-的优先级&quot; class=&quot;headerlink&quot; title=&quot;Css 的优先级&quot;&gt;&lt;/a&gt;Css 的优先级&lt;/h1&gt;&lt;p&gt;important &amp;gt; 内联样式 &amp;gt; id 选择器 &amp;gt; class 选择器</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://monthlygirl.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-Vue.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-Vue.html</id>
    <published>2023-12-22T10:09:53.000Z</published>
    <updated>2023-12-22T10:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-router-的实现"><a href="#vue-router-的实现" class="headerlink" title="vue-router 的实现"></a>vue-router 的实现</h1><p>vue-router 的作用：通过改变 URL，在不重新请求页面的情况下 更新视图</p><p>vue-router 的两种模式</p><p>一、hash 模式</p><p>vue hash 模式路由，在 URL 上带有 # 号，hash 路由 通过 改变 # 号后面的路由来更新视图。# 号后面的URL 改变 不会触发浏览器重新发起请求。</p><p>hash 模式的原理是根据 onhashchange 来监听 URL 变化，通过 window.location.hash 来获取当前 url 值</p><p>二、history 模式 （基于 HTML5 history API）</p><p>history 模式 url 上不会带有 # 号，通过 pushState 、replaceState 、popState实现跳转页面且不重新发送请求。</p><p>使用 pushState 跳转 url 不会向服务器发起新的文档请求，并且它只能实现当前域的跳转，并且会添加一条访问记录<br>popState 可以监听当前url 是否改变，history.back, history.forward,history.go 都会触发 popState</p><p>history.pushState 和 history.replaceState 不会触发 popState 事件</p><p>使用 history 路由 虽然也可以实现像 hash 路由那样实现跳转 url 不重新发起文档请求，但用户在刷新页面时还是会重新发起请求，为了避免这种情况，所以需要服务端配合重定向返回 html。</p><p>三、浏览器的 history.pushState 和 框架中的 history.pushState 的区别</p><p>路由框架的pushState与history.pushState是不一样的，路由框架的pushState不仅调用了history.pushState改变了url，更重要的是它还多了一步操作，即根据这个url销毁了旧组件，渲染了新组件；至于state里面的key值，则是为了兼容hashHistory。</p><h1 id="Vuex-的底层实现"><a href="#Vuex-的底层实现" class="headerlink" title="Vuex 的底层实现"></a>Vuex 的底层实现</h1><p>一、vuex 的核心流程<br>    vue component 接受交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getter 获取到 state 新值，重新渲染 vue component</p><p>二、vuex 的底层原理</p><ul><li>state: 提供一个响应式数据，通过 new vue 实现<pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this._vm = new Vue(&#123;</span><br><span class="line">    $state: state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>getter: 借助 vue 的计算属性 computed 来实现缓存</li><li>mutation： 更改 state，通过 commit 修改 state，是唯一修改state 的地方，并且是同步的</li><li>action: 触发 mutation 方法， action 可以包含些异步操作</li><li>module： Vue.set 动态 添加 state 到响应式数据中去。实际是根据 store 配置递归建立相应的 module 和 module间的父子关系，在根据 namespace 来分割模块，使得 commit/dispatch 时需要制定 namespace</li></ul><h1 id="Vue-provide-和-inject"><a href="#Vue-provide-和-inject" class="headerlink" title="Vue provide 和 inject"></a>Vue provide 和 inject</h1><p>provide、inject 是 vue 组件通信的一种方式，允许祖先组件向其所有的子孙后代 注入一个依赖，不论组件层次有多深</p><p>原理</p><ul><li>依赖注入，其核心原理就是通过 $parent 向上查找祖先组件的 provide，找到则赋值给 inject ，未找到给其 default 值。依赖注入原理和 javascript 中 instanceof 操作符原理类型，instance of 中，通过 <strong>proto</strong> 向原型链中查找，如果 __proto__和 构造函数的 prototype 相等 则返回true</li></ul><p>provide 和 inject </p><ul><li>provide、inject 的初始化阶段是在 beforeCreate 和 Create 之间，所以日常开发中 可以在 Create 中访问到 </li><li>各类型初始化阶段：<br>  initInject: 首先初始化 inject 的注入内容<br>  initState: 初始化 Vue 各项资源，data、props、methods、computed、watch 等<br>  initProvide: 初始化 provide </li><li>所以在 data、props 中 可以访问到 inject，在 provide 中 可以访问到data、props 等其自身的方法和属性</li><li>provide 中可以提供自身的方法和属性给后代组件，并且是具有响应式的，但如果注入的是一个 普通对象 那么就不具备响应式。</li></ul><h1 id="Vue-EventBus"><a href="#Vue-EventBus" class="headerlink" title="Vue EventBus"></a>Vue EventBus</h1><p>用于兄弟组件之间进行通信，是组件传递消息的一种方式</p><p>EventBus 原理：<br>    实际上就是发布-订阅者模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">event</span>[name]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[name] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span>[name].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">name, args</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span>[name] &amp;&amp; <span class="variable language_">this</span>.<span class="property">event</span>[name].<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(...args)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vite-原理"><a href="#vite-原理" class="headerlink" title="vite 原理"></a>vite 原理</h1><p>vite 新一代前端构建工具，基于现在浏览器都已普遍支持 ESM 这一特性实现构建。</p><p>vite 在编译项目时，会将项目 分为 依赖 + 源码 两个部分</p><p>依赖：指的是一些第三方库。这些第三方库会使用不同的模块化， 所以 vite 会将这些依赖统一转换处理成 ESM</p><ul><li>vite 通过 ESBuild 来对这些依赖进行处理，我们将这个过程称为 依赖预购建。</li><li>依赖预构建： <ol><li>将依赖中不同模块转换成 ESM。 </li><li>性能：为了提高性能，vite 会将多个 ESM 模块 合并成 一个，减少请求数。</li><li>缓存：vite 会为预构建的请求进行强缓存，并将预构建的依赖项缓存在 node_modules/.vite 中，它会根据package.json、NODE_ENV等文件是否变更来决定是否重新构建依赖。</li></ol></li></ul><p>源码： 指的是项目中的代码，包括 JS 文件和需要转换的文件，如.vue 文件</p><!-- vite 以 ESM 提供源码，实际上就是浏览器接管了打包的工作，vite 只在浏览器需要源码时对源码进行转换成 JS 代码，根据情景导入，实现动态加载。 --><p>Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理</p><!-- 源码会通过 304 进行协商缓存。 --><p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Last-Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><p>vite 的热更新：基于 ESM 能力，实现 import.meta.host </p><h1 id="为什么-vite-开发环境使用-ESBuild-生产环境仍需要-Rollup"><a href="#为什么-vite-开发环境使用-ESBuild-生产环境仍需要-Rollup" class="headerlink" title="为什么 vite 开发环境使用 ESBuild, 生产环境仍需要 Rollup"></a>为什么 vite 开发环境使用 ESBuild, 生产环境仍需要 Rollup</h1><blockquote><p>“尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）”<br>“Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容。尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。”</p></blockquote><p>vite 作者尤雨溪在 vite 官网上解释过这个问题，大致意思是： ESBuild 还是处于开发阶段，对于代码分割、TreeSharking 方面还不太完善。所以在生产环境为了用户体验、网站性能方面考虑，仍需要对项目进行打包。而 RollUp 和 webpack 一样是个成熟的构建工具，rollup 会更灵活。未来，esbuild 可能会成为主流构建。</p><p>rollup 有以下几个优点：<br>    css 代码分割，如果某个异步模块引入了一些 css 代码，vite 会自动将这些 css 抽取出来 生成单独的文件，提高线上产物的缓存复用率</p><pre><code>自动预加载，vite 会自动为入口 chunk 的依赖自动生成 预加载标签 &lt;link rel=&quot;modulePreload&quot; &gt; 这种适当的预加载会让浏览器提前下载好资源，优化页面性能。</code></pre><h1 id="vite-和-webpack-对比"><a href="#vite-和-webpack-对比" class="headerlink" title="vite 和 webpack 对比"></a>vite 和 webpack 对比</h1><ol><li><p>vite 中分为 2 个模块：依赖和源码；<br>webpack 中一切皆模块，不管是依赖还是源码都需要进行处理。</p></li><li><p>vite 是基于浏览器已经普通支持 ESM 语法这一特性，所以在构建本地服务时，不需要打包<br> webpack 完全没有考虑这一特点，只要是模块都需要用 loader 进行处理</p></li><li><p>vite 在启动时，不考虑编译问题，只考虑模块间的依赖，当浏览器中访问指定页面时，浏览器才开始按需加载当前页面，并会借助浏览器的缓存功能<br>webpack 在构建本地服务时要对所有的模块和依赖进行编译，无论当前页面是否被加载，webpack 的特点是先编译在运行，所以项目越大 运行速度越慢</p></li><li><p>vite 支持 TS，只负责把 TS 代码进行转换，对于 TS 类型校验的事交给了 IDE 去做<br> webpack 在构建 TS 项目时，需要安装 typescript 运行， TSC会对 TS 代码进行校验和编译，所以慢</p></li><li><p>vite 在 HMR 热更新时 也不进行编译，基于 ESM import.meta 实现 hot 属性<br> webpack 在热更新时会重新编译，所以也很慢。</p></li></ol><h1 id="Tree-Sharking-原理"><a href="#Tree-Sharking-原理" class="headerlink" title="Tree-Sharking 原理"></a>Tree-Sharking 原理</h1><p>ESM 引入进行静态分析，编译时会判断引入了哪些模块，判断哪些模块的变量未被使用，从而删除对应的代码</p><h1 id="babel-怎么做-polyfill"><a href="#babel-怎么做-polyfill" class="headerlink" title="babel 怎么做 polyfill"></a>babel 怎么做 polyfill</h1><p>babel 只做语法转换，将 ES6 转为 ES5，但是如果 在 ES5 中，有些对象方法在实际浏览器中可能不被支持，比如 Promise、array.prototype 等，这时候就需要通过 Babel-polyfill 来解决</p><p>Babel-polyfill 虽然可以通过模拟浏览器解决不存在对象方法的事，但存在2个问题：</p><ol><li>直接修改内置的原型，造成全局污染</li><li>无法按需引入</li></ol><p>所以社区中出现了 Babel-runtime， 不仅解决了 对象方法不被浏览器所支持的问题，也实现按需引入，不再修改内置原型，而是通过替换的方式 来解决。</p><h1 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h1><p>v-if 和 v-show 的作用都是用来控制 DOM 的展示和隐藏，不同的是<br>1、控制手段不同：v-show 是通过 css 来切换，v-if 是新建和删除 DOM 来控制<br>2、编译过程不同：v-show 是基于 css 进行切换，v-if 切换有一个局部的编译/卸载的过程</p><p>v-show 和 v-if， 虽然从表面看 类似，都是控制组件的显示和隐藏。但内部实现差距还是很大的</p><p>v-if 它在切换的过程中，条件块内部的事件监听器和子组件会被适当的重建和整合。满足条件后会触发对应组件的更新。<br>v-if 渲染的节点，由于新旧节点的vnode冲突， 在核心 diff 算法对比过程中，会移除旧节点 创建新节点。那么就会创建新的组件，经历组件自身初始化、渲染 vnode、patch等过程。</p><p>对于 v-show 渲染的节点，在初始化阶段时 它会先生成两个条件的组件，所以在后续的条件渲染中，由于新旧 vnode 一致，它只需 patchVnode 即可，在 patchVNode 的过程中，内部会执行 v-show 指令对应的回调更新，根据 v-show 指令绑定的值来设置它作用的 DOM 元素 style.display 的值</p><p>因此：相比 v-if 不断删除和创建新的DOM，v-show 只在更新现有 DOM 上的显隐值。所以 v-show 的支出比 v-if 小很多。</p><p>v-show 适用于多次切换的场景，v-if 适用于少数切换的场景。</p><p>v-show 相比 v-if 的性能优势时组件在更新阶段，如果在初始化阶段，v-if 性能优于 v-show.<br>因为 v-if 它本身只会渲染一个分支， v-show 把两个分支都渲染了。<br>在使用 v-show 时，所以分支内部组件都会渲染，对应的生命周期钩子函数都会执行，而使用 v-if 时 没有命中的分支内部组件是不会渲染的（包含内部的生命周期函数）</p><h1 id="Vue-事件绑定原理"><a href="#Vue-事件绑定原理" class="headerlink" title="Vue 事件绑定原理"></a>Vue 事件绑定原理</h1><ol><li>vue 通过解析模板的 html 提取 DOM 上的所有属性</li><li>通过正则匹配出事件名和事件处理方法</li><li>根据得到的事件名和事件处理方法，vue 会（调用 gen 回调）生成事件处理函数，这个函数中维护具体的事件名、对应的处理方法和修饰符等信息</li><li>将事件处理函数 通过 调用原生 DOM API addEventListener 注入到虚拟 DOM 中。</li></ol><h1 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h1><h2 id="Vue2-的响应式原理"><a href="#Vue2-的响应式原理" class="headerlink" title="Vue2 的响应式原理"></a>Vue2 的响应式原理</h2><p>Vue 2 中是采用 Object.defineProperty 来实现响应式的，通过劫持对象的属性，使得访问和修改对象属性时触发 相应的 setter和getter 函数。</p><p>在一开始组件被实例化时，如果模板上有绑定插值变量，视图中会关联一个 watcher，用来观测依赖更新，<br>  这时就会触发 getter 去收集依赖，并将依赖维护在一个 dep 数组中。</p><p>修改对象属性就会触发 setter，setter 就会通知依赖更新，watcher 收到依赖更新后 就会更新视图（这中间还有一层 patch 新旧节点对比）</p><p>Object.defineProperty 的缺陷</p><ol><li>因为它劫持的是对象的属性，所以它无法检测到对象属性的新增和删除，vue 提供了api 方法 vm.update,vm.delete </li><li>由于数组是通过一系列的数组方法来改变数组内（.push,.pop）Object.defineProperty 主要用于检测对象的，所以对于数组长度的变化无法检测到</li></ol><h2 id="Vue2-中怎么重写数组的"><a href="#Vue2-中怎么重写数组的" class="headerlink" title="Vue2 中怎么重写数组的"></a>Vue2 中怎么重写数组的</h2><p>由于数组是通过一系列的数组方法来改变数组内（.push,.pop等）所以对于数组的长度无法检测到。<br>vue2 中为了可以检测到数组的变化 通过拦截数组的原型 去实现检测 数组的变化。（这也暴露了一个缺陷，使用下标修改数组 无法被检测到）<br>同样还是通过 getter 去收集依赖，将收集到的依赖 保存在 Observe 实例中。通过Observe 去检测依赖的更新。<br>observe 中 有一个 <em>ob</em> 属性 用于记录该数据是否是响应式</p><h2 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.$set"></a>Vue.$set</h2><p>Vue.$set 挂载在 vue 原型上的方法，用于更新对象的新增属性，使新增属性也具有响应式。<br>原理是先判断该属性是否响应式属性，通过 <em>ob</em> 判断， 如果不是 调用 defineReactive 方法 使其变为响应式</p><h2 id="Vu-delete"><a href="#Vu-delete" class="headerlink" title="Vu.$delete"></a>Vu.$delete</h2><p>Vue.$delete 挂载在 vue 原型上的方法，用于删除对象属性。</p><p>实现方法比较粗暴： 直接使用 delete obj.name  this.dep.notify()</p><h1 id="Vue3-响应式原理"><a href="#Vue3-响应式原理" class="headerlink" title="Vue3 响应式原理"></a>Vue3 响应式原理</h1><p>Vue3 中怎么实现数据的响应式</p><p>Vue3 通过 Proxy 和 Reflect 搭配使用 实现响应式原理</p><p>Proxy ： 可以劫持整个对象，并且会返回一个新对象，Proxy 可以拦截并重新定义一个对象的基本操作，对于一些复合操作，proxy 无法调用</p><p>但由于对象中的一些方法都是范性的，不能直接调用。于是 Reflect 就登场了</p><p>Reflect 用于执行对象的默认操作<br>Proxy 中对对象的代理方法 和 Reflect 一一对应。所以无论通过 Proxy 怎么修改 都可以通过 Reflect 去获取对象的默认行为。</p><p>使用 Reflect 的好处： 1. 方法更具有语义化，并且直接使用 Reflect API 不会报错</p><p>Reflect 接收三个参数<br>Reflect(target, key, receiver) 其中 receiver 就是 代理对象，可以用于改变 this 指向。</p><p>Vue3 中先使用 Proxy 进行对对象拦截操作，然后在用 track 和 trigger 收集依赖和触发依赖的更新</p><p>Proxy  API 不能监听到对象内部深层次的属性变化，它在 getter 中去递归响应式，按需实现响应式</p><h2 id="Vue3-浅层响应式"><a href="#Vue3-浅层响应式" class="headerlink" title="Vue3 浅层响应式"></a>Vue3 浅层响应式</h2><p>props 是浅层响应，因为 props 是由父组件传递给子组件的，它的深层响应 应该由 父组件来保证</p><h1 id="Vue3-中-的-Ref-和-Reactive"><a href="#Vue3-中-的-Ref-和-Reactive" class="headerlink" title="Vue3 中 的 Ref 和 Reactive"></a>Vue3 中 的 Ref 和 Reactive</h1><p>ref 和 reactive 都是 vue3 中用于实现数据的响应式的，其不同是</p><ol><li>reactive 用于复杂数据类型、ref 用于 基本数据类型</li><li>reactive 基于 Proxy 实现的，ref 基于 reactive 的基础上实现的</li></ol><h2 id="reactive-的实现原理"><a href="#reactive-的实现原理" class="headerlink" title="reactive 的实现原理"></a>reactive 的实现原理</h2><p>reactive 是基于 Proxy 实现，Proxy 用于对整个对象进行代理 并返回一个新对象，所以当我们使用 reactive 去绑定一个对象，如果修改了对象的原数据，那么这个 reactive 就失去响应式</p><p>使用解构 reactive的对象也会让其失去响应式</p><h2 id="ref-的实现原理"><a href="#ref-的实现原理" class="headerlink" title="ref 的实现原理"></a>ref 的实现原理</h2><p>ref 是基于 reactive 实现的，由于 proxy只能对对象进行代理，所以在实现基本数据类型的响应式时，是将基本数据类型包装成对象。</p><p>ref = reactive({value: target}) 这也是我们在使用 ref 时 为什么要用 .value 去访问的原因。</p><p>由于在实现响应式前 会先对数据进行一层包装，所以重新赋值一个新对象给 ref 不会失去响应式</p><h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><p>toRef 使一个对象的属性具有响应式 – 对象属性具有响应式</p><h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p>toRefs 将一个d对象变为响应式变量 – 整个对象都具有响应式</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>用于监听响应式变量的变化，在组件初始化时不执行</p><h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><p>用于监听响应式变量的变化，会在组件初始化时执行</p><h2 id="watch-和-watchEffect-的区别"><a href="#watch-和-watchEffect-的区别" class="headerlink" title="watch 和 watchEffect 的区别"></a>watch 和 watchEffect 的区别</h2><ol><li>watch 不会在组件初始化时马上执行，watchEffect 会</li><li>watch 支持深度监听和立即执行回调函数，watchEffect 不支持</li><li>watch 适合监听特定数据的变化后执行异步操作等</li><li>watchEffect 适用于需要自动依赖收集的场景。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-router-的实现&quot;&gt;&lt;a href=&quot;#vue-router-的实现&quot; class=&quot;headerlink&quot; title=&quot;vue-router 的实现&quot;&gt;&lt;/a&gt;vue-router 的实现&lt;/h1&gt;&lt;p&gt;vue-router 的作用：通过改变 UR</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码解析: vue 响应式原理</title>
    <link href="https://monthlygirl.github.io/2023/11/Vue%20defineReactive.html"/>
    <id>https://monthlygirl.github.io/2023/11/Vue%20defineReactive.html</id>
    <published>2023-11-26T14:36:01.000Z</published>
    <updated>2023-11-26T14:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-响应式原理解析"><a href="#Vue-响应式原理解析" class="headerlink" title="Vue 响应式原理解析"></a>Vue 响应式原理解析</h1><p>大家都知道 vue 是双向数据绑定，vue 的双向数据绑定使用的是 <strong>v-model</strong> 实现。<strong>v-model</strong>实际上是 input 的事件 和 value 属性值。其最本质的原理是基于 vue 的响应式原理实现。响应式的实现原理是怎么样的呢？让我们接下来一起看看</p><h2 id="1-数据劫持"><a href="#1-数据劫持" class="headerlink" title="1. 数据劫持"></a>1. 数据劫持</h2><p>源码位置：<code>vue/src/core/observer/index.ts</code><br>在vue 源码有这么一个函数 <strong>defineReactive</strong>，其本质是使用<strong>Object.defineProperty</strong> 方法劫持对象属性，使得在访问和修改属性时能够执行特定的操作</p><ul><li>get: 用于获取属性值，同时进行依赖收集</li><li>set: 设置新值，触发依赖更新。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: object,</span></span><br><span class="line"><span class="params">  key: string,</span></span><br><span class="line"><span class="params">  val?: any,</span></span><br><span class="line"><span class="params">  customSetter?: <span class="built_in">Function</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  mock?: boolean</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建依赖收集</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取属性值描述，如果是只读属性，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="comment">// 预定义 getter/setter</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!getter || setter) &amp;&amp;</span><br><span class="line">    (val === <span class="variable constant_">NO_INITIAL_VALUE</span> || <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val, <span class="literal">false</span>, mock)</span><br><span class="line">  <span class="comment">// 使用 Object.defineProperty 定义响应式属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 方式 用于获取属性值，在获取值的时候进行依赖收集</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否有getter， 有就直接调用 getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;</span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有子响应式对象，依赖收集</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">//如果是数组类型，需要对数组的每一项进行依赖收集</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set 方式 用于设置属性值，同时触发依赖更新</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="comment">// 先使用 getter 获取旧值</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">// 新旧值一致时，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果有 setter 调用 setter 进行更新</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getter) &#123;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shallow &amp;&amp; <span class="title function_">isRef</span>(value) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newVal</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal, <span class="literal">false</span>, mock)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">          <span class="attr">target</span>: obj,</span><br><span class="line">          key,</span><br><span class="line">          <span class="attr">newValue</span>: newVal,</span><br><span class="line">          <span class="attr">oldValue</span>: value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依赖更新</span></span><br><span class="line">        dep.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 observe函数，递归遍历对象属性，为每个属性创建一个<code>dep</code>实例，通过<strong>Object.defineProperty</strong> 为每个属性设置 getter 和 setter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>()</span><br><span class="line">                <span class="keyword">return</span> internalValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue !== internalValue) &#123;</span><br><span class="line">                    internalValue = newValue</span><br><span class="line">                    dep.<span class="title function_">notify</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">observe</span>(internalValue)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-依赖追踪"><a href="#2-依赖追踪" class="headerlink" title="2. 依赖追踪"></a>2. 依赖追踪</h2><p>vue 的响应式系统引入了一个重要概念 – 依赖追踪。每个响应式属性都会关联一个 <code>Dep</code>(依赖)对象，它复制收集所有依赖于该属性的观察者(Watcher)。<br><img src= "/img/bgTop.jpg" data-lazy-src="image-2.png" alt="Alt text"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖管理器 Dep</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeWatcher) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeWatcher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">subscribe</span> =&gt;</span> &#123;</span><br><span class="line">            subscribe.<span class="title function_">update</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当属性被访问时，会调用 <code>dep.depend()</code>,将当前的观察者添加到依赖集合中。当属性被修改时，会调用 <code>dep.notify()</code>,通知所有依赖的观察者进行更新。</p><h2 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h2><p>观察者模式是vue 响应式系统的核心。通过创建观察者对象，订阅并响应数据的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">updateFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">updateFn</span> = updateFn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前实例设置活动观察者，执行更新后重置。</span></span><br><span class="line">        activeWatcher = <span class="variable language_">this</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">        activeWatcher = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Vue 采用 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong>的方式来实现数据的响应式，通过<strong>Object.defineProperty</strong> 来劫持数据的 setter 和 getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。</p><p>参考链接：<br><a href="https://tsejx.github.io/vue-guidebook/infrastructure/vue2/reactivity/#%E6%80%BB%E7%BB%93">https://tsejx.github.io/vue-guidebook/infrastructure/vue2/reactivity/#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-响应式原理解析&quot;&gt;&lt;a href=&quot;#Vue-响应式原理解析&quot; class=&quot;headerlink&quot; title=&quot;Vue 响应式原理解析&quot;&gt;&lt;/a&gt;Vue 响应式原理解析&lt;/h1&gt;&lt;p&gt;大家都知道 vue 是双向数据绑定，vue 的双向数据绑定使用的是 </summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term=" vue 响应式原理" scheme="https://monthlygirl.github.io/tags/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码解析：深度理解 initProps 函数</title>
    <link href="https://monthlygirl.github.io/2023/11/Vue%20source.html"/>
    <id>https://monthlygirl.github.io/2023/11/Vue%20source.html</id>
    <published>2023-11-25T07:50:13.000Z</published>
    <updated>2023-11-25T07:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-源码解析：深度理解-initProps-函数"><a href="#Vue-js-源码解析：深度理解-initProps-函数" class="headerlink" title="Vue.js 源码解析：深度理解 initProps 函数"></a>Vue.js 源码解析：深度理解 initProps 函数</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Vue.js 中，initProps 函数是组件初始化过程中的一个重要步骤，它负责处理组件的 props，使其变成响应式，并提供一些警告和检查。本文将深入解析 initProps 函数，探讨其实现原理和关键步骤。本文基于 Vue 源码 version <code>2.7.14</code></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开始之前，我们需要了解一些背景知识：</p><ul><li>Vue 组件的 props 是用于接收父组件传递的数据机制。</li><li>props 同样具有响应式，响应式系统是 Vue 的核心特性之一，它能用追踪数据的变化并实现视图的自动更新。</li></ul><h2 id="initProps-函数"><a href="#initProps-函数" class="headerlink" title="initProps 函数"></a>initProps 函数</h2><p>源码位置：<code>vue/src/core/instance/state.ts</code></p><h3 id="1-initProps-函数的作用"><a href="#1-initProps-函数的作用" class="headerlink" title="1. initProps 函数的作用"></a>1. <code>initProps</code> 函数的作用</h3><p><code>initProps</code> 主要用于处理组件的‘props’, 使其成为具有响应式数据，函数的核心功能：</p><ul><li><strong>获取props 数据</strong>： 从 <strong>vm.$options.propsData</strong> 获取 props 数据</li><li> <strong>创建响应式数据</strong>： 使用  <strong>shallowReactive</strong>创建一个浅层的响应式对象，并赋值给  <strong>vm._props</strong></li><li><strong>切换响应式观察状态</strong>： 判断当前组件是否是根节点，如果是根节点，则不会再用props 传进来，此时不需要启用响应式观察。</li><li> <strong>遍历处理 props</strong>： 循环遍历 propsOptions，验证prop 并将其设为响应式。</li><li> <strong>告警</strong>： 在开发环境，做校验告警，如：将保留字属性作为 props 时 发出告警。</li><li> <strong>代理到组件</strong>： 将 prop 代理到组件中，确保可以通过 this.propName 直接访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm: Component, propsOptions: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取 propsData</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;</span><br><span class="line">  <span class="comment">// 创建响应式对象 shallowReactive V3 方法</span></span><br><span class="line">  <span class="keyword">const</span> props = (vm.<span class="property">_props</span> = <span class="title function_">shallowReactive</span>(&#123;&#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存keys ，以便将来的key更新可以使用Array 而不是动态对象键枚举进行迭代。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">keys</span>: string[] = (vm.<span class="property">$options</span>.<span class="property">_propKeys</span> = [])</span><br><span class="line">  <span class="comment">// 是否是根组件，不是根组件的话不会有props 传入 不需要响应式</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.<span class="property">$parent</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    <span class="comment">// 切换响应式状态</span></span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 循环 props 选项</span></span><br><span class="line">    keys.<span class="title function_">push</span>(key)</span><br><span class="line">    <span class="comment">// 校验 props 并获取 props 值</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">// 开发环境下的校验告警</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = <span class="title function_">hyphenate</span>(key)</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="title function_">isReservedAttribute</span>(hyphenatedKey) ||</span><br><span class="line">        config.<span class="title function_">isReservedAttr</span>(hyphenatedKey)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`&quot;<span class="subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">              <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">              <span class="string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +</span><br><span class="line">              <span class="string">`value. Prop being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个响应式的 props</span></span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前key 不在组件的原型上</span></span><br><span class="line">    <span class="comment">// 代理到组件中，确保能够访问 props</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toggleObserving</span>(<span class="literal">true</span>) <span class="comment">//不是根组件 启用响应式观察</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出 initProps 中主要的函数 为 <strong>shallowReactive</strong>、<strong>defineReactive</strong>，接下来一一解析。</p><h3 id="2-shallowReactive-函数"><a href="#2-shallowReactive-函数" class="headerlink" title="2. shallowReactive 函数"></a>2. shallowReactive 函数</h3><p><strong>initProps</strong> 函数中使用了 <strong>shallowReactive</strong> 来创建浅层响应式对象，这个函数的作用是创建一个具有响应性的对象，但是只会对对象的第一层属性进行相应，而不会递归处理嵌套对象。那为什么 initProps 中只需对第一层属性进行响应呢？来我们继续看下去</p><h4 id="为什么-initProps-只对第一层属性进行响应？"><a href="#为什么-initProps-只对第一层属性进行响应？" class="headerlink" title="为什么 initProps 只对第一层属性进行响应？"></a>为什么 initProps 只对第一层属性进行响应？</h4><p>首先 <strong>initProps</strong> 函数并不是用来专门创建响应式对象的，而是用来初始化实例的 <strong>props</strong> 属性。在 Vue 中， <strong>props</strong> 是父组件传给子组件的属性，这些属性的响应式应该由父组件来保证的。</p><p> <strong>shallowReactive</strong> 来创建浅层响应式对象，而不会递归地将嵌套对象的属性变成响应式。</p><p><strong>defineReactive</strong> 函数，该函数的作用是将一个对象的属性变成响应式。然而，这里的目标并不是为了递归地将嵌套在 props 中的对象的属性都变成响应式，而是为了确保每个 props 中的属性都能够在组件实例中被访问。</p><p>因此，initProps 只关注 props 的第一层属性，而不会深入到嵌套的对象中去创建响应式。这是因为深层次的嵌套属性通常由父组件来管理和控制，子组件只需要访问这些属性而不需要在自身内部将它们变成响应式。 Vue.js 的设计哲学是在组件之间通过 props 进行数据传递，而不是在组件内部对传递的数据进行深度的响应式处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowReactive&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">ShallowReactive</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 调用 makeReactive 函数，传入目标对象和 true（表示浅层响应式）</span></span><br><span class="line">  <span class="title function_">makeReactive</span>(target, <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 在目标对象上定义一个 IS_SHALLOW 标志为 true，表示该对象为浅层响应式</span></span><br><span class="line">  <span class="title function_">def</span>(target, <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeReactive</span>(<span class="params">target: any, shallow: boolean</span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isReadonly</span>(target)) &#123;  <span class="comment">// 检查目标对象是否为只读代理，如果是，直接返回只读版本</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 如果目标对象是数组，发出警告，因为 Vue 2 不支持在 watch 或 watchEffect 中跟踪数组的变化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Avoid using Array as root value for <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">`shallowReactive()`</span> : <span class="string">`reactive()`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span> as it cannot be tracked in watch() or watchEffect(). Use <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">`shallowRef()`</span> : <span class="string">`ref()`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span> instead. This is a Vue-2-only limitation.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> existingOb = target &amp;&amp; target.<span class="property">__ob__</span> <span class="comment">// 检查目标对象是否已经有响应式对象</span></span><br><span class="line">      <span class="keyword">if</span> (existingOb &amp;&amp; existingOb.<span class="property">shallow</span> !== shallow) &#123; <span class="comment">// 如果目标对象已经有响应式对象，检查它是否和 shallow 参数相同</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Target is already a <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            existingOb.shallow ? <span class="string">``</span> : <span class="string">`non-`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span>shallow reactive object, and cannot be converted to <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">``</span> : <span class="string">`non-`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span>shallow.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 调用 observe 函数创建响应式对象</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="title function_">observe</span>(</span><br><span class="line">      target,</span><br><span class="line">      shallow,</span><br><span class="line">      <span class="title function_">isServerRendering</span>() <span class="comment">/* ssr mock reactivity */</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !ob) &#123;</span><br><span class="line">      <span class="comment">// 在开发环境下，如果创建响应式对象失败，发出相应的警告</span></span><br><span class="line">      <span class="keyword">if</span> (target == <span class="literal">null</span> || <span class="title function_">isPrimitive</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isCollectionType</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 如果目标对象是集合类型（如 Map 或 Set），发出警告，因为 Vue 2 不支持响应式集合类型</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Vue 2 does not support reactive collection types such as Map or Set.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-defineReactive"><a href="#3-defineReactive" class="headerlink" title="3. defineReactive"></a>3. defineReactive</h2><p><strong>defineReactive</strong> 函数是 Vue 响应式系统的核心之一，用于定义对象的属性，并在属性的 getter 和 setter 中实现对属性值的观察。接下来将出另篇文章解读传送门</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-js-源码解析：深度理解-initProps-函数&quot;&gt;&lt;a href=&quot;#Vue-js-源码解析：深度理解-initProps-函数&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 源码解析：深度理解 initProps 函数&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="initProps" scheme="https://monthlygirl.github.io/tags/initProps/"/>
    
  </entry>
  
  <entry>
    <title>http history</title>
    <link href="https://monthlygirl.github.io/2023/07/Interview-JS.html"/>
    <id>https://monthlygirl.github.io/2023/07/Interview-JS.html</id>
    <published>2023-07-17T08:12:11.000Z</published>
    <updated>2023-07-17T08:12:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h1><p>Http1.0 是最早的版本，它使用短链接，每次请求都需等待服务器响应后关闭连接。<br>它最早被使用在1996年的网页，开始人们只使用一些简单的 web 页和网络请求上，在1999年时广泛使用Http1.1</p><p>Http1.0 的缺点：</p><ul><li>短链接：http1.0 使用的是短链接方式，每个请求都必须建立连接和断开连接，每个连接都需要经过 TCP 连接过程（三次握手四次挥手的过程）</li><li>不支持复用header头，每次请求都需要发送完整的请求头信息</li><li>不支持对数据进行二进制分帧传输（？）</li><li>通过 expires 头来表示资源的过期时间，缺点 如果服务器和客户端的时间不一致，缓存可能会出现问题。</li><li>http1.1 没有提供对缓存的有效性验证，每次都需要重新下载整个资源，没有办法优化带宽利用。</li><li>不支持加密，所有数据传输都是明文传输，存在安全风险，需要额外使用安全协议（https 来对 http进行数据加密和身份校验）</li></ul><h1 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h1><p>在Http1.0 每次连接都需要建立完成的 TCP 连接，所以在 1999年时开始广泛使用Http1.1。<br>它们的主要区别在：</p><ul><li>针对http1.0的短链接，http1.1 引入 keep-alive 支持长连接，允许在单个连接上建立多次请求和相应</li><li>http1.1 引入了更复杂的缓存机制，使用了更多的缓存控制头，如：Cache-Control 头、ETag 和 Last-Modified 头</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP1-0&quot;&gt;&lt;a href=&quot;#HTTP1-0&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.0&quot;&gt;&lt;/a&gt;HTTP1.0&lt;/h1&gt;&lt;p&gt;Http1.0 是最早的版本，它使用短链接，每次请求都需等待服务器响应后关闭连接。&lt;br&gt;它最早被使</summary>
      
    
    
    
    
    <category term="HTTP、多路复用、长链接" scheme="https://monthlygirl.github.io/tags/HTTP%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E3%80%81%E9%95%BF%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》学习日志</title>
    <link href="https://monthlygirl.github.io/2021/06/code.html"/>
    <id>https://monthlygirl.github.io/2021/06/code.html</id>
    <published>2021-06-16T13:19:49.000Z</published>
    <updated>2021-06-16T13:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p><code>变量名应该是名词，能够正确地描述业务，有表达力。如果一个变量名需要用注释来补充说明，那很有可能说明命名有问题</code>。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p><code>函数名要具体，它体现的是做什么，而不是怎么做。</code></p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p><code>类名是一组数据和操作的封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。</code><br>实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如Customer,Employee等等；辅助类是辅佐实体类一起完成业务逻辑得，其命名要能够通过后缀来体现功能，例如，用来为Customer 做控制路由的控制类CustomerController，对于辅助类，尽量不要用Helper,Util之类的后缀，因为其含义太过笼统。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p><code>包代表了一组有关系的类的集合，起到了分类组合和命名空间的作用，包名应该能够反映一组类在更高抽象层次上的联系，例如Apple、Pear，我们可以将它们放在一个包中，命名为fruit。包的命名要适合，不能太抽象也不能太具体。如Apple，那么将Pear、Orange放进包中就不适合了；如果太抽象，称为Object，Object无所不包，这便失去了用包来限定范围的作用。</code></p><h2 id="模块名"><a href="#模块名" class="headerlink" title="模块名"></a>模块名</h2><p><code>相对于包来说，模块的粒度更大，通常一个模块包含了多个包，模块命名要有唯一性，另外名称要反映模块在系统中的职能</code></p><h2 id="命名保持一致性"><a href="#命名保持一致性" class="headerlink" title="命名保持一致性"></a>命名保持一致性</h2><p>保持命名的一致性，可以提高代码的可读性，每个概念对应一个词。在项目，通常约定方法名，如：crud操作中 create 新增，add 添加，remove 删除。<br>使用对仗词，遵守对仗词的命名规则有助于保持一致性，从而提高代码的可读性。像first/last这样的对仗词就很容易理解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>像Brian W.Kernighan 说的那样：“别给糟糕的代码加注释—重新写吧。”<br>注释，不要复述功能，注释要能够解释代码背后的意图，而不是对功能的简单重复，真正的高手是尽量不写注释。</p><p><strong>很多人（包括我在没阅读这边书之前）觉得命名规范只是细节，但命名其实很难。书中在这一章开头就引用了两个名人的谚语，言简意赅的表达了命名的重要性。<code>就像Stack OverFlow的创始人Joel Spolsky说的：“起一个好名字应该很难，因为好名字需要把要以浓缩在一到两词中”，Martin Fowler也表示过“在计算机科学中有两件难事：缓存失效和命名”</code>；所以好的命名可以保证代码不仅是被机器执行的指令，更是人和人之间沟通的桥梁。也像channing哥说的，好的代码看着，不是在看代码，而是像看一本书</strong></p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ol><li>代码格式，代码格式关系到代码的可读性，因此需要遵从一定的规范，包括缩进、水平对齐、注释格式等</li><li>命名规范，每种语言都有自己独特的命名风格，javascript是弱类型语言，会使用匈牙利命名法的习惯（这个还第一次见）</li><li>异常规范，要统一处理异常，异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码，这种不一致性通常会让人摸不着头脑，增加了服务的使用成本和沟通成本</li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数数量"><a href="#参数数量" class="headerlink" title="参数数量"></a>参数数量</h2><p>最理想的参数数量是零（零参函数），其次是一（一元函数），再次是二（二元函数），应尽量避免三（三元函数）<br>如果函数需要3个以上参数，就说明其中一些参数应该封装为类了。</p><h2 id="短小函数"><a href="#短小函数" class="headerlink" title="短小函数"></a>短小函数</h2><p>函数的第一规则是要短小，第二规则是要更短小。有时保持代码的逻辑不变，只是把长方法改成多个短方法，代码的可读性就能提高很多。超长方法是典型代码的“坏味道”，对超长方法的结构化分解是提升代码可读性最有效的方式之一。</p><h2 id="职责单一"><a href="#职责单一" class="headerlink" title="职责单一"></a>职责单一</h2><p>一个方法只做一件事情（华哥跟我说了好多次，拆分函数，哪怕只有一句话，只要有助于语义显性化的表达，也是值得的），也就是函数级别的单一职责原则（SRP），遵循SRP不仅可以提升代码的可读性，还行提升代码的可复用性。因为职责越单一，功能越内聚，</p><h2 id="精简辅助代码"><a href="#精简辅助代码" class="headerlink" title="精简辅助代码"></a>精简辅助代码</h2><p>辅助代码，它不是处理业务逻辑的核心代码，但如判空、打印日志、缓存检查等等，这些代码往往会在多个函数中重复冗余，如果辅助代码太多，会极大地干扰代码的可读性。因此我们应该尽量减少辅助代码对业务代码的干扰。让函数中的代码能直观第体现业务逻辑，而不是让业务代码淹没在辅助代码中。</p><h2 id="组合函数模式"><a href="#组合函数模式" class="headerlink" title="组合函数模式"></a>组合函数模式</h2><p>组合函数要求所有的公有函数读起来像一系列执行步骤的概要，而这些步骤的真正实现细节是在私有函数里面。组合函数有助于代码保持精炼并易于复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。&lt;/p&gt;
&lt;h1 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="学习指南" scheme="https://monthlygirl.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>vue3.0</title>
    <link href="https://monthlygirl.github.io/2021/04/vue3.0.html"/>
    <id>https://monthlygirl.github.io/2021/04/vue3.0.html</id>
    <published>2021-04-01T13:59:31.000Z</published>
    <updated>2021-04-01T13:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-0的新特性及Vue3-0带来的新变化"><a href="#Vue3-0的新特性及Vue3-0带来的新变化" class="headerlink" title="Vue3.0的新特性及Vue3.0带来的新变化"></a>Vue3.0的新特性及Vue3.0带来的新变化</h1><p>vue3.0 2020年9月发布,命名为One p</p><h2 id="Vue3-0-带来的新变化"><a href="#Vue3-0-带来的新变化" class="headerlink" title="Vue3.0 带来的新变化"></a>Vue3.0 带来的新变化</h2><ul><li>性能的提升 1.3~2x<br>与vue2.x相比,mount 50%提升,内存占用小120%<br>核心代码+ Composition API:13.5kb,最小11.75kb  可以单独使用<br>所有的runtime:22.5kb(vue2是32kb)</li></ul><h1 id="为什么会有这么大的性能提升"><a href="#为什么会有这么大的性能提升" class="headerlink" title="为什么会有这么大的性能提升?"></a>为什么会有这么大的性能提升?</h1><h2 id="Compiler-原理"><a href="#Compiler-原理" class="headerlink" title="Compiler 原理"></a>Compiler 原理</h2><ol><li>静态的节点和静态绑定的class和id不再作更新处理(hoistStatic-&gt;SSR优化)</li><li>结合打包标记PatchFlag,进行更新分析<br>在编译过程中会将template编译成ast语法树,ast是一个抽象的语法树,动态的内容打上标记,在更新的时候只更新动态的内容</li><li>事件监听器Cache缓存处理(cacheHandlers)</li><li>hoistStatic 自动针对多静态节点进行优化,输出字符串</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-0的新特性及Vue3-0带来的新变化&quot;&gt;&lt;a href=&quot;#Vue3-0的新特性及Vue3-0带来的新变化&quot; class=&quot;headerlink&quot; title=&quot;Vue3.0的新特性及Vue3.0带来的新变化&quot;&gt;&lt;/a&gt;Vue3.0的新特性及Vue3.0</summary>
      
    
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/categories/Vue/"/>
    
    
    <category term="vue3.0 Compiler" scheme="https://monthlygirl.github.io/tags/vue3-0-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的各个版本</title>
    <link href="https://monthlygirl.github.io/2021/03/http-version.html"/>
    <id>https://monthlygirl.github.io/2021/03/http-version.html</id>
    <published>2021-03-01T12:51:53.000Z</published>
    <updated>2021-03-01T12:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>HTTP 是超文本传输协议,它定义了客户端和服务器之间交换报文的格式和方式,默认采用80端口,它使用TCP作为传输层协议,保证了数据传输的可靠性</p><p>HTTP 是一个无状态的协议,HTTP 服务器不会保存关于客户端的任务信息</p><p>HTTP 有两种连接模式,一种是持续连接,一种是非持续连接;<br>非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接;持续连接,TCP 连接默认不关闭,可以被多个请求复用;采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间; </p><p>在HTTP1.0 以前使用的非持续的连接,但是可以在请求时,加上Connection: keep-alive 来要求服务器不要关闭 TCP 连接</p><p>在HTTP1.1以后默认采用的是持续的连接;目前对于同一个域,大多数浏览器支持同时建立 6 个持久连接</p><h1 id="HTTP-协议的各个版本"><a href="#HTTP-协议的各个版本" class="headerlink" title="HTTP 协议的各个版本"></a>HTTP 协议的各个版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议; 它不涉及数据包传输,主要规定了客户端和服务器之间的通信格式,默认使用80端口</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>最早的版本是0.9版本,该版本及其简单,只有一个命令 <code>GET</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / index.<span class="property">html</span></span><br><span class="line"><span class="comment">// TCP 连接建立后,客户端向服务器请求网页 index.html</span></span><br></pre></td></tr></table></figure><p>协议规定,服务器只能回应 HTML 格式的字符串,不能回应别的格式<br>服务器发送完毕,就关闭 TCP 连接</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP1.0 版本发布,内容大大增加</p><ol><li>首先,任何格式内容都可以发送; 可以传输文字 / 图像 / 视频 / 二进制 文件 </li><li>除了 <code>GET</code> 命令,还引入了 <code>POST</code> / <code>HEAD</code> 命令,使传输信息变得更丰富</li><li>HTTP 请求和回应格式也发生改变了,每次通信都必须包含头信息,用来描述一些元数据</li><li>新增状态码 / 缓存 / 内容编码 / 字符编码 /等等</li></ol><h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p>字符编码,1.0版规定,头信息必须是 ASCII 码,后面的数据可以是任何格式;<br>因此服务器回应的时候,必须告诉客户端,数据是什么格式,这就是 <code>Content-type</code> 字段的作用<br>常见的 <code>Content-type</code> 字段的值</p><ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg<br>…</li></ul><h3 id="Content-Encoding-字符"><a href="#Content-Encoding-字符" class="headerlink" title="Content-Encoding 字符"></a>Content-Encoding 字符</h3><p>由于发送的数据可以是任何格式,因此可以把数据压缩后再发送; <code>Content-Encoding</code> 字段说明数据的压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure><p>客户端请求时,用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gizp,deflate</span><br></pre></td></tr></table></figure><h3 id="HTTP-1-0-的缺点"><a href="#HTTP-1-0-的缺点" class="headerlink" title="HTTP/1.0 的缺点"></a>HTTP/1.0 的缺点</h3><p>每次 TCP 连接只能发送一个请求,发送数据完毕,连接就关闭,如果还要请求其他资源,就必须再新建一个连接<br>TCP 连接的新建成本高,所以 HTTP/1.0 版本性能较差<br>为了解决这个问题,有些浏览器在请求时,用了一个非标准的 <code>Connection</code> 字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这个字符要求服务器不要关闭 TCP 连接,以便其他请求复用,服务器同样回应这个字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这样一个可以复用的 TCP 连接就建立了,直到客户端或服务器主动关闭连接,但是,这不是标准字段,不同实现的行为可能不一致,因此不是根本的解决方法</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1版本的发布,它进一步完善了 HTTP 协议</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>1.1版本的最大变化,就是引入了持久连接,即 TCP 连接默认不关闭,可以被多个请求复用,不用声明 <code>Connection:keep-alive</code><br>客户端和服务器发现对方一段时间没有活动,就可以主动关闭连接;不过,规范的做法是,客户端在最后一个请求时,发送 <code>Connection: close</code>,明确要求服务器关闭 TCP 连接,对于同一个域名,大多数浏览器允许同时建立 6 个持久连接</p><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>1.1版本引入了管道机制,即在同一个 TCP 连接里面,客户端可以同时发送多个请求,这样就进一步改进了 HTTP 协议的效率</p><p>举例来说,客户端需要请求两个资源,在1.1版本以前的做法是,在同一个 TCP 连接里面,先发送 A 请求,然后等待服务器做出回应,收到后再发送B请求,管道机制则是允许浏览器同时发送A请求和B请求,但服务器还是按照顺序,先回应A请求,完成后再回应B请求</p><p>另外增加了 <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> 等方法</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然1.1版本允许复用 TCP 连接,但是同一个 TCP 连接里面,所有的数据通信是依次进行的,服务器只有处理完一个回应,才会进行下一个回应,要是前一个回应特别慢,后面就会 有许多请排队等着,这称为 <code>队头阻塞</code><br>为了避免这个问题,只有两种方法: 一是减少请求数, 二是同时打开多个持久连接,这就是我们对网站优化时，使用雪碧图、合并脚本的原因。 </p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/2 是谷歌自行研发的 SPDY 协议,主要解决 HTTP/1.1 效率不高的问题</p><p>HTTP/2 主要有以下新的特性:</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/2 是一个二进制协议,在 HTTP/1.1 版本中,报文的头信息必须是文本(ASCII编码),数据体可以是文本,也可以是二进制,HTTP/2 则是一个彻底的二进制协议,头信息和数据体都是二进制的,并且统称为 “ 帧 “ ,可以分为头信息帧和数据帧<br>帧的概念是它实现多路复用的基础</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 实现了多路复用,HTTP/2 仍然复用 TCP 连接,但是一个连接里,客户端和服务器都可以同时发送多个请求或回应,而且不用按照顺序一一发送,这样就避免了 “队头阻塞” 的问题</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 使用了数据流的概念,因为HTTP/2 的数据包不是按顺序发送的,同一个连接里面连续的数据包,可能属于不同的请求;因此,必须要对数据包做标记,指出它属于哪个请求;HTTP/2 将每个请求或回应的所有数据包,称为一个数据流;<br>每个数据流都有一个独一无二的编号;数据包发送的时候,都必须标记数据流 ID ,用来区分它属于哪个数据流</p><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP/2 实现了头信息压缩,由于 HTTP 1.1 协议不带有状态,每次请求都必须附上所有信息,所以请求的很多字段都是重复的,比如 Cookie 和 User Agent,一模一样的内容,每次请求都必须附带,这会浪费很多带宽,也影响速度</p><p>HTTP/2 对这一点做了优化,引入了头新压缩机制,一方面,头信息使用 gzip 或 compress 压缩后再发送;另一方面,客户端和服务器同时维护一张头信息表,所有字段都会存入这个表,生成一个索引号,以后就不发送同样字段了,只发送索引号,这样就能提供速度了</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求,主动向客户端发送资源,这叫做服务器推送,使用服务器推送,提前给客户端提送必要的资源,这样就可以相对减少一些延迟时间,这里需要注意的是 HTTP2 下服务器主动推送的是静态资源和 webSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的</p><h3 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h3><p>因为 HTTP/2 使用了多路复用,一般来说同一域名下只需要使用一个 TCP 连接,由于多个数据流使用同一个 TCP 连接,遵守同一个同一个流量状态控制和拥塞控制,只要一个数据流遭遇拥塞,剩下的数据流就没法发出去,这样就导致了后面的所有数据都被阻塞, HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题,与它本身的实现没有多大关系</p><h2 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h2><p>由于 TCP 本身存在的一些限制,Google 就开发了一个基于 UDP 协议的 QUIC 协议,并且使用在了 HTTP/3上,QUIC 协议在 UDP 协议上实现了 多路复用 / 有序交付 / 重传 等等功能</p><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ol><li>HTTP 报文使用明文的方式发送,可能被第三方窃听</li><li>HTTP 报文可能被第三方截取后修改通信内容,接收方没有办法发现报文内容的修改</li><li>HTTP 还存在认证的问题,第三方可以冒充他人参与通信</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS 指的是超文本传输安全协议,HTTPS 是基于 HTTP 协议的,不过它会使用 TLS/SSL 来对数据加密,使用 TLS/SSL 协议,所有的信息都是加密的,第三方没有办法窃听;并且它提供了一种校验机制,信息一旦被篡改,通信的双方会立刻发现,它还配备了身份证书,防止身边被冒充的情况出现</p><h2 id="TLS-握手实现原理"><a href="#TLS-握手实现原理" class="headerlink" title="TLS 握手实现原理"></a>TLS 握手实现原理</h2><p>TLS 的握手过程主要用到了三个方法来保证传输的安全</p><ol><li><p>首先的对称加密的方法,对称加密的方法是,双方使用同一个密钥对数据进行加密和解密,但对称加密存在的一个问题就是如何保证密钥传输的安全性,因为密钥还是会通过网络传输的,一旦密钥被其他人获取到,那么整个加密过程就毫无作用;这就要用到非对称加密的方法</p></li><li><p>非对称加密的方法是,我们拥有两个密钥,一个是公钥,一个是私钥,公钥是公开的,私钥是保密的,用私钥加密的数据只有对应的公钥才能解密,我们可以将公钥公布出去,任务想和我们通信的客户,都可以使用我们提供的公钥对数据进行加密,然后使用私钥进行解密,这样就能保证数据的安全了,但是非对称加密有一个缺点就是加密的过程很慢,因此如果每次通信都使用非对称加密的方法的话,反而会造成等待时间过长的问题; 因此我们可以使用对称加密和非对称加密结合的方法,因为对称加密方式的缺点就是无法保证密钥的安全传输,因此我们可以以非对称加密方式来对对称加密的密钥进行传输,然后以后通信使用对称加密的方式来加密,这样就解决了两个方法各种存在的问题</p></li><li><p>但是现在的方法也不一定是安全的,因为我们没有办法确定我们得到的公钥就一定是安全的公钥,可能存在一个中间人,截取了对方发给我们的公钥,然后将他自己的公钥发送给我们,当我们使用他的公钥加密后发送的信息,就可以被他用自己的私钥解密,然后伪装我们以同样的方法向对方发送信息,这样我们的信息就被窃取了,然而我们自己还不知道<br>为了解决这样的问题,我们可以使用数字证书的方式,首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要,然后让有公信力的认证中心,用它的私钥对消息摘要加密,形成签名,最后将原始的信息和签名结合在一起,称为数字证书,当接收方接收到数字证书的时候,先根据原始信息使用同一的 Hash 算法生成一个摘要,然后使用公证处的公钥来对数字证书中的摘要进行解密,最后将解密的摘要和我们生成的摘要进行对比,就能发现我们得到的信息是否被更改了这个方法最重要的是认证中心的可靠性,一般浏览器里会内置一些顶层的认证中心的证书,相当与我们自动信任了他们,只有这样我们才能保证数据的安全</p></li></ol><h1 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h1><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样,前者是80, 后者是443</li><li>HTTP 协议运行在 TCP 之上,所有传输的内容都是明文,HTTPS 运行在 SSL/TLS 之上, SSL/TLS 运行在 TCP 之上,所有传输的内容都是密文传输 </li><li>HTTPS 可以有效的防止运营商劫持</li></ul><h1 id="为什么-HTTP-1-1-不能实现多路复用"><a href="#为什么-HTTP-1-1-不能实现多路复用" class="headerlink" title="为什么 HTTP/1.1 不能实现多路复用"></a>为什么 HTTP/1.1 不能实现多路复用</h1><p> http/2的多路复用是基于二进制协议实现的,在http/1.1 中头部报文信息必须是文本，服务器接收数据后无法识别多个响应对应的请求<br> http/2中实现了二进制协议，也就是说 头部信息是二进制的，叫“帧”，所以头部信息和数据体 也称为头部信息帧和数据帧。<br> 同时 http/2 中引入了数据流的概念，帧表示最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组合的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h1&gt;&lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP HTTPS" scheme="https://monthlygirl.github.io/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/2021/03/JavaScript.html"/>
    <id>https://monthlygirl.github.io/2021/03/JavaScript.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li>在 js 中我们是使用构造函数来新建一个对象的,每一个构造函数的内部都有一个 prototype 属性,这个属性是一个对象,这个对象上包含了该构造函数的所有实例共享的属性和方法</li><li>当我们使用构造函数新建了一个对象后,在这个对象的内部包含一个指针 <code>__proto__</code>,这个指针指向该对象所属构造函数的 prototype 属性对应的值, 在ES5 中这个指针被称为 对象 的原型</li><li>一般来说我们是不能够获取到这个值的,但是现在的浏览器都实现了 <strong>proto</strong> 属性,让我们可以访问这个属性,但是最后不要用这个属性, 因为它不是规范中规定的</li><li>ES5 中新增了一个Object.getPrototypeOf()方法,我们可以通过这个方法来获取对象的原型</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>当我们访问一个对象的属性时,如果这个对象内部不存在这个属性,那么它就会去它的原型对象里找这个属性,这个原型对象又会有自己的原型,于是就这样一直找下去,这也就是原型链的概念.</li><li>原型链的尽头一般来说都是 object.prototype </li></ul><h2 id="原型和原型链的特点"><a href="#原型和原型链的特点" class="headerlink" title="原型和原型链的特点"></a>原型和原型链的特点</h2><ul><li>JavaScript 对象是通过引用来传递的,我们创建的每一个新对象实体中并没有 一份属于自己的原型,当我们修改原型时,与之相关的对象也会继承这一改变</li></ul><h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a>js 获取原型的方法</h2><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol><li>作用域: 当前代码对变量的访问权限(函数作用域,es6 let const 声明的块级作用域)</li><li>作用域链: 内层作用域访问一个变量,首先会在当前作用域的父级找,如果没找到,在往上一层找,直到找到全局,如果还没有找到就宣布放弃,这种一层一层向上的关系,就是作用域链,即以链式的方式访问变量</li></ol><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><ul><li>垃圾回收机制: 会自动释放内存,就是说一个函数执行完毕,内存中的空间会被释放,再一次调用的时候,函数内部会被重新赋值</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>读取函数内部的变量,让全局访问局部变量</li><li>延长变量的生命周期<h2 id="闭包的使用方式"><a href="#闭包的使用方式" class="headerlink" title="闭包的使用方式"></a>闭包的使用方式</h2></li></ol><ul><li>就是函数内部嵌套着另一个函数,这个函数在外部别调用,所以内存不会被回收,从而延长变量的生命周期</li></ul><h1 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h1><ul><li>递归就是函数自己调用函数自己,递归一定要有结束条件,否则会陷入死循环</li><li>使用场景: 遍历树的结构</li></ul><h1 id="js的异步机制"><a href="#js的异步机制" class="headerlink" title="js的异步机制"></a>js的异步机制</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/">《js的异步机制》</a></a></p><h1 id="事件循环机制-Event-Loop"><a href="#事件循环机制-Event-Loop" class="headerlink" title="事件循环机制(Event Loop)"></a>事件循环机制(Event Loop)</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/"><a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/">《事件循环机制Event Loop》</a></a></p><h1 id="什么是-Promise-对象-什么是-Promise-A"><a href="#什么是-Promise-对象-什么是-Promise-A" class="headerlink" title="什么是 Promise 对象? 什么是 Promise/A+ ?"></a>什么是 Promise 对象? 什么是 Promise/A+ ?</h1><ol><li>promise对象是异步编程的一种解决方案,最早由社区提出,promise/A+规范是javascript promise的规范,规定了一个promise所必须具有的特性</li><li>Promise 是一个构造函数,它接收一个函数作用参数, 并且返回一个promise实例,一个promise实例有三种状态,分别是pending,resolve,reject,对应着进行中,已完成,已失败,一个实例的状态只能由 pending 转换为 resolve 或由 pending 转换为 reject ,状态一经改变就凝固了,无法再改变,我们可以在异步操作结束后调用这两个函数改变promise的状态,一个状态一经改变可以通过 then 注册回调函数,可以立即得到结果</li></ol><h1 id="ES5-继承和-ES6-继承的区别"><a href="#ES5-继承和-ES6-继承的区别" class="headerlink" title="ES5 继承和 ES6 继承的区别"></a>ES5 继承和 ES6 继承的区别</h1><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><ul><li>ES5 的继承实质: 先创建子类,再实例化父类,并将父类的方法添加到子类的this中;可以通过原型或构造函数机制来实现</li><li>ES6 实质: 先创建父类,实例化子类通过调用super方法访问父类后,在通过修改this实现继承,super关键字指代父类的实例,即父类的this对象,在子类构造函数中,如果不调用super方法,子类得不到this对象</li><li>ES6 实现继承是通过关键字 <code>extends</code> <code>super</code> 来实现继承</li></ul><h1 id="new-的时候做了什么"><a href="#new-的时候做了什么" class="headerlink" title="new 的时候做了什么"></a>new 的时候做了什么</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型,将对象的原型设置为函数的 prototype 对象</li><li>让函数的 this 指向这个对象,执行构造函数的代码,为这个新对象添加属性</li><li>判断函数的返回值类型,如果是值类型,返回创建的对象;如果是引用类型,就返回这个引用类型的对象</li></ol><p>详情请看本站文章 <a href="http://localhost:4000/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"><a href="http://guestljz.gitee.io/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/">《如何实现一个 new》</a></a></p><h1 id="Ajax是什么-如何创建一个Ajax"><a href="#Ajax是什么-如何创建一个Ajax" class="headerlink" title="Ajax是什么? 如何创建一个Ajax?"></a>Ajax是什么? 如何创建一个Ajax?</h1><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li>AJAX,异步的 JavaScript 和 XML ,是一种实现 无页面刷新 获取数据的 混合技术 ,简单来说就是JavaScript执行异步请求<h2 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h2></li><li>比如,领导要找张三汇报工作,于是领导就委托秘书帮忙去叫张三,然后领导就继续忙自己的工作,直到秘书告诉领导张三到了,接着张三就开始汇报工作</li><li>AJAX 请求数据的流程 就跟 “领导找张三汇报工作相似” , 其中的核心 就是 <strong>秘书</strong>,<strong>秘书</strong>相当于浏览器的XMLHttpRequest对象,当浏览器发出HTTP请求与接收HTTP响应时,浏览器可以接着做其他的事情,直到收到xhr返回的数据渲染页面</li></ul><h2 id="AJAX-实现流程"><a href="#AJAX-实现流程" class="headerlink" title="AJAX 实现流程"></a>AJAX 实现流程</h2><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><h2 id="AJAX的状态"><a href="#AJAX的状态" class="headerlink" title="AJAX的状态"></a>AJAX的状态</h2><ul><li>0 表示未初始化,尚未调用open方法</li><li>1 启用open方法,数据发生</li><li>2 表示已调用open方法 接收到响应</li><li>3 表示正在解析</li><li>4 表示已完成</li></ul><p>详情请看本站文章 <a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/"><a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/">《Ajax》</a></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象,是一种编程开发思想,面向对象编程,它将真实世界各种复杂的关系,抽象为一个个对象,然后进行分工合作,完成对真实世界的模拟</li><li>面向对象的特性: 封装 / 多态 / 继承</li><li>面向对象就是对 <strong>现实世界理解和抽象的方法</strong><br>我对面向对象的理解就是: 面向对象的编程方式就是让每一个类都只做一件事,面向过程会让一个类越来越全能,就像是一个管家一样做了所有的事;而面向对象像是雇佣了一群职员,每个人做一件小事,各司其职,最终合作共赢</li></ul><h1 id="JSON-parse-和JSON-stringify"><a href="#JSON-parse-和JSON-stringify" class="headerlink" title="JSON.parse()和JSON.stringify()"></a>JSON.parse()和JSON.stringify()</h1><p>JSON.parse()把字符串解析成对象<br>JSON.stringify()从对象中解析出字符串</p><h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>详情请看本站文章 <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">《事件模型》</a></a> </p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托本质上是利用了浏览器事件冒泡的机制,因为事件在冒泡过程中会上传到父节点,并且父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件代理</p><p>使用事件代理我们可以不不必要为每一个子元素都绑定一个监听事件,这样减少了内存上的消耗,并且使用事件代理我们还可以实现事件的动态绑定,比如说新增了一个子节点,我们并不需要单独第为它添加一个监听事件,它所它发生的事件会交给父元素中的监听函数来处理</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行环境(即执行上下文中)存在着执行代码的的私有作用域,上层作用域的指向,方法的参数,这个作用域中定义的变量以及这个作用域的this对象等等</p><h1 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h1><p>基本数据类型: 栈内存 先进后出<br>复杂数据类型: 堆内存 优先队列,复杂数据类型将值报存在堆中,将值对应的指针保存在栈中,通过栈中的指针来获取堆中的值</p><h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>详情请看本站文章  <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/">《模块化》</a></a></p><h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><p><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/">《ES6 中新增特性》</a></a></p><h1 id="Promise-all-的实现"><a href="#Promise-all-的实现" class="headerlink" title="Promise.all 的实现"></a>Promise.all 的实现</h1><p>Promise.all 同时发送多个请求，并行运行 promise， 所以 promise 成功则返回成功，如果有一个失败，则返回失败，并返回失败的原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">        promises.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">            val.<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>(r)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件模型</title>
    <link href="https://monthlygirl.github.io/2021/03/Event_Model.html"/>
    <id>https://monthlygirl.github.io/2021/03/Event_Model.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事件模型</p><h2 id="DOM0-级模型"><a href="#DOM0-级模型" class="headerlink" title="DOM0 级模型"></a>DOM0 级模型</h2><ul><li>第一周事件模型是最早的 DOM0 级模型,这种模型不会传播,所以没有事件流的概念,但是现在有的浏览器支持一冒泡的方式实现,它可以在网页中直接定义监听函数,也可以通过 js 属性来指定监听函数,这种方式是所有浏览器都兼容的</li></ul><h2 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h2><ul><li>第二种事件模型 是 IE 事件模型,在该事件模型中,一次事件共有两个过程,事件处理阶段,和事件冒泡阶段;事件处理阶段会首先执行目标元素绑定的监听事件;然后是事件冒泡阶段,冒泡指的是事件从目标元素冒泡到 document,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,这种模型通过 attachEvent 来添加监听函数,可以添加多个监听函数,会按顺序一次执行</li></ul><h2 id="DOM2-级模型"><a href="#DOM2-级模型" class="headerlink" title="DOM2 级模型"></a>DOM2 级模型</h2><ul><li>第三种是 DOM2 级事件模型,在该事件模型中,一次事件共有三个过程,第一个过程是事件捕获阶段;事件捕获指的是事件从 document 一直向下传播到目标元素,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,后面这两个阶段和 IE 事件模型的两个阶段相同,这种事件模型,事件绑定函数式 addEventListener,其中第三个参数可以指定事件是否在捕获阶段执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三种事件模型是什么&quot;&gt;&lt;a href=&quot;#三种事件模型是什么&quot; class=&quot;headerlink&quot; title=&quot;三种事件模型是什么?&quot;&gt;&lt;/a&gt;三种事件模型是什么?&lt;/h1&gt;&lt;p&gt;事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM0级 DOM2级" scheme="https://monthlygirl.github.io/tags/DOM0%E7%BA%A7-DOM2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://monthlygirl.github.io/2021/03/Module.html"/>
    <id>https://monthlygirl.github.io/2021/03/Module.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所以并没有模块化的概念,但随着程序越来越复杂,代码的模块化开发变得越来越重要</p><p>由于函数具有独立作用域的特点,最原始的写法是使用函数来作为模块,几个函数作用一个模块,但是这种方法容易造成全局污染,且模块间没有联系</p><p>后来提出了对象的写法,通过将函数作为一个对象的方法来实现,这样解决了直接使用函数作用模块的一些缺点,但是这种办法会暴露所以的模块成员,外部代码可以修改内部属性的值</p><p>也可以使用立即执行函数的写法,通过利用闭包来实现模块私有作用域的建立,同时不会对全局作用域造成污染</p><p>简单来说:模块化就是 把函数作为模块 ,<br>缺陷: 污染全局变量, 模块成员之间没什么关系<br>方法: 面向对象思想 ,并使用立即执行函数 ,实现闭包 避免了变量污染 同时同一模块内的成员也有了关系 在模块外部无法修改我们没有暴露出来的变量、函数 这就是简单的模块</p><h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="headerlink" title="js 的几种模块规范"></a>js 的几种模块规范</h2><ol><li><p>CommonJS 方法,它通过 require 来引入模块,通过 module.exports 定义模块的输出接口,这种模块加载方案是 服务端的解决方法,它是以同步的方式来引入模块的,因为在服务DAU文件都存储在本地磁盘,读取非常快,所以以同步的方式加载没有问题但如果是在浏览器端,由于模块加载时使用网络请求,因此使用异步加载的方式更加合适</p></li><li><p>AMD 方法,这种方法采用异步加载的方式来加载模块,模块的加载不影响后面语句的执行,所有依赖这个模块的语句都定义在一个回调函数里,等到加载完成后再执行回调函数 require.js 实现了 AMD 规范</p></li><li><p>CMD 方案,这种方案和 AMD 方案都是为了解决异步模块加载的问题,sea.js实现了 CMD 规范,它和require.js 的区别在于模块定义时对依赖的处理不同对依赖模块的执行时机的处理也不同</p></li><li><p>ES6 提出的方案,使用 import 和 export 的形式来导入导出模块,这种方案和上面三种方案都不同</p></li></ol><h1 id="AMD-和-CMD-规范的区别"><a href="#AMD-和-CMD-规范的区别" class="headerlink" title="AMD 和 CMD 规范的区别"></a>AMD 和 CMD 规范的区别</h1><p>主要区别在两个方面</p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同,AMD 推崇依赖前置,在定义模块的时候就要声明其依赖的模块,而 CMD 推崇就近依赖,只有利用某个模块的时候再去 require</p></li><li><p>第二个方面试依赖模块的执行时机处理不同,首先 AMD 和 CMD 对于模块的加载方式都是异步加载,不过他们在于模块的执行时机,AMD 在依赖模块加载完成后就直接执行依赖模块,依赖模块的执行顺序和我们书写的顺序不一定一致,而 CMD 在依赖模块加载完成后并不执行,只是下载而已,等到所有的依赖模块都加载好后,进入回调函数逻辑,遇到require语句时才执行对应模块</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化开发怎么做&quot;&gt;&lt;a href=&quot;#模块化开发怎么做&quot; class=&quot;headerlink&quot; title=&quot;模块化开发怎么做&quot;&gt;&lt;/a&gt;模块化开发怎么做&lt;/h1&gt;&lt;p&gt;模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="模块化" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
