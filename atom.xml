<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月刊少女野崎君のBlog</title>
  
  
  <link href="https://monthlygirl.github.io/atom.xml" rel="self"/>
  
  <link href="https://monthlygirl.github.io/"/>
  <updated>2024-01-13T12:38:22.000Z</updated>
  <id>https://monthlygirl.github.io/</id>
  
  <author>
    <name>月刊少女野崎君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue 模板编译和渲染</title>
    <link href="https://monthlygirl.github.io/2024/01/vue-template-compile-render.html"/>
    <id>https://monthlygirl.github.io/2024/01/vue-template-compile-render.html</id>
    <published>2024-01-13T12:38:22.000Z</published>
    <updated>2024-01-13T12:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板编译与渲染"><a href="#模板编译与渲染" class="headerlink" title="模板编译与渲染"></a>模板编译与渲染</h1><h2 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h2><p>在 Vue 中推崇 使用.vue 文件，在.vue 文件中使用 <template></template> 标签来编写 vue 语法。</p><ul><li>  Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。</li><li>  render 函数 会把模板内容生成对应的 VNode， VNode 经过 patch 过程 从而得到 可渲染的视图中的 VNode</li><li>  最后根据 VNode 创建 真实的 DOM 节点，并插入到视图中，最终完成视图的渲染更新。</li></ul><p>其中，【Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。】 这一过程称之为模版编译。</p><h2 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h2><ul><li>  Vue.js 通过编译将 template 模板转换成渲染函数 render，执行渲染函数就可以得到一个虚拟节点树。</li><li>  在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对于的 update 来修改视图。这个视图主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。</li></ul><p>简单点来说，在 Vue 的底层实现上，Vue 将模版编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应式系统。在状态改变时，Vue 会计算出重新渲染组件的最小代价并应用到 DOM 操作上</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/o0pdzflrj8alc6.png" alt="模板转换过程"></p><p>通过以上图帮助理解模板转换成视图的过程，由此也可得出，模板转换视图的关键词：模板函数（render）、VNode、patch</p><ul><li>  渲染函数：用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板（template）编译成渲染函数（render），当然我们也可以不写模板，直接写渲染函数，以获得更好的性能。</li><li>  VNode 虚拟节点：它可以代表一个真实的 DOM 节点。通过 createElement 方法能将 VNode 渲染成 DOM 节点。简单来说 vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。</li><li>  patch： 虚拟 DOM 最核心的部分，它可以将 Vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于 Snabbdom 实现的。并在其基础上做了很多调整和改进。</li></ul><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/kaypjulrj8zejg.png" alt="视图转换"></p><h2 id="模板编译原理"><a href="#模板编译原理" class="headerlink" title="模板编译原理"></a>模板编译原理</h2><p>模板编译中有个环节是将模板编译成 render 函数，这个过程我们把它称作为<strong>编译</strong>。虽然我们可以为组件编写 render 函数，但使用 template 模板更加直观，也更符合我们的开发习惯。</p><p>Vue.js 提供了两个版本，一个是 Runtime + Compiler，一个是 Runtime Only。前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render 函数</p><h3 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\platforms\web\entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="title function_">warn</span>(<span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">    <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span>;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">                    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">                template,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                    shouldDecodeNewlines,</span><br><span class="line">                    shouldDecodeNewlinesForHref,</span><br><span class="line">                    <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                    <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="variable language_">this</span></span><br><span class="line">            );</span><br><span class="line">            options.<span class="property">render</span> = render;</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码之前分析过，由此也可知编译入口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">    template,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable language_">this</span></span><br><span class="line">);</span><br><span class="line">options.<span class="property">render</span> = render;</span><br><span class="line">options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br></pre></td></tr></table></figure><p>compileToFunctions 方法就是把模板 template 编译生成 render 以及 staticRenderFns。</p><p>进入 compileToFunctions 方法中可以看到，compileToFunctions 实际上是 createCompiler 方法的返回值，该方法接受一个编译配置参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: string,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看 crateCompiler 方法 看到，它实际又是通过调用 crateCompilerCreator 方法返回的。<br>这个方法中 有个 baseCompile，真正的编译过程都在这个函数。 所以 baseCompile 才是真正的模板编译流程及原理所在。<br>接下来我们从 createCompilerCreator 开始分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompilerCreator</span> (<span class="attr">baseCompile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createCompiler</span> (<span class="attr">baseOptions</span>: <span class="title class_">CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">compile</span> (</span><br><span class="line">      <span class="attr">template</span>: string,</span><br><span class="line">      options?: <span class="title class_">CompilerOptions</span></span><br><span class="line">    ): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> finalOptions = <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions)</span><br><span class="line">      <span class="keyword">const</span> errors = []</span><br><span class="line">      <span class="keyword">const</span> tips = []</span><br><span class="line">      finalOptions.<span class="property">warn</span> = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">        (tip ? tips : errors).<span class="title function_">push</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="comment">// merge custom modules</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">modules</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">modules</span> =</span><br><span class="line">            (baseOptions.<span class="property">modules</span> || []).<span class="title function_">concat</span>(options.<span class="property">modules</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge custom directives</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">directives</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">directives</span> = <span class="title function_">extend</span>(</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions.<span class="property">directives</span> || <span class="literal">null</span>),</span><br><span class="line">            options.<span class="property">directives</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy other options</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="string">&#x27;modules&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;directives&#x27;</span>) &#123;</span><br><span class="line">            finalOptions[key] = options[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> compiled = <span class="title function_">baseCompile</span>(template, finalOptions)</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        errors.<span class="property">push</span>.<span class="title function_">apply</span>(errors, <span class="title function_">detectErrors</span>(compiled.<span class="property">ast</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      compiled.<span class="property">errors</span> = errors</span><br><span class="line">      compiled.<span class="property">tips</span> = tips</span><br><span class="line">      <span class="keyword">return</span> compiled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compile,</span><br><span class="line">      <span class="attr">compileToFunctions</span>: <span class="title function_">createCompileToFunctionFn</span>(compile)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCompilerCreator 方法返回了一个 createCOmpiler 的函数，接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法 和 compileToFunctions 属性，这个 compileToFunctions 就是对应 $mount 函数调用的 compileToFunctions 方法， 它又是调用 createCompileToFunction 方法的返回值。<br>接下来看下 createCompileToFunction 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompileToFunctionFn</span> (<span class="attr">compile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">compileToFunctions</span> (</span><br><span class="line">    <span class="attr">template</span>: string,</span><br><span class="line">    options?: <span class="title class_">CompilerOptions</span>,</span><br><span class="line">    vm?: <span class="title class_">Component</span></span><br><span class="line">  ): <span class="title class_">CompiledFunctionResult</span> &#123;</span><br><span class="line">    options = <span class="title function_">extend</span>(&#123;&#125;, options)</span><br><span class="line">    <span class="keyword">const</span> warn = options.<span class="property">warn</span> || baseWarn</span><br><span class="line">    <span class="keyword">delete</span> options.<span class="property">warn</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return 1&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">&#x27;It seems you are using the standalone build of Vue.js in an &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;The template compiler cannot work in this environment. Consider &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;templates into render functions.&#x27;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check cache</span></span><br><span class="line">    <span class="keyword">const</span> key = options.<span class="property">delimiters</span></span><br><span class="line">      ? <span class="title class_">String</span>(options.<span class="property">delimiters</span>) + template</span><br><span class="line">      : template</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile</span></span><br><span class="line">    <span class="keyword">const</span> compiled = <span class="title function_">compile</span>(template, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check compilation errors/tips</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">errors</span> &amp;&amp; compiled.<span class="property">errors</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Error compiling template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">          compiled.<span class="property">errors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">`- <span class="subst">$&#123;e&#125;</span>`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">tips</span> &amp;&amp; compiled.<span class="property">tips</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        compiled.<span class="property">tips</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="title function_">tip</span>(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn code into functions</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> fnGenErrors = []</span><br><span class="line">    res.<span class="property">render</span> = <span class="title function_">createFunction</span>(compiled.<span class="property">render</span>, fnGenErrors)</span><br><span class="line">    res.<span class="property">staticRenderFns</span> = compiled.<span class="property">staticRenderFns</span>.<span class="title function_">map</span>(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createFunction</span>(code, fnGenErrors)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check function generation errors.</span></span><br><span class="line">    <span class="comment">// this should only happen if there is a bug in the compiler itself.</span></span><br><span class="line">    <span class="comment">// mostly for codegen development use</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((!compiled.<span class="property">errors</span> || !compiled.<span class="property">errors</span>.<span class="property">length</span>) &amp;&amp; fnGenErrors.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed to generate render function:\n\n`</span> +</span><br><span class="line">          fnGenErrors.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; err, code &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;err.toString()&#125;</span> in\n\n<span class="subst">$&#123;code&#125;</span>\n`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compilerToFunctions 接收3个参数：编译模板 template，编译配置 options 和 Vue 实例 vm<br>最终返回 render 和 staticRenderFns 函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>模板编译过程：template —&gt; compiler(parse,optimize, generate) —&gt; render 函数（VNode）</p><p>模板编译是通过 Compiler 完成，compiler 可以分成 parse、optimize 和 generate 三个阶段，最终得到 render function。</p><p>compile 函数在执行 createCompilerToFunction 的时候作为参数传入，它是 createCompiler 函数中定义的 compile  函数。</p><p>Vue 在实现 compile 的过程中 利用函数柯里化技巧把基础的编译过程函数抽出来，通过 createCompilerCreator(baseCompile) 的方式把真正编译的过程和其他逻辑如对编译配置处理、缓存处理等剥离开。很巧妙的设计</p><p>编译入口最终终于找到了，主要就是执行了如下几个逻辑：</p><ol><li>Parse 解析：解析模板字符串生成 AST<br> Parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成 AST</li><li>Optimize优化：优化语法树<br> Optimize 主要作用是标记 static 静态节点，这是Vue 在编译过程中做优化，后面当 update 视图更新时，patch 过程中 diff 算法会直接跳过静态节点，从而减少 比较的过程 优化 patch 的性能。</li><li>Generate 生成：生成 render<br> Generate 是将 AST 转换成 render function 字符串的过程，得到的结果是 render 字符串已经 staticRenderFns 字符串。<br>最终 baseCompile 的返回值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">ast</span>: ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span></span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终返回了 ast、render、staticRenderFns, 且通过 generate 处理 ast 之后得到的是个对象。</li></ol><p>经历了这三个阶段后，vue 的 模板 template 就转换成 它 渲染 Vnode 所需的 render 函数了。</p><h2 id="Parse-解析"><a href="#Parse-解析" class="headerlink" title="Parse 解析"></a>Parse 解析</h2><p>解析整个模板的时候它的流程应该是这样子的</p><ul><li>HTML 解析器是主线，先用 HTML 解析器进行解析整个模板，在解析过程中如果碰到文本内容，那么就调用文本解析器来解析文本，如果碰到文本中包含过滤器的那就调用过滤器解析器来解析</li></ul><p>parse 解析流程：</p><ol><li>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML解析器、文本解析器和过滤器解析器。</li><li>文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数 parse 中先调用 HTML 解析器 parseHTML 函数对模板字符串进行解析。</li><li>解析器内维护了一个栈，用来保证构建的 AST 节点层级与真正 DOM 层级一致。</li><li>文本解析器的作用就是将 HTML 解析器解析得到的文本内容进行二次解析，解析文本内容中是否包含变量，如果包含变量，则将变量提取出来进行加工，为后续生成 render 函数做准备。</li></ol><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/9s93vdlrjcbzzg.png" alt="parse解析"></p><h2 id="Optimize-优化"><a href="#Optimize-优化" class="headerlink" title="Optimize 优化"></a>Optimize 优化</h2><p>有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点。</p><p>模板编译的最终目的是用模板生成一个 render 函数，而用 render 函数就可以生成与模板对应的 VNode,之后再进行 patch 算法 完成视图渲染。</p><p>patch 算法 用来对比新旧 VNOde 之间的差异。</p><p>在上面我们还说了，静态节点不管状态怎么变化它是不会变的，因此，我们可以在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，告诉后面 patch 过程 打了标记的节点是不需要对比的，只需要 克隆 一份。</p><p>优化阶段实际上就干了两件事：</p><ol><li>在 AST 中找出所有静态节点并打上标记</li><li>在 AST 中找出所有的静态根节点打上标记<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">optimize</span>(<span class="params">root: ?ASTElement, options:CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    isStaticKey = <span class="title function_">genStaticKeysCached</span>(options.<span class="property">staticKey</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    isPlatformReservedTag = options.<span class="property">isReservedTag</span> || no</span><br><span class="line">    <span class="title function_">markStatic</span>(root)</span><br><span class="line">    <span class="title function_">markStaticRoots</span>(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="标记静态节点"><a href="#标记静态节点" class="headerlink" title="标记静态节点"></a>标记静态节点</h3><p>首先先从根节点开始写，先标记根节点是否为静态美蒂娜，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点还有子节点就继续递归，直到标记完所有节点</p><p>静态节点需满足一下几点要求：</p><ul><li>如果使用了 v-pre，那么他就是静态节点</li><li>如果没有使用 v-pre 那么它需要满足<ul><li>不能使用动态绑定语法 即 v-、@、：开头的属性</li><li>不能使用 v-if、v-else 这些</li><li>不能是内置组件，即标签名不能是slot、component</li><li>不能是自定义组件</li><li>节点的所有属性的key 都必须是静态节点才有的key,</li></ul></li></ul><h3 id="标记静态根节点"><a href="#标记静态根节点" class="headerlink" title="标记静态根节点"></a>标记静态根节点</h3><p>和静态节点类似，都是从 AST 根节点向下递归寻找，它要想成为静态根节点，必须满足</p><ul><li>节点本身必须是静态节点</li><li>必须拥有子节点</li><li>子节点不能是只有一个文本节点</li></ul><h2 id="Generate-生成"><a href="#Generate-生成" class="headerlink" title="Generate 生成"></a>Generate 生成</h2><p>根据模板对应的抽象语法树 AST 生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟DOM。</p><h1 id="模板编译整体流程"><a href="#模板编译整体流程" class="headerlink" title="模板编译整体流程"></a>模板编译整体流程</h1><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/x8odshlrjcc69i.jpg" alt="模板编译"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板编译与渲染&quot;&gt;&lt;a href=&quot;#模板编译与渲染&quot; class=&quot;headerlink&quot; title=&quot;模板编译与渲染&quot;&gt;&lt;/a&gt;模板编译与渲染&lt;/h1&gt;&lt;h2 id=&quot;什么是模板编译&quot;&gt;&lt;a href=&quot;#什么是模板编译&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="模板编译和渲染" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%92%8C%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue 的构建和初始化</title>
    <link href="https://monthlygirl.github.io/2024/01/vue-build-init.html"/>
    <id>https://monthlygirl.github.io/2024/01/vue-build-init.html</id>
    <published>2024-01-13T08:06:14.000Z</published>
    <updated>2024-01-13T08:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-的构建和初始化"><a href="#Vue-的构建和初始化" class="headerlink" title="Vue 的构建和初始化"></a>Vue 的构建和初始化</h1><h1 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h1><p>通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本</p><h2 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a>Runtime Only</h2><p>编译时转化，离线编译。</p><p>Runtime Only 版本通常需要借助如  webpack 的 vue-loader工具 把 .vue 文件 编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更 轻量，性能更优。</p><h2 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a>Runtime + Compiler</h2><p>运行时，客户端编译</p><p>如果没对代码做预编译，但又使用了 Vue 的 template 属性 并传入一个字符串，则需要在客户端编译模板，即运行时编译。因为在 Vue2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本，很显然，这个编译过程对性能有一定的损耗。所以我们通常更推荐使用 Runtime- Only 的 Vue.js</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>当代码执行 import Vue from ‘vue’ 的时候，是从这个入口执行代码来初始化 Vue。 Vue 实际 是一个用 Function 实现的类，只能通过 <strong>new Vue()</strong> 实例化。</p><p>为什么 Vue 不用 ES6 的 Class 去实现呢？</p><p>在 Vue 初始化文件中，有很多 xxxMin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，<strong>Vue 按功能把这些扩展分散都多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的</strong>。 这么做的好处就是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p><p>Vue.js 在整改初始化过程中，除了给它的原型 prototype 上扩展方法，还会通过 initGlobal API 给 Vue 这个对象本身扩展全局的静态方法，即 Vue 的全局 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>,<span class="variable constant_">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span></span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了以下几件事情：<br>合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化 data、props、computed、watcher等等。在初始化的最后，如果有检测到 el 属性，则调用 vm.$mount 方法挂在 vm, 挂载的目标就是把模版渲染成最终的 DOM</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p><h2 id="new-Vue-发生了什么-init"><a href="#new-Vue-发生了什么-init" class="headerlink" title="new Vue 发生了什么 - init"></a>new Vue 发生了什么 - init</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        endTag = <span class="string">`vuw-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponents</span>) &#123;</span><br><span class="line">        <span class="comment">// 每个子组件初始化时走这里，这里只做了一些性能优化，</span></span><br><span class="line">        <span class="comment">// 将组建配置对象上的一些深层次属性 放到 vm.$options 选项中，以提高代码的执行效率</span></span><br><span class="line">        <span class="title function_">initInternalComponents</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 初始化根组件时走到这里，合并 Vue 的全局配置到根组件的局部配置，如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中</span></span><br><span class="line"><span class="comment">         * 至于每个子组件的选项合并则发生在两个地方：</span></span><br><span class="line"><span class="comment">         * 1. Vue.component 方法注册的全局组件在注册时做了选项合并</span></span><br><span class="line"><span class="comment">         * 2. &#123; component: &#123; xx &#125;&#125; 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并,包括根组件中的 components 配置</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">       )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> ) &#123;</span><br><span class="line">        <span class="comment">// 设置代理，将 vm 实例上的属性代理到 vm._renderProxy</span></span><br><span class="line">        <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化组件实例关系属性，比如 $parent $children $root $refs 等</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化自定义事件，这里需要注意一点，所以我们在 &lt;comp <span class="doctag">@click</span>=&quot;handleClick&quot; /&gt; 上注册的事件，监听者不是父组件， 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件的插槽信息，得到 vm.$slot， 处理渲染函数，得到 vm.$createElement 方法,即 h 函数，将 render函数转为 vnode 的方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="comment">// 调用 beforeCreate 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化组件的 inject 配置，得到 result[key] = val 形式的配置对象，然后对结果数据进行相应式处理，并代理每个 key 到 vm 实例</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm)</span><br><span class="line">    <span class="comment">// 数据响应式的重点，处理 props、method、data、computed、watch</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件配置项上的 provide 对象，挂载到 vm._provided 属性上</span></span><br><span class="line">    <span class="title function_">initProvide</span>(vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 created 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">        <span class="title function_">mark</span>(endTag)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 配置项上 有 el ，则自动调用 $mount 方法，如果没有需要手动调用</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">        vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了几件事情，合并配置、初始化生命周期、初始化事件、初始化渲染、执行 beforeCrate 钩子、初始化依赖注入内容、初始化 prop、methods、data、computed、watcher，解析组件配置上的 provide 对象，执行 created 钩子，最后 mount 挂载真实 DOM</p><h2 id="Vue-实例挂载-mount"><a href="#Vue-实例挂载-mount" class="headerlink" title="Vue 实例挂载 - $mount"></a>Vue 实例挂载 - $mount</h2><p>Vue 中是通过 $mount 实例方法去挂在 vm 的，$mount 方法的实现是和平台、构建方式相关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idToTemplate = <span class="title function_">cached</span>(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="title function_">query</span>(id)</span><br><span class="line">    <span class="keyword">return</span> el &amp;&amp; el.<span class="property">innerHTML</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydration?: boolean</span>): <span class="title class_">Components</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span> </span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> template, <span class="variable language_">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">                <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                shouldDecodeNewLines,</span><br><span class="line">                shouldDecodeNewlinesForHref,</span><br><span class="line">                <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">            &#125;, <span class="variable language_">this</span>)</span><br><span class="line">            options.<span class="property">render</span> = render</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原先原型上的 $mount 方法</span></span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对 el 做了现在， Vue 不能挂在在 body、html 这样的根节点上，接下来的关键逻辑 — 如果没有定义 render 方法，则会把 el 或 template 字符串转换成 render 方法。在 vue2.0 版本中，所以 vue 的组件渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或 template 属性。最终都会转换成 render 方法， 那么这个过程是 vue 的一个 “在线编译” 的过程，他是调用 compileToFunctions 方法实现的。最后调用原先原型上的 $mount 方法挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el): <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mountComponents</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>$mount</em> 方法支持传入 2 个参数，第一个是 el, 它表示挂载的元素，可以是字符串，也可以说 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。<br>*<em>$mount</em> 方式的实质是调用 mountComponent 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountComponent 核心就是先实例化一个渲染 watcher，在它的回调函数中调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成 虚拟 Node，最终调用 vm._update 更新 DOM。 Watcher 在这里起到两个作用，一个是初始化的时候会执行毁掉你函数，另一个是当 vm 实例中的监测数据发生变化时执行的回调呢函数。<br>函数最后判断为根节点的时候 设置 vm._isMounted 为true，表示这个实例已经挂载了，同时执行 mounted 钩子函数。<br>这里 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 null 则表示当前是根 vue 实例</p><p>mountComponent 会完成整个渲染工作，包含最核心的 2 个 方法： vm._render 和 vm._update</p><h2 id="渲染-DOM-render"><a href="#渲染-DOM-render" class="headerlink" title="渲染 DOM - render"></a>渲染 DOM - render</h2><p>Vue 的 _render 方法是实例的一个私有方法，他用来把实例渲染成一个虚拟 Node</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">        _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">        vm.<span class="property">$slots</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">          vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>vm._render 最终是通过 执行 createElement 方法并返回的是 vnode，它是一个虚拟 node</p><h2 id="生成虚拟-DOM-createElement"><a href="#生成虚拟-DOM-createElement" class="headerlink" title="生成虚拟 DOM - createElement"></a>生成虚拟 DOM - createElement</h2><p>Vue 利用 createElement 方法创建 VNode，createElement 方法实际上是对 _createElement 方法的封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\vdom\create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: any,</span><br><span class="line">  <span class="attr">data</span>: any,</span><br><span class="line">  <span class="attr">children</span>: any,</span><br><span class="line">  <span class="attr">normalizationType</span>: any,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: boolean</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((<span class="attr">data</span>: any).<span class="property">__ob__</span>)) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">is</span>)) &#123;</span><br><span class="line">    tag = data.<span class="property">is</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">key</span>) &amp;&amp; !<span class="title function_">isPrimitive</span>(data.<span class="property">key</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.<span class="property">key</span>)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-primitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instead.&#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.<span class="property">scopedSlots</span> = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.<span class="property">pre</span>) &amp;&amp; <span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_createElement 方法有 5个参数：</p><ul><li>context 表示 VNode 的上下文环境，它是 Component 类型</li><li>tag 表示标签，它可以是一个 字符串，也可以是一个 Component</li><li>data 表示 VNode 的数据，它是一个 VNodeData 类型</li><li>children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准版 的 VNode 数组</li><li>normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的，经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array</li></ul><p>每个 VNode 有 children，children 的每个元素也是一个 VNode，这样就形成了一个 Vnode tree，它很好的描述了我们的 DOM tree</p><p>回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 Vnode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成。</p><h2 id="渲染真实-DOM-update"><a href="#渲染真实-DOM-update" class="headerlink" title="渲染真实 DOM - update"></a>渲染真实 DOM - update</h2><p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。_update 方法的作用是把 VNode 渲染成真实的 DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\lifecycle.js</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>_update 的核心就是调用 vm.patch 方法，这个方法实际上在不同的平台上有不同的实现方式。比如，服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器渲染中，它指向了 patch 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules form <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = platformModules.<span class="title function_">contact</span>(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">Function</span> = <span class="title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中 nodeOps 封装了一系列 DOM 操作的方法， modules 定义了一些模块的钩子函数的实现。</p><p>createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法。具体源码位置src\core\vdom\patch.js，源码过长就不放出来。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>了解了 Vue 的整个初始化过程，得出</p><ul><li><p>Vue 初始化过程是怎样的(new Vue() 发生了什么)</p><ol><li>_init() 初始化数据、状态等<ul><li>处理组件配置项<ul><li>初始化组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</li><li>初始化每个子组件做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</li></ul></li><li>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs等</li><li>处理自定义事件</li><li>调用 beforeCreate 钩子函数</li><li>初始化组件的 inject配置，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应处理，并代理每个 key 到 vm 实例上</li><li>数据响应式，处理 props、methods、data、computed、watch 等选项</li><li>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</li><li>调用 created 钩子函数</li><li>如果有 el 配置，自动 $mount </li><li>进入挂载阶段</li></ul></li></ol></li><li><p>生命周期过程是什么<br><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-的构建和初始化&quot;&gt;&lt;a href=&quot;#Vue-的构建和初始化&quot; class=&quot;headerlink&quot; title=&quot;Vue 的构建和初始化&quot;&gt;&lt;/a&gt;Vue 的构建和初始化&lt;/h1&gt;&lt;h1 id=&quot;构建版本&quot;&gt;&lt;a href=&quot;#构建版本&quot; class=&quot;</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="构建和初始化" scheme="https://monthlygirl.github.io/tags/%E6%9E%84%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>复杂异步嵌套的执行机制</title>
    <link href="https://monthlygirl.github.io/2024/01/Interview-event-loop&amp;async/await.html"/>
    <id>https://monthlygirl.github.io/2024/01/Interview-event-loop&amp;async/await.html</id>
    <published>2024-01-11T13:41:30.000Z</published>
    <updated>2024-01-11T13:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂异步嵌套逻辑分析"><a href="#复杂异步嵌套逻辑分析" class="headerlink" title="复杂异步嵌套逻辑分析"></a>复杂异步嵌套逻辑分析</h1><hr><h2 id="async-await-在事件循环中的表现"><a href="#async-await-在事件循环中的表现" class="headerlink" title="async/await 在事件循环中的表现"></a>async/await 在事件循环中的表现</h2><hr><p>对于不同Chrome 版本，<strong>async/await</strong> 会有两种表现，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不同的 Chrome 版本，会输出两种结果</p><ul><li><strong>1 3 4 2 5</strong></li><li><strong>1 3 4 5 2</strong></li></ul><blockquote><p>根据 最新的 ECMAScript 规范下，第一种为正确表现</p></blockquote><h2 id="最新的-ECMAScript-规范"><a href="#最新的-ECMAScript-规范" class="headerlink" title="最新的 ECMAScript 规范"></a>最新的 ECMAScript 规范</h2><p>最新的 ECMAScript 规范中，await 直接使用 Promise.resolve() 相同的语义，也就是说，如果 await 后面跟的是一个 Promise，则直接返回 Promise 本身。如果不是，则使用 Promise.resolve 包裹后返回。<br>所以上面的代码我们可以理解为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>console.log(2) 在第一轮事件循环时就加入微任务队列，然后 console.log(5) 才加入微任务队列，所以 2 的打印顺序在前。</p><h2 id="老版的-ECMAScript-规范"><a href="#老版的-ECMAScript-规范" class="headerlink" title="老版的 ECMAScript 规范"></a>老版的 ECMAScript 规范</h2><p>await 后不论是否为 Promise，都会产生一个新的 Promise，再将后面的内容 resolve 出去</p><blockquote><p> 其实最初关于 async/await 的相关规范和上述最新规范中行为是一致的，但是中间有一段时间 ECMA 规范有一些变化，最后又变回来了。</p></blockquote><p>根据老版规范，上述代码又可以理解成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve1</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="title function_">resolve2</span>()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 resolve1 内又 resolve 了 一个 Promise，所以在这里已经是异步任务了，而不是立即变为 fulfilled 的状态，所以 console.log(2) 并不是在第一轮事件循环中被加入微任务队列，而console.log(5) 是第一轮事件循环中就被加入到任务队列，最终打印顺序为 1 3 4 5 2</p><h1 id="复杂异步嵌套"><a href="#复杂异步嵌套" class="headerlink" title="复杂异步嵌套"></a>复杂异步嵌套</h1><p>根据上面的分析来做套题，帮助理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;),<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：script start、async1 start、async2、promise1、script end、async2 end、promise2、setTimeout</p><ol><li>定义了 async1、async2 函数，打印 script start </li><li>执行 setTimeout 回调，交由 web API, web API 将它挂入宏任务队列</li><li>执行 async1 函数，打印 async1 start</li><li>执行 async2 函数，打印 async2，将 async2 end 挂入 微任务队列</li><li>执行 new Promise ，同步执行传入构造函数的函数， 打印 promise1，将 promise2 挂入 微任务队列</li><li>打印 script end，宏任务 执行完毕</li><li>执行微任务 打印 async2 end</li><li>执行微任务 打印 promise2，微任务执行完毕，一次事件循环结束</li><li>执行下一个宏任务，查看宏任务队列，打印 setTimeout。</li><li>宏任务和 微任务都执行完毕</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;a href=&quot;#复杂异步嵌套逻辑分析&quot; class=&quot;headerlink&quot; title=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;/a&gt;复杂异步嵌套逻辑分析&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;async-await-在事件循环中的表现&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="事件循环" scheme="https://monthlygirl.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
    <category term="async await" scheme="https://monthlygirl.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>重排（reflow）和重绘（repaint）</title>
    <link href="https://monthlygirl.github.io/2024/01/Interview-reflow-repaint.html"/>
    <id>https://monthlygirl.github.io/2024/01/Interview-reflow-repaint.html</id>
    <published>2024-01-09T13:21:16.000Z</published>
    <updated>2024-01-09T13:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h1><ol><li>HTML -&gt; 被 HTML 解析器解析成 DOM 树</li><li>CSS -&gt; 被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树 生成一颗渲染树（Render Tree） 这一个过程称之为 Attachment</li><li>生成布局（flow），浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制（paint）在屏幕上，显示出整个页面</li></ol><p>4和5 结合起来也就是我们所说的渲染，同时也是最耗时的部分</p><h1 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h1><p>在网页生成时，至少会渲染一次。在用户访问的过程中，还会不断触发重绘和重排，从而影响性能。所以在开发过程中应该避免页面的重排重绘。</p><h1 id="什么是重绘、重排？"><a href="#什么是重绘、重排？" class="headerlink" title="什么是重绘、重排？"></a>什么是重绘、重排？</h1><p>什么是重绘、重排？从字面意思就可以理解</p><ul><li>重绘：重新绘制，一般发生在布局不变，视觉上变化的时候，比如阴影颜色</li><li>重排：重新排列，一般发生在布局变化或元素大小发生变化时</li></ul><p>如上概念可以得出： </p><ol><li>单单改变元素的外观，肯定不会引起网页的重新生成布局。</li><li>改变元素大小和布局变化时，那元素乃至周边的 DOM 可能都需要重新绘制。</li></ol><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h1 id="重排（reflow）："><a href="#重排（reflow）：" class="headerlink" title="重排（reflow）："></a>重排（reflow）：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><pre><code>当 DOM 的变化影响了元素的几何信息（如位置、大小等），浏览器都需要重新计算元素的几何属性。这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素</code></pre><h2 id="下面的情况会发生重排："><a href="#下面的情况会发生重排：" class="headerlink" title="下面的情况会发生重排："></a>下面的情况会发生重排：</h2><pre><code>+ 页面初始渲染，这是开销最大的一次重排+ 添加/删除可见的 DOM 元素+ 改变元素位置+ 改变元素尺寸，比如 边距、填充、边框、宽度高度等+ 改变元素内容，比如文字数量、图片大小等+ 改变元素字体大小+ 改变浏览器窗口尺寸，比如 resize 事件发生时+ 激活 css 伪类 比如 :hover+ 设置 style 属性的值，+ 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等</code></pre><table><thead><tr><th>常见引起重排的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewNeeded()</td><td></td><td></td></tr></tbody></table><h2 id="重排的影响范围："><a href="#重排的影响范围：" class="headerlink" title="重排的影响范围："></a>重排的影响范围：</h2><pre><code>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围 DOM 重新排列，影响范围有两种：+ 全局范围：从根节点 html 开始对整个渲染树进行重新渲染+ 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</code></pre><h3 id="全局范围重排"><a href="#全局范围重排" class="headerlink" title="全局范围重排"></a>全局范围重排</h3><pre><code>一般情况下当根节点 或 子节点发生重大布局变化时，往往会发生全局范围的重排</code></pre><h3 id="局部范围重排"><a href="#局部范围重排" class="headerlink" title="局部范围重排"></a>局部范围重排</h3><pre><code>只在某个 DOM 内部触发重排，一个元素形成 BFC 后，这个元素内部发生变化不会影响到外部的其他元素，只会影响该元素内部的其他元素</code></pre><h2 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h2><pre><code>重排的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓。通过减少重排的负面影响来提供用户体验的最简单方式就是尽可能的减少重排次数</code></pre><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><pre><code>尽量以局部布局的形式组织 html 结构，尽可能小的影响重排范围+ 不要使用 table 布局，可能一个小改动会造成整个 table 的重新布局。不得已的情况下，可以设置 table-layout: auto; 或者是 table-layout: fixed 这样可以让 table 一行一行的渲染。这样的做法是为了限制 reflow 的影响范围。+ 减少 DOM 嵌套</code></pre><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><ul><li>样式集中改变， 不频繁的操作样式。</li><li>分离 DOM 读写操作，DOM 的多个读写操作，应该放在一起，不要两个读操作之间，加入一个写操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>原来的操作会触发四次重排，修改后只会触发一次，这是因为我们的浏览器的渲染机制。<br>当我们修改元素的几何属性，导致浏览器发生重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定数量或到了一定的时间间隔，浏览器就会批量操作。</p><ul><li><p>将 元素 形成 BFC</p></li><li><p>优化动画<br>  将动画效果应用在 BFC 元素上，减少重排范围。动画效果可以牺牲一些平滑，来换取速度，这中间的度自己衡量。比如实现一个动画 以1个像素单位移动这样最平滑，但是 layout 会过于频繁，大量消耗 CPU 资源，如果以3个像素为单位移动则会好很多</p><ul><li><p>启用 GPU 加速，GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图像操作交给 GPU 来完成。因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p>GPU 加速通常包括以下几个部分： Canvas2D，布局合成， CSS3 转换（transitions），CSS3 3D 变换（transform），WebGl 视频</p></li></ul></li></ul><h1 id="重绘（repaints）"><a href="#重绘（repaints）" class="headerlink" title="重绘（repaints）"></a>重绘（repaints）</h1><p>当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，就叫重绘</p><h2 id="常见引起重绘的属性"><a href="#常见引起重绘的属性" class="headerlink" title="常见引起重绘的属性"></a>常见引起重绘的属性</h2><table><thead><tr><th>常见引起重绘的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td></td><td>background-size</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。Layout： 重排，又叫回流。Paint：重绘，重绘重排这些步骤都是在 CPU 中发生的。 Composite Layers：CPU 把生成的 BitMap 传输到 GPU ，渲染到屏幕上</li><li>CSS3 就是在 GPU 发生的： Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;页面生成的过程：&quot;&gt;&lt;a href=&quot;#页面生成的过程：&quot; class=&quot;headerlink&quot; title=&quot;页面生成的过程：&quot;&gt;&lt;/a&gt;页面生成的过程：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HTML -&amp;gt; 被 HTML 解析器解析成 DOM 树&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="reflow、repaint" scheme="https://monthlygirl.github.io/tags/reflow%E3%80%81repaint/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-JavaScript.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-JavaScript.html</id>
    <published>2023-12-24T12:19:58.000Z</published>
    <updated>2023-12-24T12:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonJS、AMD、CMD-和-ESM"><a href="#CommonJS、AMD、CMD-和-ESM" class="headerlink" title="CommonJS、AMD、CMD 和 ESM"></a>CommonJS、AMD、CMD 和 ESM</h1><h2 id="一、Common-JS"><a href="#一、Common-JS" class="headerlink" title="一、Common JS"></a>一、Common JS</h2><ol><li>CommonJS 它是通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务端的解决方案，它是以同步的方式来引入模块的。（因为服务端的文件都存储在本地磁盘，所以读取起来非常快，用同步的方式没有问题，但在浏览器端，由于模块加载是使用网络请求的，所以使用 异步的方式更合适）</li><li>CommonJS 输出的是一个只的拷贝，会有缓存，这个值一旦输出，模块内部更新， 对于输出的这个值不会有影响</li><li>CommonJS 是在运行时加载的，CommonJS 模块是个对象，输入时会先加载一整个模块生成一个对象，从这个对象上取值</li></ol><h2 id="二、AMD"><a href="#二、AMD" class="headerlink" title="二、AMD"></a>二、AMD</h2><ol><li><p>AMD 采用 异步方式来加载模块的，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成再去执行回调函数。require.js 实现了 AMD 规范</p></li><li><p>AMD 在使用模块依赖时，必须先声明依赖，并且依赖模块加载完成就立即执行，依赖模块的顺序可能和我们书写的并不一致</p></li></ol><h2 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h2><ol><li>CMD 和 AMD 一样都是为了解决异步模块加载问题。它和 AMD 的区别在于 模块定义时对依赖的处理不同 和依赖模块的执行时机处理不同。</li><li>CMD 模块依赖可以就近声明，使用时再去声明</li><li>CMD 会先将模块依赖下好，等待代码执行时再去执行，所以模块依赖执行顺序和我们书写的顺序一致。</li></ol><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><ol><li><p>ESM 是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</p></li><li><p>ESM 输出的是一个值的引用，即模块内部值更新，所有引用该值的地方都会更新</p></li><li><p>ESM 是在代码解析时生成的，采用静态优化 是静态执行的，因此不能有变量、表达式等这些只有在代码运行时才能得到结果写法。</p></li><li><p>ESM 对外输出的是一个接口，必须和模块内部建议一对一的关系。</p></li></ol><p>5 ESM import 输入的变量都是只读的，并且import 会有提升效果，提升到首部提前执行</p><ol start="6"><li>ESM import 多个重复语句，只会执行一次。</li></ol><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">executor</span>(resolve, reject) </span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span>  <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>))</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CommonJS、AMD、CMD-和-ESM&quot;&gt;&lt;a href=&quot;#CommonJS、AMD、CMD-和-ESM&quot; class=&quot;headerlink&quot; title=&quot;CommonJS、AMD、CMD 和 ESM&quot;&gt;&lt;/a&gt;CommonJS、AMD、CMD 和 E</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-Webpack.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-Webpack.html</id>
    <published>2023-12-24T09:28:17.000Z</published>
    <updated>2023-12-24T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js</p><h2 id="1-有哪些常用的-loader"><a href="#1-有哪些常用的-loader" class="headerlink" title="1. 有哪些常用的 loader"></a>1. 有哪些常用的 loader</h2><ul><li>file-loader: 处理文件的 loader,处理文件导入地址并替换成其访问地址，并把文件输出到相应位置</li><li>babel-loader: 将 es6 转 es5</li><li>sass-loader: 将 sass 转 css</li><li>css-loader: 处理样式间的相互引用</li><li>ts-loader: 处理 TS 文件</li><li>vue-loader： 处理 .vue 文件<br>….</li></ul><p>loader 的作用就是用于处理源文件代码，将它们转换成 webpack 可处理的模块，处理源码文件时，针对不同的源码模块使用 不同的 loader 处理</p><p>loader 的执行顺序是从右往左，从下往上，</p><blockquote><p>modules: {<br>    rules: [{<br>        use: [<br>            ‘style-loader’<br>            ‘css-loader’, ‘postcss-loader’, ‘sass-loader’]<br>    }]<br>}</p></blockquote><h2 id="2-常见的-Plugin"><a href="#2-常见的-Plugin" class="headerlink" title="2.常见的 Plugin"></a>2.常见的 Plugin</h2><ul><li>html-webpack-plugin: dist 下生成 html 文件，依赖于 html-loader</li><li>clean-webpack-plugin: 清除目录文件</li><li>mini-css-extract-plugin: 分离样式，提取css 文件，按需加载</li><li>webpack-bundle-analyzer: webpack打包分析插件<br>….</li></ul><h2 id="3-loader-和-plugin-间的区别"><a href="#3-loader-和-plugin-间的区别" class="headerlink" title="3.loader 和 plugin 间的区别"></a>3.loader 和 plugin 间的区别</h2><p>loader 是一个文件转换器，因为 webpack 只能识别 js 和 json 文件，所以其他类型的文件需要通过 loader 进行转换<br>比如： a.scss 转 b.css， 单纯的就是一个 文件转换的过程<br>loader 只运行在打包文件前</p><p>plugin 用于扩展 webpack 的功能，用于执行任意类型的任务，所有 loader 解决不了的事都可以使用 plugin 来解决。如：代码分割、代码压缩<br>plugin 在整个项目编译周期都起作用</p><h2 id="4-plugin-的组成部分"><a href="#4-plugin-的组成部分" class="headerlink" title="4.plugin 的组成部分"></a>4.plugin 的组成部分</h2><ul><li>plugin 本质是一个 node 模块，这个模块到处一个 js 类</li><li>它的原型需要定义一个 apply 方法</li><li>通过 compiler 来获取 webpack 内部钩子，获取打包阶段的各个流程。webpack 的内部钩子 分为 异步 构字 和同步构子，异步钩子需要执行对应回调</li><li>通过 compilation 操作 webpack 内部实例特定的数据</li></ul><h1 id="webpack-和-gulp-的不同"><a href="#webpack-和-gulp-的不同" class="headerlink" title="webpack 和 gulp 的不同"></a>webpack 和 gulp 的不同</h1><ul><li><p>webpack 基于入口，会自动解析入口所需加载的所有资源文件，用不同的loader 来处理不同的文件</p></li><li><p>gulp 是基于任务和流的，找到一个文件模块 对其做一系列的链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web 的构建流程</p></li><li><p>gulp 需要将整个构建 拆成多个 task 并合理控制所有的 task 的调用关系</p></li><li><p>webpack 只需找到入口，并且清楚对不同资源应用什么 loader 进行加工处理</p></li><li><p>gulp 常见 api: gulp.src, gulp.dest, gulp.pipe, gulp.watch 等</p></li></ul><h1 id="npm、yarn、pnpm"><a href="#npm、yarn、pnpm" class="headerlink" title="npm、yarn、pnpm"></a>npm、yarn、pnpm</h1><h2 id="1-npm-3-0之前"><a href="#1-npm-3-0之前" class="headerlink" title="1. npm 3.0之前"></a>1. npm 3.0之前</h2><p>在 npm 3.0 之前，安装项目的 node_modules 包，会出现嵌套结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">  ｜--- foo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br><span class="line">  ｜--- zoo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br></pre></td></tr></table></figure><p>这种嵌套结构会出现 2 个问题</p><ol><li>层级嵌套太深，导致文件路径过长</li><li>重复安装包，导致项目体积变大</li></ol><p>为了解决这些问题，于是 yarn 横空出世</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn采用 扁平化依赖项来解决 npm 的问题</p><p>扁平化依赖项就是将所有依赖铺平，放在同一级的依赖目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    |-- foo</span><br><span class="line">        |-- index</span><br><span class="line">    |-- bar</span><br><span class="line">        |-- index</span><br><span class="line">    |-- zoo</span><br><span class="line">        |-- index</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这种层级依赖的管理下， node_modules 中不会有层级深的情况，并且在安装依赖时，会先查找当前 node_modules 中是否有这个包，所有也解决了重复安装包 体积变大的问题。<br>解决了 npm 3.0 之前的问题，后续npm 也延用了 yarn 的方案。</p><p>但同时引进了新的问题 – 幽灵依赖 </p><h2 id="幽灵依赖依赖"><a href="#幽灵依赖依赖" class="headerlink" title="幽灵依赖依赖"></a>幽灵依赖依赖</h2><p>幽灵依赖指的是：当前项目中的package.json 并没有该依赖，在代码中确可以引用。<br>这个原因是因为 npm 包被铺平了，依赖中的依赖也被安装了，所以在当前项目 package.json  没有声明该依赖也可以引用。</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>pnpm 中解决了幽灵依赖的问题。<br>使用 pnpm 管理项目依赖，pnpm 不允许安装 package.json 中没有声明的依赖。</p><p>同时 pnpm 还做了另一个优化，使用 软链接和硬链接 来管理依赖，减少了磁盘空间。</p><h2 id="什么是软链接"><a href="#什么是软链接" class="headerlink" title="什么是软链接"></a>什么是软链接</h2><p>软链接： 相当于一个符号链接，指向目标文件地址，类似 window 电脑的快捷方式。<br>修改软链接，不会影响到目标文件</p><h2 id="什么是硬链接"><a href="#什么是硬链接" class="headerlink" title="什么是硬链接"></a>什么是硬链接</h2><p>硬链接：链接符号存储了引用地址，类似 js 中的对象引用。<br>修改硬链接的内容，引用的目标文件会受到影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"></span><br><span class="line">b.<span class="property">age</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="pnpm-原理"><a href="#pnpm-原理" class="headerlink" title="pnpm 原理"></a>pnpm 原理</h2><p>根据软硬链接实现的<br>使用 pnpm 安装依赖时，在 node_modules 中会出现一个.pnpm 的文件和其他依赖文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">|-- .<span class="property">pnpm</span>/</span><br><span class="line">|-- element/</span><br><span class="line">|-- and</span><br></pre></td></tr></table></figure><p>此时，依赖文件 如 element 中实际是一个软链接，指向了 .pnpm 中的 element<br>即 真实路径是 .pnpm/element.3.2.1/node_modules/element<br><code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules&lt;/name&gt;</code></p><p>在由 pnpm/<name>@<version>/node_modules</name> 硬链接到 .pnpm/store 中去</p><p>所以 pnpm 通过这种方式 不仅解决了幽灵依赖的问题，还减少了磁盘空间，下载速度快。</p><h1 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h1><p>CSS 预处理器本质是为 CSS 增加一些可编程的特性，使 CSS 更加强大。</p><ol><li><p>postcss<br> 提供了可以用 JS 代码来处理 CSS，负责把 CSS 代码解析成 AST，再由插件对 AST 进行处理，插件可以实现多样化，如：支持变量和混入，增加浏览器前缀等</p><p> postcss 的作用</p><ul><li>将 css 解析为 JS 可操作的 AST</li><li>调用差距处理 AST 并等到结果</li></ul></li></ol><p>postcss 一般配合 构建工具使用<br>常用的有：<br>    auto prefixer<br>    postcss-px-to-viewport<br>    cassnano 压缩css 等</p><ol start="2"><li><p>sass 在完全兼容 css 的前提下，提供变量、嵌套、混合 自定义函数等编程能力，less 同理</p></li><li><p>sass 和 less 的区别</p><ul><li>sass 和 less 在语法上有些共性，如：嵌套规则、运算、作用域等</li><li>主要的不同在于它们的实现方式<br>less 基于 js， sass 基于 ruby<br>变量的区别： less 用 @， sass 用 $<br>sass 支持条件语句 if{} else{} for{}，less 不支持</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js&lt;/</summary>
      
    
    
    
    
    <category term="Webpack" scheme="https://monthlygirl.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-CSS.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-CSS.html</id>
    <published>2023-12-22T10:09:53.000Z</published>
    <updated>2023-12-22T10:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Css-的优先级"><a href="#Css-的优先级" class="headerlink" title="Css 的优先级"></a>Css 的优先级</h1><p>important &gt; 内联样式 &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器</p><h1 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别"></a>页面导入样式时，使用 link 和 @import 有什么区别</h1><ol><li><p>link 属于 XHTML 标签，除了加载 CSS 外 还能用于定义 rel 等属性； @import 是提供给 css 的，只能用于加载 css</p></li><li><p>页面被加载时 link 会同时被加载，而 import 引用的 css 会等到页面加载完后在加载</p></li><li><p>import 有兼容性问题，只有在 IE5以上才能被识别，link 是 XHTML 标签，没有兼容性问题</p></li><li><p>link 支持使用 js 控制 DOM 去改变样式，import 不支持</p></li></ol><h1 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h1><p>css 盒模型 分为 IE 盒模型(border-box) + W3C 盒模型(content-box)<br>盒模型包括：content + padding + border + margin<br>IE 盒模型 和 W3C 盒模型的区别是 IE 盒模型的 content 包含 padding + border</p><h1 id="CSS-选择器有哪些？-哪些属性可以继承"><a href="#CSS-选择器有哪些？-哪些属性可以继承" class="headerlink" title="CSS 选择器有哪些？ 哪些属性可以继承"></a>CSS 选择器有哪些？ 哪些属性可以继承</h1><ol><li>id 选择器</li><li>class 选择器</li><li>标签选择器</li><li>相邻选择器</li><li>子代选择器</li><li>属性选择器</li><li>通配符选择器</li><li>伪类选择器</li></ol><p>可继承属性：font-size,font-family, color 等<br>不可继承：border、padding、margin、width、height 等</p><h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p>区别：<br>    1. 伪类本质上是为了祢补常规css 选择器不足<br>    2. 伪元素的本质是创建了一个有内容的虚拟元素<br>    3. css3 中 伪类和伪元素的写法不同</p><p>伪类有： :active, :hover, :checked :nth-child 等<br>伪元素： ::after、::before、::first-letter 等</p><h1 id="css-的-content-属性的作用"><a href="#css-的-content-属性的作用" class="headerlink" title="css 的 content 属性的作用"></a>css 的 content 属性的作用</h1><p>css 的 content 属性 专门应用在 before / after 上，用来插入生成内容</p><h1 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h1><p>BFC 指的是 块级格式化的上下文，一个元素形成了BFC 后，那么它的内部元素变化不会影响到外部元素，同样外部元素变化也不会影响到内部元素。<br>一个 BFC 就像是一个隔离区域，和其他区域互不影响。<br>一般来说，一个根元素就是一个 BFC，浮动和绝对定位也会形成 BFC， display 属性为 inline-block、flex 时也会创建 BFC 。overflow 的值不为 visible 时也会创建 BFC</p><h1 id="什么是-IFC"><a href="#什么是-IFC" class="headerlink" title="什么是 IFC"></a>什么是 IFC</h1><p>IFC 指的是 行级格式化上下文，它有着一些布局规则：</p><ol><li>行级上下文内部的盒子会在水平方向一个一个的方知</li><li>当一行不够时，会自动切换下一行</li><li>行级上下文的高度有内部高度最高的内联盒子决定。</li></ol><h1 id="什么是浮动、高度塌陷？如何清除浮动"><a href="#什么是浮动、高度塌陷？如何清除浮动" class="headerlink" title="什么是浮动、高度塌陷？如何清除浮动"></a>什么是浮动、高度塌陷？如何清除浮动</h1><p>在文档流中，父元素的高度默认是由子元素撑开的<br>也就是子元素多高，父元素就多高<br>但是当为 子元素设置浮动后 float ，子元素会脱离文档流<br>此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷</p><p>父元素高度塌陷，父元素下的所有元素都会向上移动。</p><p>通过清除浮动、设定父元素高度可以解决此问题，但我们一般不推荐写死父元素的高度来解决。</p><p>清除浮动的方式：</p><ol><li>使用 clear 来清除浮动</li></ol><p>clear 一般配合伪元素来一起使用</p><p>.div::before {<br>    content: ‘’;<br>    display: block;<br>    clear: both;<br>}</p><ol start="2"><li><p>使用 BFC 来清除浮动（BFC 中可以使用影响最小的 overflow: hidden 来清除浮动）</p></li><li><p>BFC 有兼容性问题，对于I E也可以使用 zoom: 1 来清除浮动<br>zoom 属性是 IE 浏览器专有属性，它可以设置或检索对象的缩放比例，解决 ie 下比较奇葩的bug。触发ie 的haslayout 属性</p></li></ol><p>原理是所设置的元素会被扩大和缩小，高度和宽度会重新计算，触发重新渲染。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Css-的优先级&quot;&gt;&lt;a href=&quot;#Css-的优先级&quot; class=&quot;headerlink&quot; title=&quot;Css 的优先级&quot;&gt;&lt;/a&gt;Css 的优先级&lt;/h1&gt;&lt;p&gt;important &amp;gt; 内联样式 &amp;gt; id 选择器 &amp;gt; class 选择器</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://monthlygirl.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://monthlygirl.github.io/2023/12/Interview-Vue.html"/>
    <id>https://monthlygirl.github.io/2023/12/Interview-Vue.html</id>
    <published>2023-12-22T10:09:53.000Z</published>
    <updated>2023-12-22T10:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-router-的实现"><a href="#vue-router-的实现" class="headerlink" title="vue-router 的实现"></a>vue-router 的实现</h1><p>vue-router 的作用：通过改变 URL，在不重新请求页面的情况下 更新视图</p><p>vue-router 的两种模式</p><p>一、hash 模式</p><p>vue hash 模式路由，在 URL 上带有 # 号，hash 路由 通过 改变 # 号后面的路由来更新视图。# 号后面的URL 改变 不会触发浏览器重新发起请求。</p><p>hash 模式的原理是根据 onhashchange 来监听 URL 变化，通过 window.location.hash 来获取当前 url 值</p><p>二、history 模式 （基于 HTML5 history API）</p><p>history 模式 url 上不会带有 # 号，通过 pushState 、replaceState 、popState实现跳转页面且不重新发送请求。</p><p>使用 pushState 跳转 url 不会向服务器发起新的文档请求，并且它只能实现当前域的跳转，并且会添加一条访问记录<br>popState 可以监听当前url 是否改变，history.back, history.forward,history.go 都会触发 popState</p><p>history.pushState 和 history.replaceState 不会触发 popState 事件</p><p>使用 history 路由 虽然也可以实现像 hash 路由那样实现跳转 url 不重新发起文档请求，但用户在刷新页面时还是会重新发起请求，为了避免这种情况，所以需要服务端配合重定向返回 html。</p><p>三、浏览器的 history.pushState 和 框架中的 history.pushState 的区别</p><p>路由框架的pushState与history.pushState是不一样的，路由框架的pushState不仅调用了history.pushState改变了url，更重要的是它还多了一步操作，即根据这个url销毁了旧组件，渲染了新组件；至于state里面的key值，则是为了兼容hashHistory。</p><h1 id="Vuex-的底层实现"><a href="#Vuex-的底层实现" class="headerlink" title="Vuex 的底层实现"></a>Vuex 的底层实现</h1><p>一、vuex 的核心流程<br>    vue component 接受交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getter 获取到 state 新值，重新渲染 vue component</p><p>二、vuex 的底层原理</p><ul><li>state: 提供一个响应式数据，通过 new vue 实现<pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this._vm = new Vue(&#123;</span><br><span class="line">    $state: state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>getter: 借助 vue 的计算属性 computed 来实现缓存</li><li>mutation： 更改 state，通过 commit 修改 state，是唯一修改state 的地方，并且是同步的</li><li>action: 触发 mutation 方法， action 可以包含些异步操作</li><li>module： Vue.set 动态 添加 state 到响应式数据中去。实际是根据 store 配置递归建立相应的 module 和 module间的父子关系，在根据 namespace 来分割模块，使得 commit/dispatch 时需要制定 namespace</li></ul><h1 id="Vue-provide-和-inject"><a href="#Vue-provide-和-inject" class="headerlink" title="Vue provide 和 inject"></a>Vue provide 和 inject</h1><p>provide、inject 是 vue 组件通信的一种方式，允许祖先组件向其所有的子孙后代 注入一个依赖，不论组件层次有多深</p><p>原理</p><ul><li>依赖注入，其核心原理就是通过 $parent 向上查找祖先组件的 provide，找到则赋值给 inject ，未找到给其 default 值。依赖注入原理和 javascript 中 instanceof 操作符原理类型，instance of 中，通过 <strong>proto</strong> 向原型链中查找，如果 __proto__和 构造函数的 prototype 相等 则返回true</li></ul><p>provide 和 inject </p><ul><li>provide、inject 的初始化阶段是在 beforeCreate 和 Create 之间，所以日常开发中 可以在 Create 中访问到 </li><li>各类型初始化阶段：<br>  initInject: 首先初始化 inject 的注入内容<br>  initState: 初始化 Vue 各项资源，data、props、methods、computed、watch 等<br>  initProvide: 初始化 provide </li><li>所以在 data、props 中 可以访问到 inject，在 provide 中 可以访问到data、props 等其自身的方法和属性</li><li>provide 中可以提供自身的方法和属性给后代组件，并且是具有响应式的，但如果注入的是一个 普通对象 那么就不具备响应式。</li></ul><h1 id="Vue-EventBus"><a href="#Vue-EventBus" class="headerlink" title="Vue EventBus"></a>Vue EventBus</h1><p>用于兄弟组件之间进行通信，是组件传递消息的一种方式</p><p>EventBus 原理：<br>    实际上就是发布-订阅者模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">event</span>[name]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">event</span>[name] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span>[name].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">name, args</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">event</span>[name] &amp;&amp; <span class="variable language_">this</span>.<span class="property">event</span>[name].<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(...args)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vite-原理"><a href="#vite-原理" class="headerlink" title="vite 原理"></a>vite 原理</h1><p>vite 新一代前端构建工具，基于现在浏览器都已普遍支持 ESM 这一特性实现构建。</p><p>vite 在编译项目时，会将项目 分为 依赖 + 源码 两个部分</p><p>依赖：指的是一些第三方库。这些第三方库会使用不同的模块化， 所以 vite 会将这些依赖统一转换处理成 ESM</p><ul><li>vite 通过 ESBuild 来对这些依赖进行处理，我们将这个过程称为 依赖预购建。</li><li>依赖预构建： <ol><li>将依赖中不同模块转换成 ESM。 </li><li>性能：为了提高性能，vite 会将多个 ESM 模块 合并成 一个，减少请求数。</li><li>缓存：vite 会为预构建的请求进行强缓存，并将预构建的依赖项缓存在 node_modules/.vite 中，它会根据package.json、NODE_ENV等文件是否变更来决定是否重新构建依赖。</li></ol></li></ul><p>源码： 指的是项目中的代码，包括 JS 文件和需要转换的文件，如.vue 文件</p><!-- vite 以 ESM 提供源码，实际上就是浏览器接管了打包的工作，vite 只在浏览器需要源码时对源码进行转换成 JS 代码，根据情景导入，实现动态加载。 --><p>Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理</p><!-- 源码会通过 304 进行协商缓存。 --><p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><p>vite 的热更新：基于 ESM 能力，实现 import.meta.host </p><h1 id="为什么-vite-开发环境使用-ESBuild-生产环境仍需要-Rollup"><a href="#为什么-vite-开发环境使用-ESBuild-生产环境仍需要-Rollup" class="headerlink" title="为什么 vite 开发环境使用 ESBuild, 生产环境仍需要 Rollup"></a>为什么 vite 开发环境使用 ESBuild, 生产环境仍需要 Rollup</h1><p>“尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）”<br>“Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容。尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。”</p><p>vite 作者尤雨溪在 vite 官网上解释过这个问题，大致意思是： ESBuild 还是处于开发阶段，对于代码分割、TreeSharking 方面还不太完善。所以在生产环境为了用户体验、网站性能方面考虑，仍需要对项目进行打包。而 RollUp 和 webpack 一样是个成熟的构建工具，rollup 会更灵活。未来，esbuild 可能会成为主流构建。</p><p>rollup 有以下几个优点：<br>    css 代码分割，如果某个异步模块引入了一些 css 代码，vite 会自动将这些 css 抽取出来 生成单独的文件，提高线上产物的缓存复用率</p><pre><code>自动预加载，vite 会自动为入口 chunk 的依赖自动生成 预加载标签 &lt;link rel=&quot;modulePreload&quot; &gt; 这种适当的预加载会让浏览器提前下载好资源，优化页面性能。</code></pre><h1 id="vite-和-webpack-对比"><a href="#vite-和-webpack-对比" class="headerlink" title="vite 和 webpack 对比"></a>vite 和 webpack 对比</h1><ol><li><p>vite 中分为 2 个模块：依赖和源码；<br>webpack 中一切皆模块，不管是依赖还是源码都需要进行处理。</p></li><li><p>vite 是基于浏览器已经普通支持 ESM 语法这一特性，所以在构建本地服务时，不需要打包<br> webpack 完全没有考虑这一特点，只要是模块都需要用 loader 进行处理</p></li><li><p>vite 在启动时，不考虑编译问题，只考虑模块间的依赖，当浏览器中访问指定页面时，浏览器才开始按需加载当前页面，并会借助浏览器的缓存功能<br> webpack 在构建本地服务时要对所有的模块和依赖进行编译，无论当前页面是否被加载，webpack 的特点是先编译在运行，所以项目越大 运行速度越慢</p></li><li><p>vite 支持 TS，只负责把 TS 代码进行转换，对于 TS 类型校验的事交给了 IDE 去做<br> webpack 在构建 TS 项目时，需要安装 typescript 运行， TSC会对 TS 代码进行校验和编译，所以慢</p></li><li><p>vite 在 HMR 热更新时 也不进行编译，基于 ESM import.meta 实现 hot 属性<br> webpack 在热更新时会重新编译，所以也很慢。</p></li></ol><h1 id="Tree-Sharking-原理"><a href="#Tree-Sharking-原理" class="headerlink" title="Tree-Sharking 原理"></a>Tree-Sharking 原理</h1><p>ESM 引入进行静态分析，编译时会判断引入了哪些模块，判断哪些模块的变量未被使用，从而删除对应的代码</p><h1 id="babel-怎么做-polyfill"><a href="#babel-怎么做-polyfill" class="headerlink" title="babel 怎么做 polyfill"></a>babel 怎么做 polyfill</h1><p>babel 只做语法转换，将 ES6 转为 ES5，但是如果 在 ES5 中，有些对象方法在实际浏览器中可能不被支持，比如 Promise、array.prototype 等，这时候就需要通过 Babel-polyfill 来解决</p><p>Babel-polyfill 虽然可以通过模拟浏览器解决不存在对象方法的事，但存在2个问题：</p><ol><li>直接修改内置的原型，造成全局污染</li><li>无法按需引入</li></ol><p>所以社区中出现了 Babel-runtime， 不仅解决了 对象方法不被浏览器所支持的问题，也实现按需引入，不再修改内置原型，而是通过替换的方式 来解决。</p><h1 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h1><p>v-if 和 v-show 的作用都是用来控制 DOM 的展示和隐藏，不同的是<br>1、控制手段不同：v-show 是通过 css 来切换，v-if 是新建和删除 DOM 来控制<br>2、编译过程不同：v-show 是基于 css 进行切换，v-if 切换有一个局部的编译/卸载的过程</p><p>v-show 和 v-if， 虽然从表面看 类似，都是控制组件的显示和隐藏。但内部实现差距还是很大的</p><p>v-if 它在切换的过程中，条件块内部的事件监听器和子组件会被适当的重建和整合。满足条件后会触发对应组件的更新。<br>v-if 渲染的节点，由于新旧节点的vnode冲突， 在核心 diff 算法对比过程中，会移除旧节点 创建新节点。那么就会创建新的组件，经历组件自身初始化、渲染 vnode、patch等过程。</p><p>对于 v-show 渲染的节点，在初始化阶段时 它会先生成两个条件的组件，所以在后续的条件渲染中，由于新旧 vnode 一致，它只需 patchVnode 即可，在 patchVNode 的过程中，内部会执行 v-show 指令对应的回调更新，根据 v-show 指令绑定的值来设置它作用的 DOM 元素 style.display 的值</p><p>因此：相比 v-if 不断删除和创建新的DOM，v-show 只在更新现有 DOM 上的显隐值。所以 v-show 的支出比 v-if 小很多。</p><p>v-show 适用于多次切换的场景，v-if 适用于少数切换的场景。</p><p>v-show 相比 v-if 的性能优势时组件在更新阶段，如果在初始化阶段，v-if 性能优于 v-show.<br>因为 v-if 它本身只会渲染一个分支， v-show 把两个分支都渲染了。<br>在使用 v-show 时，所以分支内部组件都会渲染，对应的生命周期钩子函数都会执行，而使用 v-if 时 没有命中的分支内部组件是不会渲染的（包含内部的生命周期函数）</p><h1 id="Vue-事件绑定原理"><a href="#Vue-事件绑定原理" class="headerlink" title="Vue 事件绑定原理"></a>Vue 事件绑定原理</h1><ol><li>vue 通过解析模板的 html 提取 DOM 上的所有属性</li><li>通过正则匹配出事件名和事件处理方法</li><li>根据得到的事件名和事件处理方法，vue 会（调用 gen 回调）生成事件处理函数，这个函数中维护具体的事件名、对应的处理方法和修饰符等信息</li><li>将事件处理函数 通过 调用原生 DOM API addEventListener 注入到虚拟 DOM 中。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-router-的实现&quot;&gt;&lt;a href=&quot;#vue-router-的实现&quot; class=&quot;headerlink&quot; title=&quot;vue-router 的实现&quot;&gt;&lt;/a&gt;vue-router 的实现&lt;/h1&gt;&lt;p&gt;vue-router 的作用：通过改变 UR</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码解析: vue 响应式原理</title>
    <link href="https://monthlygirl.github.io/2023/11/Vue%20defineReactive.html"/>
    <id>https://monthlygirl.github.io/2023/11/Vue%20defineReactive.html</id>
    <published>2023-11-26T14:36:01.000Z</published>
    <updated>2023-11-26T14:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-响应式原理解析"><a href="#Vue-响应式原理解析" class="headerlink" title="Vue 响应式原理解析"></a>Vue 响应式原理解析</h1><p>大家都知道 vue 是双向数据绑定，vue 的双向数据绑定使用的是 <strong>v-model</strong> 实现。<strong>v-model</strong>实际上是 input 的事件 和 value 属性值。其最本质的原理是基于 vue 的响应式原理实现。响应式的实现原理是怎么样的呢？让我们接下来一起看看</p><h2 id="1-数据劫持"><a href="#1-数据劫持" class="headerlink" title="1. 数据劫持"></a>1. 数据劫持</h2><p>源码位置：<code>vue/src/core/observer/index.ts</code><br>在vue 源码有这么一个函数 <strong>defineReactive</strong>，其本质是使用<strong>Object.defineProperty</strong> 方法劫持对象属性，使得在访问和修改属性时能够执行特定的操作</p><ul><li>get: 用于获取属性值，同时进行依赖收集</li><li>set: 设置新值，触发依赖更新。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: object,</span></span><br><span class="line"><span class="params">  key: string,</span></span><br><span class="line"><span class="params">  val?: any,</span></span><br><span class="line"><span class="params">  customSetter?: <span class="built_in">Function</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  mock?: boolean</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建依赖收集</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取属性值描述，如果是只读属性，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="comment">// 预定义 getter/setter</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!getter || setter) &amp;&amp;</span><br><span class="line">    (val === <span class="variable constant_">NO_INITIAL_VALUE</span> || <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val, <span class="literal">false</span>, mock)</span><br><span class="line">  <span class="comment">// 使用 Object.defineProperty 定义响应式属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 方式 用于获取属性值，在获取值的时候进行依赖收集</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否有getter， 有就直接调用 getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;</span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有子响应式对象，依赖收集</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">//如果是数组类型，需要对数组的每一项进行依赖收集</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set 方式 用于设置属性值，同时触发依赖更新</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="comment">// 先使用 getter 获取旧值</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">// 新旧值一致时，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果有 setter 调用 setter 进行更新</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getter) &#123;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shallow &amp;&amp; <span class="title function_">isRef</span>(value) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newVal</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal, <span class="literal">false</span>, mock)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">          <span class="attr">target</span>: obj,</span><br><span class="line">          key,</span><br><span class="line">          <span class="attr">newValue</span>: newVal,</span><br><span class="line">          <span class="attr">oldValue</span>: value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 依赖更新</span></span><br><span class="line">        dep.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 observe函数，递归遍历对象属性，为每个属性创建一个<code>dep</code>实例，通过<strong>Object.defineProperty</strong> 为每个属性设置 getter 和 setter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                dep.<span class="title function_">depend</span>()</span><br><span class="line">                <span class="keyword">return</span> internalValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue !== internalValue) &#123;</span><br><span class="line">                    internalValue = newValue</span><br><span class="line">                    dep.<span class="title function_">notify</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">observe</span>(internalValue)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-依赖追踪"><a href="#2-依赖追踪" class="headerlink" title="2. 依赖追踪"></a>2. 依赖追踪</h2><p>vue 的响应式系统引入了一个重要概念 – 依赖追踪。每个响应式属性都会关联一个 <code>Dep</code>(依赖)对象，它复制收集所有依赖于该属性的观察者(Watcher)。<br><img src= "/img/bgTop.jpg" data-lazy-src="image-2.png" alt="Alt text"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖管理器 Dep</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeWatcher) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeWatcher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">subscribe</span> =&gt;</span> &#123;</span><br><span class="line">            subscribe.<span class="title function_">update</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当属性被访问时，会调用 <code>dep.depend()</code>,将当前的观察者添加到依赖集合中。当属性被修改时，会调用 <code>dep.notify()</code>,通知所有依赖的观察者进行更新。</p><h2 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h2><p>观察者模式是vue 响应式系统的核心。通过创建观察者对象，订阅并响应数据的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">updateFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">updateFn</span> = updateFn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前实例设置活动观察者，执行更新后重置。</span></span><br><span class="line">        activeWatcher = <span class="variable language_">this</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">        activeWatcher = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Vue 采用 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong>的方式来实现数据的响应式，通过<strong>Object.defineProperty</strong> 来劫持数据的 setter 和 getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。</p><p>参考链接：<br><a href="https://tsejx.github.io/vue-guidebook/infrastructure/vue2/reactivity/#%E6%80%BB%E7%BB%93">https://tsejx.github.io/vue-guidebook/infrastructure/vue2/reactivity/#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-响应式原理解析&quot;&gt;&lt;a href=&quot;#Vue-响应式原理解析&quot; class=&quot;headerlink&quot; title=&quot;Vue 响应式原理解析&quot;&gt;&lt;/a&gt;Vue 响应式原理解析&lt;/h1&gt;&lt;p&gt;大家都知道 vue 是双向数据绑定，vue 的双向数据绑定使用的是 </summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term=" vue 响应式原理" scheme="https://monthlygirl.github.io/tags/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码解析：深度理解 initProps 函数</title>
    <link href="https://monthlygirl.github.io/2023/11/Vue%20source.html"/>
    <id>https://monthlygirl.github.io/2023/11/Vue%20source.html</id>
    <published>2023-11-25T07:50:13.000Z</published>
    <updated>2023-11-25T07:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-源码解析：深度理解-initProps-函数"><a href="#Vue-js-源码解析：深度理解-initProps-函数" class="headerlink" title="Vue.js 源码解析：深度理解 initProps 函数"></a>Vue.js 源码解析：深度理解 initProps 函数</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Vue.js 中，initProps 函数是组件初始化过程中的一个重要步骤，它负责处理组件的 props，使其变成响应式，并提供一些警告和检查。本文将深入解析 initProps 函数，探讨其实现原理和关键步骤。本文基于 Vue 源码 version <code>2.7.14</code></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开始之前，我们需要了解一些背景知识：</p><ul><li>Vue 组件的 props 是用于接收父组件传递的数据机制。</li><li>props 同样具有响应式，响应式系统是 Vue 的核心特性之一，它能用追踪数据的变化并实现视图的自动更新。</li></ul><h2 id="initProps-函数"><a href="#initProps-函数" class="headerlink" title="initProps 函数"></a>initProps 函数</h2><p>源码位置：<code>vue/src/core/instance/state.ts</code></p><h3 id="1-initProps-函数的作用"><a href="#1-initProps-函数的作用" class="headerlink" title="1. initProps 函数的作用"></a>1. <code>initProps</code> 函数的作用</h3><p><code>initProps</code> 主要用于处理组件的‘props’, 使其成为具有响应式数据，函数的核心功能：</p><ul><li><strong>获取props 数据</strong>： 从 <strong>vm.$options.propsData</strong> 获取 props 数据</li><li> <strong>创建响应式数据</strong>： 使用  <strong>shallowReactive</strong>创建一个浅层的响应式对象，并赋值给  <strong>vm._props</strong></li><li><strong>切换响应式观察状态</strong>： 判断当前组件是否是根节点，如果是根节点，则不会再用props 传进来，此时不需要启用响应式观察。</li><li> <strong>遍历处理 props</strong>： 循环遍历 propsOptions，验证prop 并将其设为响应式。</li><li> <strong>告警</strong>： 在开发环境，做校验告警，如：将保留字属性作为 props 时 发出告警。</li><li> <strong>代理到组件</strong>： 将 prop 代理到组件中，确保可以通过 this.propName 直接访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span>(<span class="params">vm: Component, propsOptions: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取 propsData</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;</span><br><span class="line">  <span class="comment">// 创建响应式对象 shallowReactive V3 方法</span></span><br><span class="line">  <span class="keyword">const</span> props = (vm.<span class="property">_props</span> = <span class="title function_">shallowReactive</span>(&#123;&#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存keys ，以便将来的key更新可以使用Array 而不是动态对象键枚举进行迭代。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">keys</span>: string[] = (vm.<span class="property">$options</span>.<span class="property">_propKeys</span> = [])</span><br><span class="line">  <span class="comment">// 是否是根组件，不是根组件的话不会有props 传入 不需要响应式</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.<span class="property">$parent</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    <span class="comment">// 切换响应式状态</span></span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 循环 props 选项</span></span><br><span class="line">    keys.<span class="title function_">push</span>(key)</span><br><span class="line">    <span class="comment">// 校验 props 并获取 props 值</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="comment">// 开发环境下的校验告警</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = <span class="title function_">hyphenate</span>(key)</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="title function_">isReservedAttribute</span>(hyphenatedKey) ||</span><br><span class="line">        config.<span class="title function_">isReservedAttr</span>(hyphenatedKey)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`&quot;<span class="subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">              <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">              <span class="string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +</span><br><span class="line">              <span class="string">`value. Prop being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个响应式的 props</span></span><br><span class="line">      <span class="title function_">defineReactive</span>(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前key 不在组件的原型上</span></span><br><span class="line">    <span class="comment">// 代理到组件中，确保能够访问 props</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toggleObserving</span>(<span class="literal">true</span>) <span class="comment">//不是根组件 启用响应式观察</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出 initProps 中主要的函数 为 <strong>shallowReactive</strong>、<strong>defineReactive</strong>，接下来一一解析。</p><h3 id="2-shallowReactive-函数"><a href="#2-shallowReactive-函数" class="headerlink" title="2. shallowReactive 函数"></a>2. shallowReactive 函数</h3><p><strong>initProps</strong> 函数中使用了 <strong>shallowReactive</strong> 来创建浅层响应式对象，这个函数的作用是创建一个具有响应性的对象，但是只会对对象的第一层属性进行相应，而不会递归处理嵌套对象。那为什么 initProps 中只需对第一层属性进行响应呢？来我们继续看下去</p><h4 id="为什么-initProps-只对第一层属性进行响应？"><a href="#为什么-initProps-只对第一层属性进行响应？" class="headerlink" title="为什么 initProps 只对第一层属性进行响应？"></a>为什么 initProps 只对第一层属性进行响应？</h4><p>首先 <strong>initProps</strong> 函数并不是用来专门创建响应式对象的，而是用来初始化实例的 <strong>props</strong> 属性。在 Vue 中， <strong>props</strong> 是父组件传给子组件的属性，这些属性的响应式应该由父组件来保证的。</p><p> <strong>shallowReactive</strong> 来创建浅层响应式对象，而不会递归地将嵌套对象的属性变成响应式。</p><p><strong>defineReactive</strong> 函数，该函数的作用是将一个对象的属性变成响应式。然而，这里的目标并不是为了递归地将嵌套在 props 中的对象的属性都变成响应式，而是为了确保每个 props 中的属性都能够在组件实例中被访问。</p><p>因此，initProps 只关注 props 的第一层属性，而不会深入到嵌套的对象中去创建响应式。这是因为深层次的嵌套属性通常由父组件来管理和控制，子组件只需要访问这些属性而不需要在自身内部将它们变成响应式。 Vue.js 的设计哲学是在组件之间通过 props 进行数据传递，而不是在组件内部对传递的数据进行深度的响应式处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> shallowReactive&lt;T <span class="keyword">extends</span> object&gt;(</span><br><span class="line">  <span class="attr">target</span>: T</span><br><span class="line">): <span class="title class_">ShallowReactive</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 调用 makeReactive 函数，传入目标对象和 true（表示浅层响应式）</span></span><br><span class="line">  <span class="title function_">makeReactive</span>(target, <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 在目标对象上定义一个 IS_SHALLOW 标志为 true，表示该对象为浅层响应式</span></span><br><span class="line">  <span class="title function_">def</span>(target, <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeReactive</span>(<span class="params">target: any, shallow: boolean</span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isReadonly</span>(target)) &#123;  <span class="comment">// 检查目标对象是否为只读代理，如果是，直接返回只读版本</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 如果目标对象是数组，发出警告，因为 Vue 2 不支持在 watch 或 watchEffect 中跟踪数组的变化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Avoid using Array as root value for <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">`shallowReactive()`</span> : <span class="string">`reactive()`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span> as it cannot be tracked in watch() or watchEffect(). Use <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">`shallowRef()`</span> : <span class="string">`ref()`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span> instead. This is a Vue-2-only limitation.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> existingOb = target &amp;&amp; target.<span class="property">__ob__</span> <span class="comment">// 检查目标对象是否已经有响应式对象</span></span><br><span class="line">      <span class="keyword">if</span> (existingOb &amp;&amp; existingOb.<span class="property">shallow</span> !== shallow) &#123; <span class="comment">// 如果目标对象已经有响应式对象，检查它是否和 shallow 参数相同</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Target is already a <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            existingOb.shallow ? <span class="string">``</span> : <span class="string">`non-`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span>shallow reactive object, and cannot be converted to <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            shallow ? <span class="string">``</span> : <span class="string">`non-`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span>shallow.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 调用 observe 函数创建响应式对象</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="title function_">observe</span>(</span><br><span class="line">      target,</span><br><span class="line">      shallow,</span><br><span class="line">      <span class="title function_">isServerRendering</span>() <span class="comment">/* ssr mock reactivity */</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !ob) &#123;</span><br><span class="line">      <span class="comment">// 在开发环境下，如果创建响应式对象失败，发出相应的警告</span></span><br><span class="line">      <span class="keyword">if</span> (target == <span class="literal">null</span> || <span class="title function_">isPrimitive</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isCollectionType</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 如果目标对象是集合类型（如 Map 或 Set），发出警告，因为 Vue 2 不支持响应式集合类型</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Vue 2 does not support reactive collection types such as Map or Set.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-defineReactive"><a href="#3-defineReactive" class="headerlink" title="3. defineReactive"></a>3. defineReactive</h2><p><strong>defineReactive</strong> 函数是 Vue 响应式系统的核心之一，用于定义对象的属性，并在属性的 getter 和 setter 中实现对属性值的观察。接下来将出另篇文章解读传送门</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-js-源码解析：深度理解-initProps-函数&quot;&gt;&lt;a href=&quot;#Vue-js-源码解析：深度理解-initProps-函数&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 源码解析：深度理解 initProps 函数&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="initProps" scheme="https://monthlygirl.github.io/tags/initProps/"/>
    
  </entry>
  
  <entry>
    <title>http history</title>
    <link href="https://monthlygirl.github.io/2023/07/Interview-JS.html"/>
    <id>https://monthlygirl.github.io/2023/07/Interview-JS.html</id>
    <published>2023-07-17T08:12:11.000Z</published>
    <updated>2023-07-17T08:12:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h1><p>Http1.0 是最早的版本，它使用短链接，每次请求都需等待服务器响应后关闭连接。<br>它最早被使用在1996年的网页，开始人们只使用一些简单的 web 页和网络请求上，在1999年时广泛使用Http1.1</p><p>Http1.0 的缺点：</p><ul><li>短链接：http1.0 使用的是短链接方式，每个请求都必须建立连接和断开连接，每个连接都需要经过 TCP 连接过程（三次握手四次挥手的过程）</li><li>不支持复用header头，每次请求都需要发送完整的请求头信息</li><li>不支持对数据进行二进制分帧传输（？）</li><li>通过 expires 头来表示资源的过期时间，缺点 如果服务器和客户端的时间不一致，缓存可能会出现问题。</li><li>http1.1 没有提供对缓存的有效性验证，每次都需要重新下载整个资源，没有办法优化带宽利用。</li><li>不支持加密，所有数据传输都是明文传输，存在安全风险，需要额外使用安全协议（https 来对 http进行数据加密和身份校验）</li></ul><h1 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h1><p>在Http1.0 每次连接都需要建立完成的 TCP 连接，所以在 1999年时开始广泛使用Http1.1。<br>它们的主要区别在：</p><ul><li>针对http1.0的短链接，http1.1 引入 keep-alive 支持长连接，允许在单个连接上建立多次请求和相应</li><li>http1.1 引入了更复杂的缓存机制，使用了更多的缓存控制头，如：Cache-Control 头、ETag 和 Last-Modified 头</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP1-0&quot;&gt;&lt;a href=&quot;#HTTP1-0&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.0&quot;&gt;&lt;/a&gt;HTTP1.0&lt;/h1&gt;&lt;p&gt;Http1.0 是最早的版本，它使用短链接，每次请求都需等待服务器响应后关闭连接。&lt;br&gt;它最早被使</summary>
      
    
    
    
    
    <category term="HTTP、多路复用、长链接" scheme="https://monthlygirl.github.io/tags/HTTP%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E3%80%81%E9%95%BF%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》学习日志</title>
    <link href="https://monthlygirl.github.io/2021/06/code.html"/>
    <id>https://monthlygirl.github.io/2021/06/code.html</id>
    <published>2021-06-16T13:19:49.000Z</published>
    <updated>2021-06-16T13:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p><code>变量名应该是名词，能够正确地描述业务，有表达力。如果一个变量名需要用注释来补充说明，那很有可能说明命名有问题</code>。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p><code>函数名要具体，它体现的是做什么，而不是怎么做。</code></p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p><code>类名是一组数据和操作的封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。</code><br>实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如Customer,Employee等等；辅助类是辅佐实体类一起完成业务逻辑得，其命名要能够通过后缀来体现功能，例如，用来为Customer 做控制路由的控制类CustomerController，对于辅助类，尽量不要用Helper,Util之类的后缀，因为其含义太过笼统。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p><code>包代表了一组有关系的类的集合，起到了分类组合和命名空间的作用，包名应该能够反映一组类在更高抽象层次上的联系，例如Apple、Pear，我们可以将它们放在一个包中，命名为fruit。包的命名要适合，不能太抽象也不能太具体。如Apple，那么将Pear、Orange放进包中就不适合了；如果太抽象，称为Object，Object无所不包，这便失去了用包来限定范围的作用。</code></p><h2 id="模块名"><a href="#模块名" class="headerlink" title="模块名"></a>模块名</h2><p><code>相对于包来说，模块的粒度更大，通常一个模块包含了多个包，模块命名要有唯一性，另外名称要反映模块在系统中的职能</code></p><h2 id="命名保持一致性"><a href="#命名保持一致性" class="headerlink" title="命名保持一致性"></a>命名保持一致性</h2><p>保持命名的一致性，可以提高代码的可读性，每个概念对应一个词。在项目，通常约定方法名，如：crud操作中 create 新增，add 添加，remove 删除。<br>使用对仗词，遵守对仗词的命名规则有助于保持一致性，从而提高代码的可读性。像first/last这样的对仗词就很容易理解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>像Brian W.Kernighan 说的那样：“别给糟糕的代码加注释—重新写吧。”<br>注释，不要复述功能，注释要能够解释代码背后的意图，而不是对功能的简单重复，真正的高手是尽量不写注释。</p><p><strong>很多人（包括我在没阅读这边书之前）觉得命名规范只是细节，但命名其实很难。书中在这一章开头就引用了两个名人的谚语，言简意赅的表达了命名的重要性。<code>就像Stack OverFlow的创始人Joel Spolsky说的：“起一个好名字应该很难，因为好名字需要把要以浓缩在一到两词中”，Martin Fowler也表示过“在计算机科学中有两件难事：缓存失效和命名”</code>；所以好的命名可以保证代码不仅是被机器执行的指令，更是人和人之间沟通的桥梁。也像channing哥说的，好的代码看着，不是在看代码，而是像看一本书</strong></p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ol><li>代码格式，代码格式关系到代码的可读性，因此需要遵从一定的规范，包括缩进、水平对齐、注释格式等</li><li>命名规范，每种语言都有自己独特的命名风格，javascript是弱类型语言，会使用匈牙利命名法的习惯（这个还第一次见）</li><li>异常规范，要统一处理异常，异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码，这种不一致性通常会让人摸不着头脑，增加了服务的使用成本和沟通成本</li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数数量"><a href="#参数数量" class="headerlink" title="参数数量"></a>参数数量</h2><p>最理想的参数数量是零（零参函数），其次是一（一元函数），再次是二（二元函数），应尽量避免三（三元函数）<br>如果函数需要3个以上参数，就说明其中一些参数应该封装为类了。</p><h2 id="短小函数"><a href="#短小函数" class="headerlink" title="短小函数"></a>短小函数</h2><p>函数的第一规则是要短小，第二规则是要更短小。有时保持代码的逻辑不变，只是把长方法改成多个短方法，代码的可读性就能提高很多。超长方法是典型代码的“坏味道”，对超长方法的结构化分解是提升代码可读性最有效的方式之一。</p><h2 id="职责单一"><a href="#职责单一" class="headerlink" title="职责单一"></a>职责单一</h2><p>一个方法只做一件事情（华哥跟我说了好多次，拆分函数，哪怕只有一句话，只要有助于语义显性化的表达，也是值得的），也就是函数级别的单一职责原则（SRP），遵循SRP不仅可以提升代码的可读性，还行提升代码的可复用性。因为职责越单一，功能越内聚，</p><h2 id="精简辅助代码"><a href="#精简辅助代码" class="headerlink" title="精简辅助代码"></a>精简辅助代码</h2><p>辅助代码，它不是处理业务逻辑的核心代码，但如判空、打印日志、缓存检查等等，这些代码往往会在多个函数中重复冗余，如果辅助代码太多，会极大地干扰代码的可读性。因此我们应该尽量减少辅助代码对业务代码的干扰。让函数中的代码能直观第体现业务逻辑，而不是让业务代码淹没在辅助代码中。</p><h2 id="组合函数模式"><a href="#组合函数模式" class="headerlink" title="组合函数模式"></a>组合函数模式</h2><p>组合函数要求所有的公有函数读起来像一系列执行步骤的概要，而这些步骤的真正实现细节是在私有函数里面。组合函数有助于代码保持精炼并易于复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。&lt;/p&gt;
&lt;h1 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="学习指南" scheme="https://monthlygirl.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>vue3.0</title>
    <link href="https://monthlygirl.github.io/2021/04/vue3.0.html"/>
    <id>https://monthlygirl.github.io/2021/04/vue3.0.html</id>
    <published>2021-04-01T13:59:31.000Z</published>
    <updated>2021-04-01T13:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-0的新特性及Vue3-0带来的新变化"><a href="#Vue3-0的新特性及Vue3-0带来的新变化" class="headerlink" title="Vue3.0的新特性及Vue3.0带来的新变化"></a>Vue3.0的新特性及Vue3.0带来的新变化</h1><p>vue3.0 2020年9月发布,命名为One p</p><h2 id="Vue3-0-带来的新变化"><a href="#Vue3-0-带来的新变化" class="headerlink" title="Vue3.0 带来的新变化"></a>Vue3.0 带来的新变化</h2><ul><li>性能的提升 1.3~2x<br>与vue2.x相比,mount 50%提升,内存占用小120%<br>核心代码+ Composition API:13.5kb,最小11.75kb  可以单独使用<br>所有的runtime:22.5kb(vue2是32kb)</li></ul><h1 id="为什么会有这么大的性能提升"><a href="#为什么会有这么大的性能提升" class="headerlink" title="为什么会有这么大的性能提升?"></a>为什么会有这么大的性能提升?</h1><h2 id="Compiler-原理"><a href="#Compiler-原理" class="headerlink" title="Compiler 原理"></a>Compiler 原理</h2><ol><li>静态的节点和静态绑定的class和id不再作更新处理(hoistStatic-&gt;SSR优化)</li><li>结合打包标记PatchFlag,进行更新分析<br>在编译过程中会将template编译成ast语法树,ast是一个抽象的语法树,动态的内容打上标记,在更新的时候只更新动态的内容</li><li>事件监听器Cache缓存处理(cacheHandlers)</li><li>hoistStatic 自动针对多静态节点进行优化,输出字符串</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-0的新特性及Vue3-0带来的新变化&quot;&gt;&lt;a href=&quot;#Vue3-0的新特性及Vue3-0带来的新变化&quot; class=&quot;headerlink&quot; title=&quot;Vue3.0的新特性及Vue3.0带来的新变化&quot;&gt;&lt;/a&gt;Vue3.0的新特性及Vue3.0</summary>
      
    
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/categories/Vue/"/>
    
    
    <category term="vue3.0 Compiler" scheme="https://monthlygirl.github.io/tags/vue3-0-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的各个版本</title>
    <link href="https://monthlygirl.github.io/2021/03/http-version.html"/>
    <id>https://monthlygirl.github.io/2021/03/http-version.html</id>
    <published>2021-03-01T12:51:53.000Z</published>
    <updated>2021-03-01T12:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>HTTP 是超文本传输协议,它定义了客户端和服务器之间交换报文的格式和方式,默认采用80端口,它使用TCP作为传输层协议,保证了数据传输的可靠性</p><p>HTTP 是一个无状态的协议,HTTP 服务器不会保存关于客户端的任务信息</p><p>HTTP 有两种连接模式,一种是持续连接,一种是非持续连接;<br>非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接;持续连接,TCP 连接默认不关闭,可以被多个请求复用;采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间; </p><p>在HTTP1.0 以前使用的非持续的连接,但是可以在请求时,加上Connection: keep-alive 来要求服务器不要关闭 TCP 连接</p><p>在HTTP1.1以后默认采用的是持续的连接;目前对于同一个域,大多数浏览器支持同时建立 6 个持久连接</p><h1 id="HTTP-协议的各个版本"><a href="#HTTP-协议的各个版本" class="headerlink" title="HTTP 协议的各个版本"></a>HTTP 协议的各个版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议; 它不涉及数据包传输,主要规定了客户端和服务器之间的通信格式,默认使用80端口</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>最早的版本是0.9版本,该版本及其简单,只有一个命令 <code>GET</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / index.<span class="property">html</span></span><br><span class="line"><span class="comment">// TCP 连接建立后,客户端向服务器请求网页 index.html</span></span><br></pre></td></tr></table></figure><p>协议规定,服务器只能回应 HTML 格式的字符串,不能回应别的格式<br>服务器发送完毕,就关闭 TCP 连接</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP1.0 版本发布,内容大大增加</p><ol><li>首先,任何格式内容都可以发送; 可以传输文字 / 图像 / 视频 / 二进制 文件 </li><li>除了 <code>GET</code> 命令,还引入了 <code>POST</code> / <code>HEAD</code> 命令,使传输信息变得更丰富</li><li>HTTP 请求和回应格式也发生改变了,每次通信都必须包含头信息,用来描述一些元数据</li><li>新增状态码 / 缓存 / 内容编码 / 字符编码 /等等</li></ol><h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p>字符编码,1.0版规定,头信息必须是 ASCII 码,后面的数据可以是任何格式;<br>因此服务器回应的时候,必须告诉客户端,数据是什么格式,这就是 <code>Content-type</code> 字段的作用<br>常见的 <code>Content-type</code> 字段的值</p><ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg<br>…</li></ul><h3 id="Content-Encoding-字符"><a href="#Content-Encoding-字符" class="headerlink" title="Content-Encoding 字符"></a>Content-Encoding 字符</h3><p>由于发送的数据可以是任何格式,因此可以把数据压缩后再发送; <code>Content-Encoding</code> 字段说明数据的压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure><p>客户端请求时,用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gizp,deflate</span><br></pre></td></tr></table></figure><h3 id="HTTP-1-0-的缺点"><a href="#HTTP-1-0-的缺点" class="headerlink" title="HTTP/1.0 的缺点"></a>HTTP/1.0 的缺点</h3><p>每次 TCP 连接只能发送一个请求,发送数据完毕,连接就关闭,如果还要请求其他资源,就必须再新建一个连接<br>TCP 连接的新建成本高,所以 HTTP/1.0 版本性能较差<br>为了解决这个问题,有些浏览器在请求时,用了一个非标准的 <code>Connection</code> 字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这个字符要求服务器不要关闭 TCP 连接,以便其他请求复用,服务器同样回应这个字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这样一个可以复用的 TCP 连接就建立了,直到客户端或服务器主动关闭连接,但是,这不是标准字段,不同实现的行为可能不一致,因此不是根本的解决方法</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1版本的发布,它进一步完善了 HTTP 协议</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>1.1版本的最大变化,就是引入了持久连接,即 TCP 连接默认不关闭,可以被多个请求复用,不用声明 <code>Connection:keep-alive</code><br>客户端和服务器发现对方一段时间没有活动,就可以主动关闭连接;不过,规范的做法是,客户端在最后一个请求时,发送 <code>Connection: close</code>,明确要求服务器关闭 TCP 连接,对于同一个域名,大多数浏览器允许同时建立 6 个持久连接</p><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>1.1版本引入了管道机制,即在同一个 TCP 连接里面,客户端可以同时发送多个请求,这样就进一步改进了 HTTP 协议的效率</p><p>举例来说,客户端需要请求两个资源,在1.1版本以前的做法是,在同一个 TCP 连接里面,先发送 A 请求,然后等待服务器做出回应,收到后再发送B请求,管道机制则是允许浏览器同时发送A请求和B请求,但服务器还是按照顺序,先回应A请求,完成后再回应B请求</p><p>另外增加了 <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> 等方法</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然1.1版本允许复用 TCP 连接,但是同一个 TCP 连接里面,所有的数据通信是依次进行的,服务器只有处理完一个回应,才会进行下一个回应,要是前一个回应特别慢,后面就会 有许多请排队等着,这称为 <code>队头阻塞</code><br>为了避免这个问题,只有两种方法: 一是减少请求数, 二是同时打开多个持久连接,这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。 </p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/2 是谷歌自行研发的 SPDY 协议,主要解决 HTTP/1.1 效率不高的问题</p><p>HTTP/2 主要有以下新的特性:</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/2 是一个二进制协议,在 HTTP/1.1 版本中,报文的头信息必须是文本(ASCII编码),数据体可以是文本,也可以是二进制,HTTP/2 则是一个彻底的二进制协议,头信息和数据体都是二进制的,并且统称为 “ 帧 “ ,可以分为头信息帧和数据帧<br>帧的概念是它实现多路复用的基础</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 实现了多路复用,HTTP/2 仍然复用 TCP 连接,但是一个连接里,客户端和服务器都可以同时发送多个请求或回应,而且不用按照顺序一一发送,这样就避免了 “队头阻塞” 的问题</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 使用了数据流的概念,因为HTTP/2 的数据包不是按顺序发送的,同一个连接里面连续的数据包,可能属于不同的请求;因此,必须要对数据包做标记,指出它属于哪个请求;HTTP/2 将每个请求或回应的所有数据包,称为一个数据流;<br>每个数据流都有一个独一无二的编号;数据包发送的时候,都必须标记数据流 ID ,用来区分它属于哪个数据流</p><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP/2 实现了头信息压缩,由于 HTTP 1.1 协议不带有状态,每次请求都必须附上所有信息,所以请求的很多字段都是重复的,比如 Cookie 和 User Agent,一模一样的内容,每次请求都必须附带,这会浪费很多带宽,也影响速度</p><p>HTTP/2 对这一点做了优化,引入了头新压缩机制,一方面,头信息使用 gzip 或 compress 压缩后再发送;另一方面,客户端和服务器同时维护一张头信息表,所有字段都会存入这个表,生成一个索引号,以后就不发送同样字段了,只发送索引号,这样就能提供速度了</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求,主动向客户端发送资源,这叫做服务器推送,使用服务器推送,提前给客户端提送必要的资源,这样就可以相对减少一些延迟时间,这里需要注意的是 HTTP2 下服务器主动推送的是静态资源和 webSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的</p><h3 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h3><p>因为 HTTP/2 使用了多路复用,一般来说同一域名下只需要使用一个 TCP 连接,由于多个数据流使用同一个 TCP 连接,遵守同一个同一个流量状态控制和拥塞控制,只要一个数据流遭遇拥塞,剩下的数据流就没法发出去,这样就导致了后面的所有数据都被阻塞, HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题,与它本身的实现没有多大关系</p><h2 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h2><p>由于 TCP 本身存在的一些限制,Google 就开发了一个基于 UDP 协议的 QUIC 协议,并且使用在了 HTTP/3上,QUIC 协议在 UDP 协议上实现了 多路复用 / 有序交付 / 重传 等等功能</p><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ol><li>HTTP 报文使用明文的方式发送,可能被第三方窃听</li><li>HTTP 报文可能被第三方截取后修改通信内容,接收方没有办法发现报文内容的修改</li><li>HTTP 还存在认证的问题,第三方可以冒充他人参与通信</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS 指的是超文本传输安全协议,HTTPS 是基于 HTTP 协议的,不过它会使用 TLS/SSL 来对数据加密,使用 TLS/SSL 协议,所有的信息都是加密的,第三方没有办法窃听;并且它提供了一种校验机制,信息一旦被篡改,通信的双方会立刻发现,它还配备了身份证书,防止身边被冒充的情况出现</p><h2 id="TLS-握手实现原理"><a href="#TLS-握手实现原理" class="headerlink" title="TLS 握手实现原理"></a>TLS 握手实现原理</h2><p>TLS 的握手过程主要用到了三个方法来保证传输的安全</p><ol><li><p>首先的对称加密的方法,对称加密的方法是,双方使用同一个密钥对数据进行加密和解密,但对称加密存在的一个问题就是如何保证密钥传输的安全性,因为密钥还是会通过网络传输的,一旦密钥被其他人获取到,那么整个加密过程就毫无作用;这就要用到非对称加密的方法</p></li><li><p>非对称加密的方法是,我们拥有两个密钥,一个是公钥,一个是私钥,公钥是公开的,私钥是保密的,用私钥加密的数据只有对应的公钥才能解密,我们可以将公钥公布出去,任务想和我们通信的客户,都可以使用我们提供的公钥对数据进行加密,然后使用私钥进行解密,这样就能保证数据的安全了,但是非对称加密有一个缺点就是加密的过程很慢,因此如果每次通信都使用非对称加密的方法的话,反而会造成等待时间过长的问题; 因此我们可以使用对称加密和非对称加密结合的方法,因为对称加密方式的缺点就是无法保证密钥的安全传输,因此我们可以以非对称加密方式来对对称加密的密钥进行传输,然后以后通信使用对称加密的方式来加密,这样就解决了两个方法各种存在的问题</p></li><li><p>但是现在的方法也不一定是安全的,因为我们没有办法确定我们得到的公钥就一定是安全的公钥,可能存在一个中间人,截取了对方发给我们的公钥,然后将他自己的公钥发送给我们,当我们使用他的公钥加密后发送的信息,就可以被他用自己的私钥解密,然后伪装我们以同样的方法向对方发送信息,这样我们的信息就被窃取了,然而我们自己还不知道<br>为了解决这样的问题,我们可以使用数字证书的方式,首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要,然后让有公信力的认证中心,用它的私钥对消息摘要加密,形成签名,最后将原始的信息和签名结合在一起,称为数字证书,当接收方接收到数字证书的时候,先根据原始信息使用同一的 Hash 算法生成一个摘要,然后使用公证处的公钥来对数字证书中的摘要进行解密,最后将解密的摘要和我们生成的摘要进行对比,就能发现我们得到的信息是否被更改了这个方法最重要的是认证中心的可靠性,一般浏览器里会内置一些顶层的认证中心的证书,相当与我们自动信任了他们,只有这样我们才能保证数据的安全</p></li></ol><h1 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h1><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和HTTPS 使用端口不一样,前者是80, 后者是443</li><li>HTTP 协议运行在 TCP 之上,所有传输的内容都是明文,HTTPS 运行在 SSL/TLS 之上, SSL/TLS 运行在 TCP 之上,所有传输的内容都是密文传输 </li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h1&gt;&lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP HTTPS" scheme="https://monthlygirl.github.io/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/2021/03/JavaScript.html"/>
    <id>https://monthlygirl.github.io/2021/03/JavaScript.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li>在 js 中我们是使用构造函数来新建一个对象的,每一个构造函数的内部都有一个 prototype 属性,这个属性是一个对象,这个对象上包含了该构造函数的所有实例共享的属性和方法</li><li>当我们使用构造函数新建了一个对象后,在这个对象的内部包含一个指针 <code>__proto__</code>,这个指针指向该对象所属构造函数的 prototype 属性对应的值, 在ES5 中这个指针被称为 对象 的原型</li><li>一般来说我们是不能够获取到这个值的,但是现在的浏览器都实现了 <strong>proto</strong> 属性,让我们可以访问这个属性,但是最后不要用这个属性, 因为它不是规范中规定的</li><li>ES5 中新增了一个Object.getPrototypeOf()方法,我们可以通过这个方法来获取对象的原型</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>当我们访问一个对象的属性时,如果这个对象内部不存在这个属性,那么它就会去它的原型对象里找这个属性,这个原型对象又会有自己的原型,于是就这样一直找下去,这也就是原型链的概念.</li><li>原型链的尽头一般来说都是 object.prototype </li></ul><h2 id="原型和原型链的特点"><a href="#原型和原型链的特点" class="headerlink" title="原型和原型链的特点"></a>原型和原型链的特点</h2><ul><li>JavaScript 对象是通过引用来传递的,我们创建的每一个新对象实体中并没有 一份属于自己的原型,当我们修改原型时,与之相关的对象也会继承这一改变</li></ul><h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a>js 获取原型的方法</h2><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol><li>作用域: 当前代码对变量的访问权限(函数作用域,es6 let const 声明的块级作用域)</li><li>作用域链: 内层作用域访问一个变量,首先会在当前作用域的父级找,如果没找到,在往上一层找,直到找到全局,如果还没有找到就宣布放弃,这种一层一层向上的关系,就是作用域链,即以链式的方式访问变量</li></ol><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><ul><li>垃圾回收机制: 会自动释放内存,就是说一个函数执行完毕,内存中的空间会被释放,再一次调用的时候,函数内部会被重新赋值</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>读取函数内部的变量,让全局访问局部变量</li><li>延长变量的生命周期<h2 id="闭包的使用方式"><a href="#闭包的使用方式" class="headerlink" title="闭包的使用方式"></a>闭包的使用方式</h2></li></ol><ul><li>就是函数内部嵌套着另一个函数,这个函数在外部别调用,所以内存不会被回收,从而延长变量的生命周期</li></ul><h1 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h1><ul><li>递归就是函数自己调用函数自己,递归一定要有结束条件,否则会陷入死循环</li><li>使用场景: 遍历树的结构</li></ul><h1 id="js的异步机制"><a href="#js的异步机制" class="headerlink" title="js的异步机制"></a>js的异步机制</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/">《js的异步机制》</a></a></p><h1 id="事件循环机制-Event-Loop"><a href="#事件循环机制-Event-Loop" class="headerlink" title="事件循环机制(Event Loop)"></a>事件循环机制(Event Loop)</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/"><a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/">《事件循环机制Event Loop》</a></a></p><h1 id="什么是-Promise-对象-什么是-Promise-A"><a href="#什么是-Promise-对象-什么是-Promise-A" class="headerlink" title="什么是 Promise 对象? 什么是 Promise/A+ ?"></a>什么是 Promise 对象? 什么是 Promise/A+ ?</h1><ol><li>promise对象是异步编程的一种解决方案,最早由社区提出,promise/A+规范是javascript promise的规范,规定了一个promise所必须具有的特性</li><li>Promise 是一个构造函数,它接收一个函数作用参数, 并且返回一个promise实例,一个promise实例有三种状态,分别是pending,resolve,reject,对应着进行中,已完成,已失败,一个实例的状态只能由 pending 转换为 resolve 或由 pending 转换为 reject ,状态一经改变就凝固了,无法再改变,我们可以在异步操作结束后调用这两个函数改变promise的状态,一个状态一经改变可以通过 then 注册回调函数,可以立即得到结果</li></ol><h1 id="ES5-继承和-ES6-继承的区别"><a href="#ES5-继承和-ES6-继承的区别" class="headerlink" title="ES5 继承和 ES6 继承的区别"></a>ES5 继承和 ES6 继承的区别</h1><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><ul><li>ES5 的继承实质: 先创建子类,再实例化父类,并将父类的方法添加到子类的this中;可以通过原型或构造函数机制来实现</li><li>ES6 实质: 先创建父类,实例化子类通过调用super方法访问父类后,在通过修改this实现继承,super关键字指代父类的实例,即父类的this对象,在子类构造函数中,如果不调用super方法,子类得不到this对象</li><li>ES6 实现继承是通过关键字 <code>extends</code> <code>super</code> 来实现继承</li></ul><h1 id="new-的时候做了什么"><a href="#new-的时候做了什么" class="headerlink" title="new 的时候做了什么"></a>new 的时候做了什么</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型,将对象的原型设置为函数的 prototype 对象</li><li>让函数的 this 指向这个对象,执行构造函数的代码,为这个新对象添加属性</li><li>判断函数的返回值类型,如果是值类型,返回创建的对象;如果是引用类型,就返回这个引用类型的对象</li></ol><p>详情请看本站文章 <a href="http://localhost:4000/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"><a href="http://guestljz.gitee.io/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/">《如何实现一个 new》</a></a></p><h1 id="Ajax是什么-如何创建一个Ajax"><a href="#Ajax是什么-如何创建一个Ajax" class="headerlink" title="Ajax是什么? 如何创建一个Ajax?"></a>Ajax是什么? 如何创建一个Ajax?</h1><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li>AJAX,异步的 JavaScript 和 XML ,是一种实现 无页面刷新 获取数据的 混合技术 ,简单来说就是JavaScript执行异步请求<h2 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h2></li><li>比如,领导要找张三汇报工作,于是领导就委托秘书帮忙去叫张三,然后领导就继续忙自己的工作,直到秘书告诉领导张三到了,接着张三就开始汇报工作</li><li>AJAX 请求数据的流程 就跟 “领导找张三汇报工作相似” , 其中的核心 就是 <strong>秘书</strong>,<strong>秘书</strong>相当于浏览器的XMLHttpRequest对象,当浏览器发出HTTP请求与接收HTTP响应时,浏览器可以接着做其他的事情,直到收到xhr返回的数据渲染页面</li></ul><h2 id="AJAX-实现流程"><a href="#AJAX-实现流程" class="headerlink" title="AJAX 实现流程"></a>AJAX 实现流程</h2><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><h2 id="AJAX的状态"><a href="#AJAX的状态" class="headerlink" title="AJAX的状态"></a>AJAX的状态</h2><ul><li>0 表示未初始化,尚未调用open方法</li><li>1 启用open方法,数据发生</li><li>2 表示已调用open方法 接收到响应</li><li>3 表示正在解析</li><li>4 表示已完成</li></ul><p>详情请看本站文章 <a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/"><a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/">《Ajax》</a></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象,是一种编程开发思想,面向对象编程,它将真实世界各种复杂的关系,抽象为一个个对象,然后进行分工合作,完成对真实世界的模拟</li><li>面向对象的特性: 封装 / 多态 / 继承</li><li>面向对象就是对 <strong>现实世界理解和抽象的方法</strong><br>我对面向对象的理解就是: 面向对象的编程方式就是让每一个类都只做一件事,面向过程会让一个类越来越全能,就像是一个管家一样做了所有的事;而面向对象像是雇佣了一群职员,每个人做一件小事,各司其职,最终合作共赢</li></ul><h1 id="JSON-parse-和JSON-stringify"><a href="#JSON-parse-和JSON-stringify" class="headerlink" title="JSON.parse()和JSON.stringify()"></a>JSON.parse()和JSON.stringify()</h1><p>JSON.parse()把字符串解析成对象<br>JSON.stringify()从对象中解析出字符串</p><h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>详情请看本站文章 <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">《事件模型》</a></a> </p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托本质上是利用了浏览器事件冒泡的机制,因为事件在冒泡过程中会上传到父节点,并且父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件代理</p><p>使用事件代理我们可以不不必要为每一个子元素都绑定一个监听事件,这样减少了内存上的消耗,并且使用事件代理我们还可以实现事件的动态绑定,比如说新增了一个子节点,我们并不需要单独第为它添加一个监听事件,它所它发生的事件会交给父元素中的监听函数来处理</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行环境(即执行上下文中)存在着执行代码的的私有作用域,上层作用域的指向,方法的参数,这个作用域中定义的变量以及这个作用域的this对象等等</p><h1 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h1><p>基本数据类型: 栈内存 先进后出<br>复杂数据类型: 堆内存 优先队列,复杂数据类型将值报存在堆中,将值对应的指针保存在栈中,通过栈中的指针来获取堆中的值</p><h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>详情请看本站文章  <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/">《模块化》</a></a></p><h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><p><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/">《ES6 中新增特性》</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件模型</title>
    <link href="https://monthlygirl.github.io/2021/03/Event_Model.html"/>
    <id>https://monthlygirl.github.io/2021/03/Event_Model.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事件模型</p><h2 id="DOM0-级模型"><a href="#DOM0-级模型" class="headerlink" title="DOM0 级模型"></a>DOM0 级模型</h2><ul><li>第一周事件模型是最早的 DOM0 级模型,这种模型不会传播,所以没有事件流的概念,但是现在有的浏览器支持一冒泡的方式实现,它可以在网页中直接定义监听函数,也可以通过 js 属性来指定监听函数,这种方式是所有浏览器都兼容的</li></ul><h2 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h2><ul><li>第二种事件模型 是 IE 事件模型,在该事件模型中,一次事件共有两个过程,事件处理阶段,和事件冒泡阶段;事件处理阶段会首先执行目标元素绑定的监听事件;然后是事件冒泡阶段,冒泡指的是事件从目标元素冒泡到 document,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,这种模型通过 attachEvent 来添加监听函数,可以添加多个监听函数,会按顺序一次执行</li></ul><h2 id="DOM2-级模型"><a href="#DOM2-级模型" class="headerlink" title="DOM2 级模型"></a>DOM2 级模型</h2><ul><li>第三种是 DOM2 级事件模型,在该事件模型中,一次事件共有三个过程,第一个过程是事件捕获阶段;事件捕获指的是事件从 document 一直向下传播到目标元素,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,后面这两个阶段和 IE 事件模型的两个阶段相同,这种事件模型,事件绑定函数式 addEventListener,其中第三个参数可以指定事件是否在捕获阶段执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三种事件模型是什么&quot;&gt;&lt;a href=&quot;#三种事件模型是什么&quot; class=&quot;headerlink&quot; title=&quot;三种事件模型是什么?&quot;&gt;&lt;/a&gt;三种事件模型是什么?&lt;/h1&gt;&lt;p&gt;事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM0级 DOM2级" scheme="https://monthlygirl.github.io/tags/DOM0%E7%BA%A7-DOM2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://monthlygirl.github.io/2021/03/Module.html"/>
    <id>https://monthlygirl.github.io/2021/03/Module.html</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所以并没有模块化的概念,但随着程序越来越复杂,代码的模块化开发变得越来越重要</p><p>由于函数具有独立作用域的特点,最原始的写法是使用函数来作为模块,几个函数作用一个模块,但是这种方法容易造成全局污染,且模块间没有联系</p><p>后来提出了对象的写法,通过将函数作为一个对象的方法来实现,这样解决了直接使用函数作用模块的一些缺点,但是这种办法会暴露所以的模块成员,外部代码可以修改内部属性的值</p><p>也可以使用立即执行函数的写法,通过利用闭包来实现模块私有作用域的建立,同时不会对全局作用域造成污染</p><p>简单来说:模块化就是 把函数作为模块 ,<br>缺陷: 污染全局变量, 模块成员之间没什么关系<br>方法: 面向对象思想 ,并使用立即执行函数 ,实现闭包 避免了变量污染 同时同一模块内的成员也有了关系 在模块外部无法修改我们没有暴露出来的变量、函数 这就是简单的模块</p><h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="headerlink" title="js 的几种模块规范"></a>js 的几种模块规范</h2><ol><li><p>CommonJS 方法,它通过 require 来引入模块,通过 module.exports 定义模块的输出接口,这种模块加载方案是 服务端的解决方法,它是以同步的方式来引入模块的,因为在服务DAU文件都存储在本地磁盘,读取非常快,所以以同步的方式加载没有问题但如果是在浏览器端,由于模块加载时使用网络请求,因此使用异步加载的方式更加合适</p></li><li><p>AMD 方法,这种方法采用异步加载的方式来加载模块,模块的加载不影响后面语句的执行,所有依赖这个模块的语句都定义在一个回调函数里,等到加载完成后再执行回调函数 require.js 实现了 AMD 规范</p></li><li><p>CMD 方案,这种方案和 AMD 方案都是为了解决异步模块加载的问题,sea.js实现了 CMD 规范,它和require.js 的区别在于模块定义时对依赖的处理不同对依赖模块的执行时机的处理也不同</p></li><li><p>ES6 提出的方案,使用 import 和 export 的形式来导入导出模块,这种方案和上面三种方案都不同</p></li></ol><h1 id="AMD-和-CMD-规范的区别"><a href="#AMD-和-CMD-规范的区别" class="headerlink" title="AMD 和 CMD 规范的区别"></a>AMD 和 CMD 规范的区别</h1><p>主要区别在两个方面</p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同,AMD 推崇依赖前置,在定义模块的时候就要声明其依赖的模块,而 CMD 推崇就近依赖,只有利用某个模块的时候再去 require</p></li><li><p>第二个方面试依赖模块的执行时机处理不同,首先 AMD 和 CMD 对于模块的加载方式都是异步加载,不过他们在于模块的执行时机,AMD 在依赖模块加载完成后就直接执行依赖模块,依赖模块的执行顺序和我们书写的顺序不一定一致,而 CMD 在依赖模块加载完成后并不执行,只是下载而已,等到所有的依赖模块都加载好后,进入回调函数逻辑,遇到require语句时才执行对应模块</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化开发怎么做&quot;&gt;&lt;a href=&quot;#模块化开发怎么做&quot; class=&quot;headerlink&quot; title=&quot;模块化开发怎么做&quot;&gt;&lt;/a&gt;模块化开发怎么做&lt;/h1&gt;&lt;p&gt;模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="模块化" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6中新增的特性</title>
    <link href="https://monthlygirl.github.io/2021/02/ES6.html"/>
    <id>https://monthlygirl.github.io/2021/02/ES6.html</id>
    <published>2021-02-27T09:09:02.000Z</published>
    <updated>2021-02-27T09:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><h1 id="新增块级作用域"><a href="#新增块级作用域" class="headerlink" title="新增块级作用域"></a>新增块级作用域</h1><h2 id="通过let-定义块级作用域"><a href="#通过let-定义块级作用域" class="headerlink" title="通过let 定义块级作用域"></a>通过let 定义块级作用域</h2><ol><li>没有变量提升,变量必须先声明后使用</li><li>通过let 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a)  //报错 必须先定义后使用</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>   <span class="comment">//在全局中定义可以在全局中使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// let a =  1  // 报错不能重复定义相同的变量名</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>   <span class="comment">//只能在当前块,当前大括号中使用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过const声明"><a href="#通过const声明" class="headerlink" title="通过const声明"></a>通过const声明</h2><ol><li>const声明变量的同时必须初始化,一旦初始化后这个变量的值就不允许修改</li><li>const声明变量也是一个块级作用域的变量,只能在当前块使用</li><li>const声明的变量也没有变量提升,必须先声明后使用</li><li>const 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//报错,a不允许修改</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="新增函数特性"><a href="#新增函数特性" class="headerlink" title="新增函数特性"></a>新增函数特性</h1><h2 id="函数可以设置默认参数"><a href="#函数可以设置默认参数" class="headerlink" title="函数可以设置默认参数"></a>函数可以设置默认参数</h2><p>在我们调用函数时,如果设置了默认形参,如果没有给函数传参,那么函数可以使用默认形参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b )  <span class="comment">//输出 a=1,b=2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun2</span>(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//输出 a=10,b=20</span></span><br><span class="line"><span class="title function_">fun2</span>(<span class="number">10</span>) <span class="comment">//输出 a=10,b=2</span></span><br></pre></td></tr></table></figure><p>同样,在构造函数中也可以使用此方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,sex,age=<span class="number">10</span></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">sex</span> =sex</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> guestljz = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;guestljz&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;guestljz: &#x27;</span>, guestljz);  <span class="comment">//guestljz: Person &#123;name: &quot;guestljz&quot;, age: 10, sex: &quot;女&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5中的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun3</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数的几种写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun4</span>= (<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3.</span>..</span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 书写语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果箭头函数只有一个形参,可以省略括号不写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun5</span> = abc=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数的花括号后面只有一句语句,可以省略花括号不写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun6</span> = abc=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数花括号后面只有一句语句,并且需要立即返回一个值,那么可以将花括号改写成 ()</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun7</span> = abc =&gt; ( n=abc )</span><br></pre></td></tr></table></figure><p>使用箭头函数,我们可以使用多种方式书写函数,并且更简洁,更方便<br>但值得注意的是,在箭头函数中,没有this,换句话说,箭头函数中的this是外部作用域中的this</p><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>关于this指向问题相关 参考  <a href="https://guestljz.gitee.io/2021/02/27/JavaScript/this%E6%8C%87%E5%90%91/">《this指向问题》</a></p><h1 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h1><p>将一个个数据打开成为一个个的状态,通过用它来展开数组或对象,也可以在函数传递参数的时候使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)   <span class="comment">//输出 [1,2,3,4,5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(..<span class="property">arr</span>)  <span class="comment">//输出 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将多个数组合并成一个数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> newArr2 = [...arr2,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr2) <span class="comment">//输出一个新数组  [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给函数传递参数使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun8</span>()=<span class="function">(<span class="params">a,b,c</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c: &#x27;</span>, c);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b: &#x27;</span>, b);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="title function_">fun8</span>(...arr3)</span><br></pre></td></tr></table></figure><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>快速从对象或者数组中获取成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象中的结果赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125;=&#123;<span class="attr">foo</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">bar</span>:<span class="string">&#x27;bbb&#x27;</span>&#125;  <span class="comment">//foo = aaa, bar=bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成这种形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">  <span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name,age,gender &#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>:a&#125; = obj </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换变量</span></span><br><span class="line"><span class="keyword">let</span> [n1,n2] = [n2,n1]</span><br></pre></td></tr></table></figure><h1 id="新增字符串方法"><a href="#新增字符串方法" class="headerlink" title="新增字符串方法"></a>新增字符串方法</h1><h2 id="string-includes"><a href="#string-includes" class="headerlink" title="string.includes()"></a>string.includes()</h2><p>  判断字符串是否包含一个指定的值,返回一个布尔值,表示是否找到了参数字符串。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;d&quot;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p> 还支持第二个参数,从哪个位置开始查找<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;g&quot;</span>,<span class="number">4</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="string-startsWith"><a href="#string-startsWith" class="headerlink" title="string.startsWith()"></a>string.startsWith()</h2><p>表示参数字符串是否在原字符串的头部,返回一个布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>同样也支持第二个参数,表示从哪个位置开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;abc efg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;efg&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="string-endsWith"><a href="#string-endsWith" class="headerlink" title="string.endsWith()"></a>string.endsWith()</h2><p> 返回布尔值，表示参数字符串是否在原字符串的尾部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.<span class="title function_">endsWith</span>(<span class="string">&quot;g&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也支持第二个参数,这个第二参数表示,从第0个到第n个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.<span class="title function_">endsWith</span>(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还有许多,详看 阮一峰的es6教程</p><h1 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h1><ul><li>Map 和 Set 是 ES6 新增的两个数据类型</li><li>都是属于内置构造函数</li><li>使用 new 的方式来实例化使用</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>Set 是一个构造函数,用来生成 Set 数据结构,它类似于数组,但是成员的值都是唯一的 , 没有重复的,初始化 Set 可以接受一个数组或类数组对象作为参数,也可以创建一个空的 Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">        size: (...)</span></span><br><span class="line"><span class="comment">        __proto__: Set</span></span><br><span class="line"><span class="comment">        [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">        length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>我们可以在 new 的时候直接向内部添加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化的时候直接添加数据,要以数组的形式添加</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Set(7) &#123;1, 2, 3, &#123;…&#125;, ƒ, …&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Set</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(7)</span></span><br><span class="line"><span class="comment">    0: 1</span></span><br><span class="line"><span class="comment">    1: 2</span></span><br><span class="line"><span class="comment">    2: 3</span></span><br><span class="line"><span class="comment">    3: Object</span></span><br><span class="line"><span class="comment">    4: function () &#123;&#125;</span></span><br><span class="line"><span class="comment">    5: true</span></span><br><span class="line"><span class="comment">    6: &quot;hwllo&quot;</span></span><br><span class="line"><span class="comment">    length: 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>看上去是一个类似数组的数据结构,但不是数组,是<strong>Set 数据结构</strong></p></li></ul></li></ul><h3 id="常用的方法和属性"><a href="#常用的方法和属性" class="headerlink" title="常用的方法和属性"></a>常用的方法和属性</h3><ul><li><p><code>size</code> : 用来获取该数据结构中有多少数据的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">//7</span></span><br></pre></td></tr></table></figure><ul><li>看上去是一个和数组数据类型差不多的数据结构,而且也看到的 length 属性</li><li>但是不能使用,想要获取该数据类型中的成员数量,<strong>需要使用 size 属性</strong></li></ul></li><li><p><code>add</code> : 用来向该数据类型中追加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">0</span>)</span><br><span class="line">s.<span class="title function_">add</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>&#125;)</span><br><span class="line">s.<span class="title function_">add</span>(&#123;<span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有点饿了&quot;</span>)&#125;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>这个方法就是向该数据类型中追加数据使用的</li></ul></li><li><p><code>delete</code> : 用来删除该数据结构中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">s.<span class="title function_">delete</span>(&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清空数据结构中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> : 查询数据结构中有没有某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">0</span>))  <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(&#123;&#125;))  <span class="comment">// true</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code> : 用来遍历 Set 数据结构的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数据结构的每一项</span></span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function"><span class="params">ietm</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ietm: &#x27;</span>, ietm);</span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ietm:  1</span></span><br><span class="line"><span class="comment">  ietm:  2</span></span><br><span class="line"><span class="comment">  ietm:  3</span></span><br><span class="line"><span class="comment">  ietm:  &#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  ƒ ()&#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  true</span></span><br><span class="line"><span class="comment">  ietm:  hello</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>方法介绍差不多了,但是有一个问题出现了,那就是</p></li><li><p>我们的方法添加 / 删除 / 查询 ,没有获取</p></li><li><p>获取 Set 结构里面的数据需要借助一个  <code>...</code> 展开运算符</p></li><li><p>把他里面的东西都放到一个数组里面去,然后再去获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">const</span> a = [...s1]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a: &#x27;</span>, a)</span><br><span class="line"><span class="comment">// 输出 a: (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>,a[<span class="number">0</span>])  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>又有一个问题出现了,new的时候需要以数组的形式传递</p></li><li><p>然后获取的时候又要转成数组的形式获取</p></li><li><p>那为什么不一开始就定义数组,为什么要弄一个 Set 数据类型?</p></li><li><p>这不得不提到一个 Set 的特点</p></li><li><p><strong>Set 不允许存储重复的数据</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">2</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">3</span>)  <span class="comment">//此时 size 是4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><p>Map 是一个构造函数,用来生成 Map 数据结构,它类似于对象,也是键值对的集合,但是”键”可以是非字符串,初始化 Map 需要一个二维数组,或者直接初始化一个空的 Map:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Map(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Map</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">    length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>在对象中不管存储什么, key 一定是一个字符串类型,对象是一个键值对 的集合 key : value</p></li><li><p>但是在 Map 里面,key 可以任意数据类型</p></li><li><p>Map 也可以叫做 (值 = 值) 的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"> <span class="comment">//   初始化的时候就给一些值</span></span><br><span class="line"> <span class="comment">//   传递的参数需要是一个数组</span></span><br><span class="line"> <span class="comment">//   数组需要是一个 二维数组</span></span><br><span class="line"> <span class="comment">//   二维数组里面的每一个小数组接受两个数据</span></span><br><span class="line"> <span class="comment">//   这个两个数据可以是任意数据类型</span></span><br><span class="line"> <span class="comment">//   这个两个数据第一个就是 key，第二个就是 value</span></span><br><span class="line"> <span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>], [&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;, <span class="number">18</span>]])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性"></a>常用方法和属性</h3><ul><li><p><code>size</code> ： t用来获取该数据类型中数据的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>delete</code> : 用来删除该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line">  m.<span class="title function_">delete</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>set</code> : 用来向该数据集合中添加数据使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>get</code> : 用来获取该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="literal">true</span>)) <span class="comment">// function () &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清除数据集合中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">clear</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> ： 用来判断数据集合中是否存在某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="literal">true</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>forEach ：遍历 MAP 数据集合中的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><ul><li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p></li><li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 **``**（反引号）</p></li><li><p>区别是使用 **``**（反引号）我们可以在字符串里面使用 <code>$&#123;变量名&#125;</code> 拼接变量</p></li><li><p>使用 单引号再字符串中不能直接换行,使用反引号可以直接换行</p></li></ul><h1 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h1><ul><li><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p></li><li><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></li><li><p>在创建symbol类型数据时的参数只是作为标识使用，直接使用 Symbol() 也是可以的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;xm&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( s );</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">typeof</span> s );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</span></span><br><span class="line"> <span class="keyword">var</span> xm = <span class="title class_">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     [xm] : <span class="string">&quot;小明&quot;</span> <span class="comment">//对象的属性是Symbol类型</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Symbol类型的属性 取值是 必须 obj[xm] 不能用obj.xm</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj[xm] );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> s4 = <span class="title class_">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xm&#x27;</span>,</span><br><span class="line">     [s4]: <span class="string">&#x27;xh&#x27;</span>,</span><br><span class="line">     [<span class="title class_">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &quot;xm&quot;, Symbol(): &quot;xh&quot;, Symbol(age): 18&#125;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// xm</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[s4]); <span class="comment">// xh 访问对象的Symbol属性的值</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改symbol类型的属性</span></span><br><span class="line"> obj[xm] = <span class="string">&quot;web前端&quot;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj[xm] );</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> <span class="comment">//对象的Symbol属性不会被遍历出来（可以用来保护对象的某个属性）</span></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&quot;sname&quot;</span>:<span class="string">&quot;小明&quot;</span>,</span><br><span class="line">     <span class="string">&quot;skill&quot;</span> : <span class="string">&quot;web&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="title class_">Symbol</span>();</span><br><span class="line"> obj[age] = <span class="number">18</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj );</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; -&gt; &quot;</span> + obj[key] );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">     [id]: <span class="string">&#x27;007&#x27;</span>,</span><br><span class="line">     [<span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;xiaocuo&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> arr = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[Symbol(id),Symbol(name)]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[arr[<span class="number">0</span>]]);  <span class="comment">//&#x27;007&#x27;  访问对象的Symbol属性的值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</span></span><br><span class="line"> <span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( s1 === s2 ); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 官方提供了全局注册并登记的方法：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建 </span></span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回 </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name1 === name2); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过symbol对象获取到参数值：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;丽丽&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name1));  <span class="comment">// &#x27;张三&#x27;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name2)); <span class="comment">// &#x27;丽丽&#x27;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6-中新增特性&quot;&gt;&lt;a href=&quot;#ES6-中新增特性&quot; class=&quot;headerlink&quot; title=&quot;ES6 中新增特性&quot;&gt;&lt;/a&gt;ES6 中新增特性&lt;/h1&gt;&lt;h1 id=&quot;新增块级作用域&quot;&gt;&lt;a href=&quot;#新增块级作用域&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://monthlygirl.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>this指向</title>
    <link href="https://monthlygirl.github.io/2021/02/this.html"/>
    <id>https://monthlygirl.github.io/2021/02/this.html</id>
    <published>2021-02-27T06:31:25.000Z</published>
    <updated>2021-02-27T06:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><p>this是一个使用在作用域里面的关键字<br>this的指向只跟函数调用有关</p><ul><li>在全局中使用this,this === window ,this指向全局,但很少在全局中使用</li><li>一个函数的this指向只和函数的调用有关(箭头函数除外),不管怎么定义,在哪定义,分以下几种情况<ol><li>函数在全局中调用,那么this就指向全局</li><li>对象调用,this就指向当前对象</li><li>事件处理函数,this指向事件源</li><li>定时器处理函数,this指向window</li></ol></li></ul><h1 id="强行改变this指向"><a href="#强行改变this指向" class="headerlink" title="强行改变this指向"></a>强行改变this指向</h1><p>在ES5的函数中使用this,因为当不同的函数在不同的作用域中调用,this的指向也就不一样,通常需要强行改变this指向,改变this指向可以通过以下三种方法 </p><h2 id="1-call"><a href="#1-call" class="headerlink" title="1. call()"></a>1. call()</h2><ul><li>直接在函数名后面使用</li><li>正常调用方式: fn(),obj.fn()</li><li>强行改变this指向方式: fn.call(),obj.call()</li><li>参数(两个参数及以上)<br>call(参数1,参数2…)<br>第一个参数表示: this要指向哪里,不传或传null,表示this指向window<br>第二个参数开始:传递给函数的参数,供函数内部使用</li><li>作用: 改变函数内部的this指向</li><li>特点: 会直接调用函数,函数会被立即执行</li></ul><h2 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply()"></a>2. apply()</h2><p>   使用方式与call一样</p><ul><li>参数:<br>apply(参数1,参数2)<br>第一个参数表示:改变this指向的对象,不传或传null,表示this指向window<br>第二个参数:是一个数组或伪数组,数组中存放传递给函数 的参数,供函数内部使用</li><li>作用:改变函数内部的this指向,函数会被立即执行</li><li>特点: 改变函数传参的方式</li></ul><h2 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. bind()</h2><p>  使用方式和前两个一样,参数与call一样</p><ul><li>作用: 改变函数内部this指向,函数不会被立即执行</li><li>特点:<br>不会直接调用函数,返回一个新函数,这个新函数中的this指向已经改变,在我们需要时调用执行即可<br>bind改变过后,this指向不会再改变了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向问题&quot;&gt;&lt;a href=&quot;#this指向问题&quot; class=&quot;headerlink&quot; title=&quot;this指向问题&quot;&gt;&lt;/a&gt;this指向问题&lt;/h1&gt;&lt;p&gt;this是一个使用在作用域里面的关键字&lt;br&gt;this的指向只跟函数调用有关&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="this" scheme="https://monthlygirl.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>React总结</title>
    <link href="https://monthlygirl.github.io/2021/02/React.html"/>
    <id>https://monthlygirl.github.io/2021/02/React.html</id>
    <published>2021-02-22T13:49:17.000Z</published>
    <updated>2021-02-22T13:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React中的key的作用"><a href="#React中的key的作用" class="headerlink" title="React中的key的作用"></a>React中的key的作用</h1><blockquote><p>key可以帮助React跟踪循环列表中的虚拟DOM,以此来了解哪些元素是已更改 / 添加 / 删除 的</p><p>react利用key来识别组件,它是一种唯一标识,相同的key React会认为是同一个组件,后续相同key对应组件都不会被创建</p><p>有了key属性后,就可以与组件建立相应的关系,react根据key来决定组件是销毁还是更新</p><p>如果key相同,组件的属性有所变化,那么react只更新组件对应的属性,没有变化则不更新</p><p>key值不同,那么react先销毁该组件,然后在重新创建组件</p></blockquote><h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><h3 id="1-挂载阶段-有3个常用的生命周期"><a href="#1-挂载阶段-有3个常用的生命周期" class="headerlink" title="1.挂载阶段,有3个常用的生命周期"></a>1.挂载阶段,有3个常用的生命周期</h3><ol><li>construtor()<br>实例被初始化时会调用这个函数,是所有生命周期中第一个执行的函数,可以在这里定义声明式变量</li><li>componentDidMount()<br>实例初始化完成,这个生命周期只执行一次,再次更新视图时不执行,可以在这里修改state,调接口,建立长连接</li><li>render()<br>所有生命周期中必须要有的生命周期,且一定要有返回值,并且返回的是一个jsx对象,它在挂载阶段和更新阶段都会zhixing</li></ol><h3 id="2-更新阶段-有2个常用的生命周期"><a href="#2-更新阶段-有2个常用的生命周期" class="headerlink" title="2.更新阶段,有2个常用的生命周期"></a>2.更新阶段,有2个常用的生命周期</h3><ol><li>componentUpdate()<br>它表示视图已更新完成,每次更新State中的数据,都会执行componentUpdate()和render()</li><li>shouldComponentUpdate()<br>它的作用是在类组件中提升性能,抽离出不参与视图渲染的数据,让它们不参与diff运算<br>这个生命周期必要要有一个返回值,且返回值是一个布尔值,返回false时不更新</li></ol><h3 id="3-销毁阶段-只有一个生命周期"><a href="#3-销毁阶段-只有一个生命周期" class="headerlink" title="3.销毁阶段,只有一个生命周期"></a>3.销毁阶段,只有一个生命周期</h3><ol><li><p>componentWillUnMount()<br>它表示组件将要被销毁,一般在这里清除定时器 / 缓存 / 长连接 等</p><h1 id="调用setState之后发生了什么"><a href="#调用setState之后发生了什么" class="headerlink" title="调用setState之后发生了什么"></a>调用setState之后发生了什么</h1></li></ol><ul><li>在代码中调用setState之后,React会将传入的参数对象与当前的状态进行合并,然后触发调和过程</li><li>经过调和过程,React会以相对高效的方式根据新的状态构建React虚拟DOM树,并且开始准备重新渲染UI界面</li><li>React在得到虚拟DOM树后,会先比较新得到的树和老树的差异,然后根据diff运算进行界面的最小化渲染</li><li>在diff运算算法中,React能够精确的知道哪些元素发生了变化,以及应该如何变化,这就保证了按需更新,而不是全部更新</li></ul><h1 id="多次触发setState-那么render会执行几次"><a href="#多次触发setState-那么render会执行几次" class="headerlink" title="多次触发setState,那么render会执行几次"></a>多次触发setState,那么render会执行几次</h1><ul><li>多次的setState最终会合并成一次render,因为setState不能立即修改state的值,而是将它放到一个任务队列中,最终多个setState会被合并,一次性更新页面</li><li><strong>传入对象会被合并</strong></li><li><strong>传入函数不会被合并,函数无法合并</strong></li></ul><h1 id="setState什么时候同步-什么时候异步"><a href="#setState什么时候同步-什么时候异步" class="headerlink" title="setState什么时候同步?什么时候异步?"></a>setState什么时候同步?什么时候异步?</h1><ol><li>如果是由React引发的事件处理(如:通过onClinck触发的事件处理),此时<code>setState</code>是异步的,它不会同步更新<code>this.state</code>,并且多个<code>setState</code>在执行过程中会被合并;除此之外,<code>setState</code>是同步的,而这里的”除此之外”是指绕过react,使用原生DOM事件(如addEventListener)调用<code>setState</code>,还有通过 <code>setTimeOut</code> / <code>setInterval</code> 执行<code>setState()</code>,此时<code>setState</code>是同步的</li></ol><h1 id="为什么要调用setState而不是直接修改state"><a href="#为什么要调用setState而不是直接修改state" class="headerlink" title="为什么要调用setState而不是直接修改state"></a>为什么要调用setState而不是直接修改state</h1><ul><li>如果你尝试直接state,那么react将接收不到state被修改的信息,即它无法知道它需要重新渲染组件;因此需要调用 <code>setState()</code>方法,这样react才会更新UI组件</li></ul><h1 id="this-setState-之后React都做了哪些工作"><a href="#this-setState-之后React都做了哪些工作" class="headerlink" title="this.setState 之后React都做了哪些工作"></a>this.setState 之后React都做了哪些工作</h1><ul><li>shouldcomponentUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><h1 id="虚拟DOM是如何工作的"><a href="#虚拟DOM是如何工作的" class="headerlink" title="虚拟DOM是如何工作的"></a>虚拟DOM是如何工作的</h1><ul><li>当数据发生变化时,比如setSTate时,会引起组件的重新渲染,整个UI都会以虚拟DOM的形式重新渲染</li><li>然后React就会收集差异进行diff运算,diff运算会找出虚拟DOM中的脏节点</li><li>最后将差异队列中的差异渲染到真实的DOM上</li></ul><h1 id="为什么要使用虚拟DOM"><a href="#为什么要使用虚拟DOM" class="headerlink" title="为什么要使用虚拟DOM"></a>为什么要使用虚拟DOM</h1><ul><li>频繁的DOM操作,会导致页面的重绘和回流,出于性能考虑,我们要减少页面的重绘和回流<h2 id="什么是重绘"><a href="#什么是重绘" class="headerlink" title="什么是重绘"></a>什么是重绘</h2></li><li>当DOM树中一些元素需要更新属性,而这些属性只是影响元素的外观,风格,不影响元素的布局时,称为重绘,比如:修改background-color,这就叫重绘<h2 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h2></li><li>当DOM树中,因为元素的尺寸,规模,布局时需要重新构建时,便称为回流,一个DOM树中,至少经历一次回流,就是页面初始化渲染时<h2 id="重绘和回流的区别"><a href="#重绘和回流的区别" class="headerlink" title="重绘和回流的区别"></a>重绘和回流的区别</h2></li><li>回流一定会引起重绘,重绘不一定会引起回流,比如当整个页面只有颜色发生改变时就只会发生重绘而不会引起回流</li><li>如果是元素的布局或几何属性发生改变时,就会引起回流,比如改变div的大小,加padding,margin等</li></ul><h1 id="虚拟DOM为什么会提高性能"><a href="#虚拟DOM为什么会提高性能" class="headerlink" title="虚拟DOM为什么会提高性能"></a>虚拟DOM为什么会提高性能</h1><ul><li>虚拟DOM相当于在js和真实的DOM中间加了一层缓存,利用DOM的diff避免过多的操作真实DOM,从而提升性能</li><li>用javascript对象表示DOM树</li><li>然后用这个对象树构建一个真正的DOM树,插到文档当中,当状态变更的时候,重新构造一颗新的对象树</li><li>之后进行diff运算,进行新老两树相比较,记录两颗树的差异从而将差异渲染到真实的DOM树中</li></ul><h1 id="diff运算原理"><a href="#diff运算原理" class="headerlink" title="diff运算原理"></a>diff运算原理</h1><ul><li>在传统做法中,diff运算是一个深度递归的过程,则就是将整颗树进行循环遍历进行比较,从而找出不同,效率低下,算法复杂度达到O(n^3)</li><li>所以react在diff运算上基于以下三个策略上做了很大的提升</li></ul><ol><li>web UI中DOM节点跨层级的移动操作特别少,可以忽略不计</li><li>拥有同类的两个组件将会生成相似的树形结构,拥有不同类的两个组件将会生成不同的树形结构</li><li>对于同一层级的一组子节点,它们可以通过唯一 id(即key) 进行区分</li></ol><p>基于以上三个策略,react分别对应的 tree diff,component diff ,element diff 进行算法优化</p><ul><li><p>tree diff<br>基于策略一,React 对树进行分层比较,两棵树只会对同一层次的节点进行比较<br>那么如果出现了跨层级的移动和操作,那么将为以当前这个脏节点为根节点,根节点下的整个树将会被重新创建,这是一种影响React性能的操作,因此官方建议不要进行DOM节点跨层级的操作</p></li><li><p>component diff<br>基于策略二,对于同类型组件,则按照原策略继续比较 Virtrual DOM树,对于同类型的组件,有可能其虚拟DOM 没有任何变化,如何能够准确知道这点,那么就可以节省大量的diff运算时间;因此,react允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析<br>如果不是,则将该组件判断为 dirty component ,然后替换整个组件下的所有子节点</p></li><li><p>element diff<br>策略三,脏节点在同一类型组件,根据策略三,同一层级的节点,它们通过key进行区分,当我们遍历一遍待渲染的节点,就能确定要添加 / 删除 / 更新的节点 , 然后修改组件</p></li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><ul><li>状态管理的作用: 1.组件间的数据共享,数据变化组件间的页面也变化,2.做缓存<h2 id="Redux-的三个3原则"><a href="#Redux-的三个3原则" class="headerlink" title="Redux 的三个3原则"></a>Redux 的三个3原则</h2></li><li>三个api: createStore() / combineReducers() / applyMidleWare()</li><li>三个特点: Store 是只读的 / 单向数据流 / 修改state只能通过纯函数 reducer 来修改</li><li>三个概念: store/ reducer / action</li></ul><h2 id="Redux-的工作流程"><a href="#Redux-的工作流程" class="headerlink" title="Redux 的工作流程"></a>Redux 的工作流程</h2><blockquote><p>当用户在View 触发dispatch,dispatch会生成一个action()方法,将它发送给Store;Store接收到action方法后,会调用reducer函数,Store会传2两个参数给reducer,一个是初始化的state,另一个是收到的action,以此来修改State,当State变化时,View也发生变化,由此可以知道reducer是一个纯函数,它会返回一个新的state,即修改后的state</p></blockquote><h2 id="在Redux中调接口"><a href="#在Redux中调接口" class="headerlink" title="在Redux中调接口"></a>在Redux中调接口</h2><blockquote><p>redux只支持dispatch同步的action,并且要求action只能是一个plain object(普通对象)<br>当react组件中dispatch(fetch)触发调接口,此时,action不是一个plain object,是一个函数,而store中不支持接收函数,所以需要使用中间件 react-thunk</p></blockquote><p>完成一次异步的dispatch需要两次派发<br>第一次派发一个空的action<br>第二次才会将action派发到store中<br>第一次dispatch的action会被thunk这个中间件接收,thunk首先会判断,此时这个action是不是一个函数,如果不是,原封不动的将这个action转发到store中,如果此时这个action是一个函数,那么thunk会执行函数内部的代码,执行第二次派发 直接执行这个函数,执行完毕再将这个函数返回的结果转发到store中</p><h2 id="Redux中的中间件"><a href="#Redux中的中间件" class="headerlink" title="Redux中的中间件"></a>Redux中的中间件</h2><ul><li>thunk,dispatch一个函数</li><li>saga,以generator方式书写Redux</li><li>promise,也是解决异步,允许payload是一个promise对象</li></ul><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h3 id="1-什么是Hook"><a href="#1-什么是Hook" class="headerlink" title="1.什么是Hook?"></a>1.什么是Hook?</h3><blockquote><p>Hook是React新增的特性,它可以在你不使用类组件的情况下使用State和其他的react特性</p></blockquote><h4 id="1-1-常用的Hook"><a href="#1-1-常用的Hook" class="headerlink" title="1-1.常用的Hook"></a>1-1.常用的Hook</h4><p>如: </p><ol><li><p>useState  </p><blockquote><p>关于useState的用法是: 需要传入一个参数作为状态的初始值,当函数执行后会返回两个值,一个是当前状态的属性,一个是修改状态的方法</p></blockquote></li><li><p>useEffect</p><blockquote><p>副作用, 通常在副作用中进行ajax请求,事件的绑定和解绑,设置定时器和清除器等;<br>useEffect有两个参数<br>第一个参数是一个回调函数,这个回调函数相当于 React生命周期中 componentDidMount() 这个钩子函数(只是相当于这个生命周期,实际上并不是生命周期),在这个回调函数中,可以进行ajax请求,设置定时器,绑定事件等等 ; 这个回调函数的返回值是一个函数,这个返回值,它相当于是React生命周期中componentWillUnmount() 这个钩子函数,我们可以在这里清除定时器,清除缓存,对事件进行解绑等<br>useEffect的第二个参数是依赖项数组,如果数组中的依赖发送变化,那么该副作用就会重新执行,如果不设置第二个参数,那么当该组件每渲染一次,副作用就会执行一次;如果设置为空数组,那么该副作用只会在组件初次渲染时执行一次<br>在副作用中,不仅可以进行ajax请求,还可以通过调用的本地的State来进行页面更新</p></blockquote></li><li><p>useContext</p><blockquote><p>上下文</p></blockquote></li><li><p>useRef</p><blockquote><p>获取DOM节点,进行DOM操作</p></blockquote></li><li><p>useMemo</p><blockquote><p>useMemo,创建一个依赖函数,当其中一个依赖项更改时,useMemo重新计算机记忆的值,而不需要在每个组件渲染时进行diff运算<br>目的: 避免重复进行复杂耗时的代码计算,所以将计算的结果存起来. 只有在需要计算时使用<br>传入两个参数: 一个回调函数,一个依赖项数组<br>useMemo 的作用<br>useMemo其实创建了一种数据缓存机制,比如登录页面需要向后台发送含用户名&amp;密码的ajax请求,获取用户登录信息,useMemo可以设置成只有当有用户密码改变后才向后台重新发送ajax,而在组件重新渲染时使用缓存的用户信息<br>useMemo与useEffect区别<br>useMemo 与 useEffect 作用类似,都会在依赖值改变时重新执行,但useMemo有一个缓存的返回值, 因此在组件渲染生命周期中,很自然地会把useMemo放到渲染DOM前执行</p></blockquote></li></ol><p>  <strong>useMemo =&gt; 渲染DOM =&gt; useEffect</strong><br>  当我们遇到复杂的计算可以使用useMemo<br>6. useCallback</p><blockquote><p>与useMemo传入的参数是一样的,都是在其依赖项发送变化后才执行的,都是返回缓存的值,区别在于useMemo返回的是函数运行的结果,useCallback返回的是函数<br>  <strong>大部分时不用,可以在搭配shouldComponentUpdate()或有多个useEffect时使用</strong></p></blockquote><h1 id="React中context"><a href="#React中context" class="headerlink" title="React中context"></a>React中context</h1><ul><li>作用: 用于React组件树中传递数据,避免使用复杂的链式的props数据传递</li><li>上下文机制: 它的数据只能单向传输,从父组件向内部组件传递</li></ul><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="怎么理组合"><a href="#怎么理组合" class="headerlink" title="怎么理组合"></a>怎么理组合</h2><ol><li>组合在React中,是一种非常强大的组件复用的设计模式, react中组件复用的思想用的是组合的思想</li><li>建立的语法基础:props可传递任何数据类型,包括jsx对象</li></ol><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><ul><li>将组件需要共用的数据,提升到相同的父组件的props中,子组件通过props使用这些数据,以达到数据共用的效果</li></ul><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><ul><li>高阶组件实际上就是一个纯函数,即唯一的输入得到唯一的输出,所以高阶函数也叫高阶组件<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>是一种组件复用的技巧,用于修饰UI组件<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2></li><li>基础react组合的特性</li></ul><h1 id="React数据类型检查"><a href="#React数据类型检查" class="headerlink" title="React数据类型检查"></a>React数据类型检查</h1><ul><li>使用第三库props_types,对自定义属性执行类型检查</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React中的key的作用&quot;&gt;&lt;a href=&quot;#React中的key的作用&quot; class=&quot;headerlink&quot; title=&quot;React中的key的作用&quot;&gt;&lt;/a&gt;React中的key的作用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;key可以帮助React跟</summary>
      
    
    
    
    <category term="React" scheme="https://monthlygirl.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://monthlygirl.github.io/tags/React/"/>
    
  </entry>
  
</feed>
