<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月刊少女野崎君のBlog</title>
  
  
  <link href="https://monthlygirl.github.io/atom.xml" rel="self"/>
  
  <link href="https://monthlygirl.github.io/"/>
  <updated>2024-05-18T02:49:17.000Z</updated>
  <id>https://monthlygirl.github.io/</id>
  
  <author>
    <name>月刊少女野崎君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多云切换-静态资源自动重试</title>
    <link href="https://monthlygirl.github.io/posts/cdn-retry.html"/>
    <id>https://monthlygirl.github.io/posts/cdn-retry.html</id>
    <published>2024-05-18T02:49:17.000Z</published>
    <updated>2024-05-18T02:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>静态资源的快速加载和高可用性对用户体验至关重要。随着 CDN 的推行，单一云服务商在遇到特殊情况时（如网络中断、服务故障等），会导致静态资源加载失败，从而影响用户体验和业务连续性。</p><p>所以，单靠一个云服务商已经不能满足我们的需求了，我们需要更强的容灾能力。需要对资源进行多云自动切换。</p><p>我们的最终目标是“多CDN架构”，具体实现方式如下</p><p>在源站上配置多个CDN域名，每个CDN域名对应一个CDN服务提供商的节点。这样，不同的CDN节点可以通过不同的域名访问同一个源站。</p><p>基于这种 “多 CDN 架构 ” 来应对单个云厂商在遇到特殊情况时 可以对资源进行自动切换，以保证网站的正常运行。</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191048646.png" alt="image-20240719104837190"></p><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><h4 id="静态资源的分类"><a href="#静态资源的分类" class="headerlink" title="静态资源的分类"></a>静态资源的分类</h4><p>静态资源可以大致分为两种类型：</p><ol><li><p><strong>同步静态资源</strong></p><p>跟随页面组合好之后一起返回 ｜ 接口返回的cdn地址</p><p>特点：能够灵活控制资源cdn域名</p></li><li><p><strong>异步静态资源</strong></p><p>由前端打包工具，建立关联关系后，构建工具异步拉取</p><p>特点：由前端在构建时，根据不同的环境写死的cdn域名，在构建时已经确定，无法在运行时动态替换</p></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>所以我们的实现主要分为三部分：</p><ol><li>如何自动获取加载失败的静态资源（同步加载的 <code>&lt;script&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;img&gt;</code>）并重试</li><li>如何自动获取加载失败的异步脚本并重试</li><li>如何自动获取加载失败的背景图片并重试</li></ol><p>最先，我想到的是动态去修改```__webpack_public_path__ ``（构建时修改，运行时生效）</p><p>伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码中写死的publicCDN地址：</span></span><br><span class="line"><span class="comment">// publicCDN=&quot;https://assets.cdn.xxx.com&quot;</span></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">VUE_APP_BUILD_TAG</span> !== <span class="string">&#x27;localhost&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> target = cdn_replace.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="function"><span class="params">i</span> =&gt;</span> i.<span class="property">origin_cdn</span> === publicCDN)</span><br><span class="line">    __webpack_public_path__ = target ? target[<span class="number">0</span>].<span class="property">target_cdn</span> : publicCDN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：在运行时就会直接替换，不会触发error后再加载，过程比较平滑</p><p>缺点：需要修改构建配置，现在主流是webpack，后续构建工具多了之后，还要对不同的构建做不同的改动</p><p>显然，这不是最优选，不仅需要每个业务中都去修改配置，后续如果升级了其他构建工具，可能还会出现其他预想不到的问题。</p><p>方案二：</p><p>通过挂载全局error事件，捕获资源失败场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, errorHandler, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>然后通过errorHandler来处理对应异步资源的cdn域名替换</p><p>伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">errorHandler</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 拿到报错异步资源的src</span></span><br><span class="line">    <span class="keyword">let</span> source_src = e.<span class="property">target</span>.<span class="property">src</span>;</span><br><span class="line">    <span class="comment">// 获取协议</span></span><br><span class="line">    <span class="keyword">let</span> protocol = source_src.<span class="title function_">split</span>(<span class="string">&#x27;//&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 获取domain</span></span><br><span class="line">    <span class="keyword">let</span> cdn = source_src.<span class="title function_">split</span>(<span class="string">&#x27;//&#x27;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 组合cdn地址</span></span><br><span class="line">    <span class="keyword">let</span> full_domain = <span class="string">`<span class="subst">$&#123;protocol&#125;</span>://<span class="subst">$&#123;cdn&#125;</span>`</span></span><br><span class="line">    <span class="comment">// 找到需要替换的目标地址</span></span><br><span class="line">    <span class="keyword">const</span> target = cdn_replace.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="function"><span class="params">i</span> =&gt;</span> i.<span class="property">origin_cdn</span> === full_domain)</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="comment">// 使用目标cdn替换当前cdn</span></span><br><span class="line">        source_src = source_src.<span class="title function_">replace</span>(full_domain, target[<span class="number">0</span>].<span class="property">target_cdn</span> )</span><br><span class="line">        <span class="comment">// 重新挂载script</span></span><br><span class="line">        <span class="title function_">loadScript</span>(source_src)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">src</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">      scriptEle.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span></span><br><span class="line">      scriptEle.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">      scriptEle.<span class="property">src</span> = src</span><br><span class="line">      scriptEle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      scriptEle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br></pre></td></tr></table></figure><p>优点：无需业务侧的配合，比较通用，既能兼顾老的页面也能支持新的页面</p><p>缺点：会触发资源的error事件之后，再次挂载对应的修改后的cdn</p><p>但这种方式无法对webpack构建的异步产物生效，因为在一个页面有多个异步chunk请求时，<strong>webpack是通过promise.all来处理异步chunk的</strong>，当一个失效后，Promise会进入rejected状态，导致再无法转为其他状态，会阻塞其他异步文件加载。</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191110864.png" alt="image-20240719111038151"></p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191156726.png" alt="image-20240719115621568"></p><p>如何打破这种局面？摆在我们面前的只有两条路：</p><ol><li>使用 webpack 插件，在编译期改写该段代码。</li><li>使用 <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a> 对浏览器的原生方法进行改写。</li></ol><p>为了降低集成成本，我们选择了第二种方案，即在运行时动态改写 <code>document.createElement</code>, <code>Node#appendChild</code> 等方法。</p><p>大体思路：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.createElement</span><br><span class="line">         ↓</span><br><span class="line">HTMLScriptElement(src, onload, onerror)</span><br><span class="line">         ↓</span><br><span class="line">document.head.appendChild</span><br></pre></td></tr></table></figure><p>为了阻止webpack在onerror回掉直接进入reject流程，可以直接对浏览器原生方法的document.createElement以及Node#appendChild等方法进行重写，使其流程变为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.createElement</span><br><span class="line">         ↓</span><br><span class="line">virtualScriptElement(src, onload, onerror)</span><br><span class="line">         ↓</span><br><span class="line">document.head.appendChild</span><br></pre></td></tr></table></figure><p>代码流程图：</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191155486.png" alt="image-20240719115525527"></p><p>优点：只针对script/link等标签的异步资源做拦截，无需担心掉入构建工具的rejected状态，从而影响后续异步资源的加载，也能配合最大重试次数的限制，能够及时终止循环重试。业务侧无需改动，公共模板挂载这段逻辑，并初始化即可。</p><p>看到这也许你会问了，</p><h4 id="为什么要创建-虚拟-element-对象？"><a href="#为什么要创建-虚拟-element-对象？" class="headerlink" title="为什么要创建 虚拟 element 对象？"></a>为什么要创建 虚拟 element 对象？</h4><p>其实直接创建真实element，并且对真实element的onerror和onload做重写也ok，但是会被用户自定义的onerror和onload覆盖掉。</p><p>但是虚拟element就可以解决这个问题，可以将用户设置的onerror和onload挂载到虚拟对象上，通过ignore标识来判断，走用户设置的onerror还是默认重写的onerror。</p><p>那么 <strong>对页面上其他的document.createElement方法有没有影响？</strong></p><p>没有影响，因为仅仅是在创建的时候多了一层包裹对象，本质上还是在调用原生createElement，并且在对创建的元素进行属性设置或者是插入节点动作时，都是取的真实的元素，而非虚拟对象。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// hookElement</span><br><span class="line">&#123;</span><br><span class="line">    originOnerror: fn,  // 原生onerror</span><br><span class="line">    originOnload: fn,    // 原生onload</span><br><span class="line">    realElement: script | link // 真实element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面中可能使用到document.createElement的场景</p><ol><li>Vue中的render函数</li><li>Vue中的自定义指令</li><li>webpack中的动态css/js</li><li>vite中的动态css/js</li><li>用户（开发）操作动态添加DOM元素</li></ol><p>最终效果</p><p>a. 前置条件申请 3 个 c d n 域名</p><p>b. 插入重试逻辑代码，体积2.2kb，可以直接放到页面上，无需使用cdn加载</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191118931.png" alt="image-20240719111848137"></p><p>c. 初始化重试方法</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191119404.png" alt="image-20240719111956627"></p><p>d. 屏蔽原异步js地址</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191121045.png" alt="image-20240719112141930"></p><p>e. 进入异步页面，验证重试</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202407191159657.png" alt="image-20240719115900918"></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用起来非常简单，只需要初始化并传入域名列表即可：</span><br><span class="line"></span><br><span class="line"><span class="comment">// assetsRetryStatistics 中包含所有资源重试的相关信息</span></span><br><span class="line"><span class="keyword">var</span> assetsRetryStatistics = <span class="variable language_">window</span>.<span class="title function_">assetsRetry</span>(&#123;</span><br><span class="line">    <span class="comment">// 域名列表，只有在域名列表中的资源，才会被重试</span></span><br><span class="line">    <span class="comment">// 使用以下配置，当 https://your.first.domain/js/1.js 加载失败时</span></span><br><span class="line">    <span class="comment">// 会自动使用 https://your.second.domain/namespace/js/1.js 重试</span></span><br><span class="line">    <span class="attr">domain</span>: [<span class="string">&#x27;your.first.domain&#x27;</span>, <span class="string">&#x27;your.second.domain/namespace&#x27;</span>],</span><br><span class="line">    <span class="comment">// 可选，最大重试次数，默认 3 次</span></span><br><span class="line">    <span class="attr">maxRetryCount</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 可选，通过该参数可自定义 URL 的转换方式</span></span><br><span class="line">    <span class="attr">onRetry</span>: <span class="keyword">function</span>(<span class="params">currentUrl, originalUrl, statistics</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUrl</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对于给定资源，要么调用 onSuccess ，要么调用 onFail，标识其最终的加载状态</span></span><br><span class="line">    <span class="comment">// 加载详细信息（成功的 URL、失败的 URL 列表、重试次数）</span></span><br><span class="line">    <span class="comment">// 可以通过访问 assetsRetryStatistics[currentUrl] 来获取</span></span><br><span class="line">    <span class="attr">onSuccess</span>: <span class="keyword">function</span>(<span class="params">currentUrl</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentUrl, assetsRetryStatistics[currentUrl])</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onFail</span>: <span class="keyword">function</span>(<span class="params">currentUrl</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentUrl, assetsRetryStatistics[currentUrl])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用以上代码初始化完毕后，以下内容便获得了加载失败重试的能力：</p><ul><li> 所有在 <code>html</code> 中使用 <code>&lt;script&gt;</code> 标签引用的脚本</li><li> 所有在 <code>html</code> 中使用 <code>&lt;link&gt;</code> 标签引用的样式 （跨域 CSS 需要正确<a href="https://github.com/Nikaple/assets-retry/blob/master/README-cn.md#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">配置</a>）</li><li> 所有在 <code>html</code> 中使用 <code>&lt;img&gt;</code> 标签引用的图片</li><li> 所有使用 <code>document.createElement(&#39;script&#39;)</code> 加载的脚本（如 webpack 的<a href="https://webpack.docschina.org/guides/code-splitting/#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-dynamic-imports-">动态导入</a>）</li><li> 所有 <code>css</code> 中（包含同步与异步）使用的 <code>background-image</code> 图片</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>assetsRetry</code> 接受一个配置对象 <code>AssetsRetryOptions</code> ，其类型签名为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">AssetsRetryOptions</span> &#123;</span><br><span class="line">    <span class="attr">maxRetryCount</span>: number  <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="attr">onRetry</span>: <span class="title class_">RetryFunction</span> <span class="comment">// 每次重试时执行的函数</span></span><br><span class="line">    <span class="attr">onSuccess</span>: <span class="title class_">SuccessFunction</span> <span class="comment">// 在域名列表内的资源最终加载成功时执行</span></span><br><span class="line">    <span class="attr">onFail</span>: <span class="title class_">FailFunction</span> <span class="comment">// 在域名列表内的资源最终加载失败时执行：</span></span><br><span class="line">    <span class="attr">domain</span>: <span class="title class_">Domain</span> <span class="comment">// 域名列表</span></span><br><span class="line">&#125;</span><br><span class="line">type <span class="title class_">RetryFunction</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    currentUrl: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    originalUrl: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    retryCollector: <span class="literal">null</span> | RetryStatistics</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> string | <span class="literal">null</span></span><br><span class="line">interface <span class="title class_">RetryStatistics</span> &#123;</span><br><span class="line">    <span class="attr">retryTimes</span>: number</span><br><span class="line">    <span class="attr">succeeded</span>: string[]</span><br><span class="line">    <span class="attr">failed</span>: string[]</span><br><span class="line">&#125;</span><br><span class="line">type <span class="title class_">SuccessFunction</span> = <span class="function">(<span class="params">currentUrl: string</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">type <span class="title class_">FailFunction</span> = <span class="function">(<span class="params">currentUrl: string</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">type <span class="title class_">Domain</span> = string[] | &#123; [<span class="attr">x</span>: string]: string &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;静态资源的快速加载和高可用性对用户体验至关重要。随着 CDN 的推行，单一云服务商在遇到特殊情况时（如网络中断、服务故障等），会导致静态资源</summary>
      
    
    
    
    <category term="work" scheme="https://monthlygirl.github.io/categories/work/"/>
    
    
    <category term="work" scheme="https://monthlygirl.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>KOA 洋葱模型</title>
    <link href="https://monthlygirl.github.io/posts/node-koa.html"/>
    <id>https://monthlygirl.github.io/posts/node-koa.html</id>
    <published>2024-03-20T08:39:07.000Z</published>
    <updated>2024-03-20T08:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KOA-洋葱模型"><a href="#KOA-洋葱模型" class="headerlink" title="KOA 洋葱模型"></a>KOA 洋葱模型</h1><p>今天分享一道面试题【手写 KOA 洋葱模型】<br>学习本文你将获得：</p><ol><li>什么是 KOA 洋葱模型</li><li>为什么 KOA 使用洋葱模型</li><li>如何实现 KOA 洋葱模型</li></ol><h2 id="1-什么是-KOA-洋葱模型"><a href="#1-什么是-KOA-洋葱模型" class="headerlink" title="1. 什么是 KOA 洋葱模型"></a>1. 什么是 KOA 洋葱模型</h2><p>KOA 是一个轻量的 Node.js 框架，洋葱模型是它的设计理念和核心实现思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KOA-洋葱模型&quot;&gt;&lt;a href=&quot;#KOA-洋葱模型&quot; class=&quot;headerlink&quot; title=&quot;KOA 洋葱模型&quot;&gt;&lt;/a&gt;KOA 洋葱模型&lt;/h1&gt;&lt;p&gt;今天分享一道面试题【手写 KOA 洋葱模型】&lt;br&gt;学习本文你将获得：&lt;/p&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="node" scheme="https://monthlygirl.github.io/categories/node/"/>
    
    
    <category term="node" scheme="https://monthlygirl.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>关于一次上传密钥泄露引发的网站奔溃...</title>
    <link href="https://monthlygirl.github.io/posts/work-upload.html"/>
    <id>https://monthlygirl.github.io/posts/work-upload.html</id>
    <published>2024-03-18T12:39:37.000Z</published>
    <updated>2024-03-18T12:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于一次上传密钥泄露引发的网站奔溃…"><a href="#关于一次上传密钥泄露引发的网站奔溃…" class="headerlink" title="关于一次上传密钥泄露引发的网站奔溃…"></a>关于一次上传密钥泄露引发的网站奔溃…</h1><p>某天，雪碧正准备下班回家，心想哎呀呀，还有几天就可以回家过年了。这时，突然来了个电话：雪碧，雪碧，网页突然打不开了，快看看，用户要炸锅了。</p><p>雪碧内心一惊，这么吓人，打开了刚放进包里的电脑，打开公司业务网站一看<img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202403182054140.png" alt="image-20240318205435268"></p><p>嗯？找不到服务器 ip 地址，那是 DNS 解析出现问题了，雪碧细品下就抓起电话开始摇人。</p><p>联系到运维查看 DNS 解析，发现所有 DNS 解析都是空的，又查看 WHOIS 后，发现 Domain 状态被 clientHold了，这是为啥呢？</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202403182102508.png" alt="image-20240318210128721"></p><p>登录云厂商网站一看，发现云厂商发了封公告【违规域名暂停解析并禁止转移通知】。这是为啥，俺们可都是21世纪好公民。</p><p>通知里提供了违规的 URL，是个上传到 cos 的 pdf 文件，打开一看，嘿，不是个pdf文件，是个欺诈网页。有人利用漏洞上传文件，篡改成 html 网页 到处散播。</p><p>同时看到在 cos 图床中还发现不止这一个文件，这怎么行，流传出去可要祸害不少人呐，赶紧先采取了紧急措施，将所有关联文件写设置了私有读写先，并关闭上传源头的 cos 上传，然后加急联系云厂商同事，帮忙解封域名。</p><h1 id="事后复盘"><a href="#事后复盘" class="headerlink" title="事后复盘"></a>事后复盘</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>不知道大家有没有疑问，为什么上传的 pdf 文件变成了 html 网页？</p><p>雪碧那是打开pdf 一看，header 头被篡改了，正常来说Content-type 是 pdf</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202403182119791.png" alt="正常来说Content-type 是 pdf"></p><p>但被篡改成了 text/html</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202403182120804.png" alt="被篡改成了 text/html"></p><p>这是上传流程中密钥泄露了！ 正好雪碧在重构上传模块，但泄露这个地方的上传还没全部接入，中招了。</p><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><p>借此机会，雪碧又重新复习了遍 DNS 解析<br>以百度为例，DNS 解析过程如下：</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://raw.githubusercontent.com/MonthlyGirl/images/master/markdown/202403182205307.png" alt="image-20240318220512257"></p><p>经过这次事件后，对 DNS 解析又清晰了，密钥安全也是是重中之重，接下来会出篇文章记录如何重构上传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于一次上传密钥泄露引发的网站奔溃…&quot;&gt;&lt;a href=&quot;#关于一次上传密钥泄露引发的网站奔溃…&quot; class=&quot;headerlink&quot; title=&quot;关于一次上传密钥泄露引发的网站奔溃…&quot;&gt;&lt;/a&gt;关于一次上传密钥泄露引发的网站奔溃…&lt;/h1&gt;&lt;p&gt;某天，雪碧正</summary>
      
    
    
    
    <category term="work" scheme="https://monthlygirl.github.io/categories/work/"/>
    
    
    <category term="work" scheme="https://monthlygirl.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://monthlygirl.github.io/posts/index.html"/>
    <id>https://monthlygirl.github.io/posts/index.html</id>
    <published>2024-03-12T13:56:55.797Z</published>
    <updated>2024-03-12T13:56:55.797Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 函数的arguments为什么不是数组？如何转化成数组？<br>date: 2022-03-12 21:56:55<br>tags: [arguments, 类数组]<br>categories: JavaScript<br>coverWidth: 100%<br>coverHeight: 500<br>cover: <a href="https://t.mwm.moe/fj/">https://t.mwm.moe/fj/</a><br>top_img: false<br>url_name: arguments</p><hr><p>因为argument是一个对象，只不过它的属性从0开始排，依次为0，1，2…最后还有callee和length属性。我们也把这样的对象称为类数组。</p><p>常见的类数组还有：</p><ul><li><ol><li>   用getElementByTagName/ClassName/Name（）获得的HTMLCollection</li></ol></li><li><ol start="2"><li>   用querySlector获得的nodeList</li></ol></li></ul><p>那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？</p><h2 id="1-Array-prototype-slice-call"><a href="#1-Array-prototype-slice-call" class="headerlink" title="1. Array.prototype.slice.call()"></a>1. Array.prototype.slice.call()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur));<span class="comment">//args可以调用数组原生的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.    Array.from()"></a>2.    Array.from()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur));<span class="comment">//args可以调用数组原生的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这种方法也可以用来转换Set和Map哦！</p><h2 id="3-ES6展开运算符"><a href="#3-ES6展开运算符" class="headerlink" title="3. ES6展开运算符"></a>3. ES6展开运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur));<span class="comment">//args可以调用数组原生的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="4-利用concat-apply"><a href="#4-利用concat-apply" class="headerlink" title="4. 利用concat+apply"></a>4. 利用concat+apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>);<span class="comment">//apply方法会把第二个参数展开</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur));<span class="comment">//args可以调用数组原生的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>当然，最原始的方法就是再创建一个数组，用for循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 函数的arguments为什么不是数组？如何转化成数组？&lt;br&gt;date: 2022-03-12 21:56:55&lt;br&gt;tags: [arguments, 类数组]&lt;br&gt;categories: JavaScript&lt;br&gt;coverWidth: </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP1.1 如何解决 HTTP 的对头阻塞问题</title>
    <link href="https://monthlygirl.github.io/posts/HTTP1.1.html"/>
    <id>https://monthlygirl.github.io/posts/HTTP1.1.html</id>
    <published>2024-03-12T13:22:12.000Z</published>
    <updated>2024-03-12T13:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP1.1 如何解决 HTTP 的队头阻塞问题？</p><h1 id="什么是-HTTP-队头阻塞？"><a href="#什么是-HTTP-队头阻塞？" class="headerlink" title="什么是 HTTP 队头阻塞？"></a>什么是 HTTP 队头阻塞？</h1><p>HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p><h2 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h2><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p><h2 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h2><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p><p>比如 content1.monthly.com 、content2.monthly.com。</p><p>这样一个<code>monthly.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTTP1.1 如何解决 HTTP 的队头阻塞问题？&lt;/p&gt;
&lt;h1 id=&quot;什么是-HTTP-队头阻塞？&quot;&gt;&lt;a href=&quot;#什么是-HTTP-队头阻塞？&quot; class=&quot;headerlink&quot; title=&quot;什么是 HTTP 队头阻塞？&quot;&gt;&lt;/a&gt;什么是 HTTP 队</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/tags/HTTP/"/>
    
    <category term="浏览器" scheme="https://monthlygirl.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入URL到显示页面的经历了什么?? -- 渲染过程</title>
    <link href="https://monthlygirl.github.io/posts/HTTP_PARSE.html"/>
    <id>https://monthlygirl.github.io/posts/HTTP_PARSE.html</id>
    <published>2024-03-12T12:49:16.000Z</published>
    <updated>2024-03-12T12:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了浏览器<code>解析</code>的过程,其中包含<code>构建DOM</code>、<code>样式计算</code>和<code>构建布局树</code>。</p><p>接下来就来拆解下一个过程——<code>渲染</code>。分为以下几个步骤:</p><ul><li>建立<code>图层树</code>(<code>Layer Tree</code>)</li><li>生成<code>绘制列表</code></li><li>生成<code>图块</code>并<code>栅格化</code></li><li>显示器显示内容</li></ul><h2 id="一、建图层树"><a href="#一、建图层树" class="headerlink" title="一、建图层树"></a>一、建图层树</h2><p>如果你觉得现在<code>DOM节点</code>也有了，样式和位置信息也都有了，可以开始绘制页面了，那你就错了。</p><p>因为你考虑掉了另外一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。</p><p>为了解决如上所述的问题，浏览器在构建完<code>布局树</code>之后，还会对特定的节点进行分层，构建一棵<code>图层树</code>(<code>Layer Tree</code>)。</p><p>那这棵图层树是根据什么来构建的呢？</p><p>一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为<strong>合成层</strong>)。那什么时候会提升为一个单独的合成层呢？</p><p>有两种情况需要分别讨论，一种是<strong>显式合成</strong>，一种是<strong>隐式合成</strong>。</p><h3 id="显式合成"><a href="#显式合成" class="headerlink" title="显式合成"></a>显式合成</h3><p>下面是<code>显式合成</code>的情况:</p><p>一、 拥有<strong>层叠上下文</strong>的节点。</p><p>层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:</p><ol><li>HTML根元素本身就具有层叠上下文。</li><li>普通元素设置<strong>position不为static</strong>并且<strong>设置了z-index属性</strong>，会产生层叠上下文。</li><li>元素的 <strong>opacity</strong> 值不是 1</li><li>元素的 <strong>transform</strong> 值不是 none</li><li>元素的 <strong>filter</strong> 值不是 none</li><li>元素的 <strong>isolation</strong> 值是isolate</li><li><strong>will-change</strong>指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)</li></ol><p>二、需要<strong>剪裁</strong>的地方。</p><p>比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。</p><h3 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h3><p>接下来是<code>隐式合成</code>，简单来说就是<code>层叠等级低</code>的节点被提升为单独的图层之后，那么<code>所有层叠等级比它高</code>的节点<strong>都会</strong>成为一个单独的图层。</p><p>这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个<code>z-index</code>比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是<strong>层爆炸</strong>的原理。这里有一个具体的例子，<a href="https://segmentfault.com/a/1190000014520786">点击打开</a>。</p><p>值得注意的是，当需要<code>repaint</code>时，只需要<code>repaint</code>本身，而不会影响到其他的层。</p><h2 id="二、生成绘制列表"><a href="#二、生成绘制列表" class="headerlink" title="二、生成绘制列表"></a>二、生成绘制列表</h2><p>接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框……然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。</p><p>这里我以百度首页为例，大家可以在 Chrome 开发者工具中在设置栏中展开 <code>more tools</code>, 然后选择<code>Layers</code>面板，就能看到下面的绘制列表:</p><h2 id="三、生成图块和生成位图"><a href="#三、生成图块和生成位图" class="headerlink" title="三、生成图块和生成位图"></a>三、生成图块和生成位图</h2><p>现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫<strong>合成线程</strong>。</p><p>绘制列表准备好了之后，渲染进程的主线程会给<code>合成线程</code>发送<code>commit</code>消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。</p><p>首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层<strong>分块</strong>。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。</p><p>因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个<strong>低分辨率</strong>的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。</p><p>顺便提醒一点，渲染进程中专门维护了一个<strong>栅格化线程池</strong>，专门负责把<strong>图块</strong>转换为<strong>位图数据</strong>。</p><p>然后合成线程会选择视口附近的<strong>图块</strong>，把它交给<strong>栅格化线程池</strong>生成位图。</p><p>生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给<code>合成线程</code>。</p><h2 id="四、显示器显示内容"><a href="#四、显示器显示内容" class="headerlink" title="四、显示器显示内容"></a>四、显示器显示内容</h2><p>栅格化操作完成后，<strong>合成线程</strong>会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。</p><p>浏览器进程中的<code>viz组件</code>接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。</p><p>无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的<strong>前缓冲区</strong>。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到<strong>后缓冲区</strong>，然后系统自动将<code>前缓冲区</code>和<code>后缓冲区</code>对换位置，如此循环更新。</p><p>看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一节介绍了浏览器&lt;code&gt;解析&lt;/code&gt;的过程,其中包含&lt;code&gt;构建DOM&lt;/code&gt;、&lt;code&gt;样式计算&lt;/code&gt;和&lt;code&gt;构建布局树&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来就来拆解下一个过程——&lt;code&gt;渲染&lt;/code&gt;。分为以下几个步骤:&lt;/</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="浏览器" scheme="https://monthlygirl.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入URL到显示页面的经历了什么?? -- 浏览器解析篇</title>
    <link href="https://monthlygirl.github.io/posts/HTTP_RENDER.html"/>
    <id>https://monthlygirl.github.io/posts/HTTP_RENDER.html</id>
    <published>2024-03-12T12:38:59.000Z</published>
    <updated>2024-03-12T12:38:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>完成了网络请求和响应，如果响应头中<code>Content-Type</code>的值是<code>text/html</code>，那么接下来就是浏览器的<code>解析</code>和<code>渲染</code>工作了。</p><p>首先来介绍解析部分，主要分为以下几个步骤:</p><ul><li>构建 <code>DOM</code>树</li><li><code>样式</code>计算</li><li>生成<code>布局树</code>(<code>Layout Tree</code>)</li></ul><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>由于浏览器无法直接理解<code>HTML字符串</code>，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是<code>DOM树</code>。<code>DOM树</code>本质上是一个以<code>document</code>为根节点的多叉树。</p><p>那通过什么样的方式来进行解析呢？</p><h3 id="HTML文法的本质"><a href="#HTML文法的本质" class="headerlink" title="HTML文法的本质"></a>HTML文法的本质</h3><p>首先，我们应该清楚把握一点: HTML 的文法并不是<code>上下文无关文法</code>。</p><p>这里，有必要讨论一下什么是<code>上下文无关文法</code>。</p><p>在计算机科学的<strong>编译原理</strong>学科中，有非常明确的定义:</p><blockquote><p>若一个形式文法G = (N, Σ, P, S) 的产生式规则都取如下的形式：V-&gt;w，则叫上下文无关语法。其中 V∈N ，w∈(N∪Σ)* 。</p></blockquote><p>其中把 G = (N, Σ, P, S) 中各个参量的意义解释一下:</p><ol><li>N 是<strong>非终结符</strong>(顾名思义，就是说最后一个符号不是它, 下面同理)集合。</li><li>Σ 是<strong>终结符</strong>集合。</li><li>P 是开始符，它必须属于 N ，也就是非终结符。</li><li>S 就是不同的产生式的集合。如 S -&gt; aSb 等等。</li></ol><p>通俗一点讲，<code>上下文无关的文法</code>就是说这个文法中所有产生式的左边都是一个非终结符。</p><p>看到这里，如果还有一点懵圈，我举个例子你就明白了。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br></pre></td></tr></table></figure><p>这个文法中，每个产生式左边都会有一个非终结符，这就是<code>上下文无关的文法</code>。在这种情况下，<code>xBy</code>一定是可以规约出<code>xAy</code>的。</p><p>我们下面看看看一个反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aA -&gt; B</span><br><span class="line">Aa -&gt; B</span><br></pre></td></tr></table></figure><p>这种情况就是不是<code>上下文无关的文法</code>，当遇到<code>B</code>的时候，我们不知道到底能不能规约出<code>A</code>，取决于左边或者右边是否有<code>a</code>存在，也就是说和上下文有关。</p><p>关于它为什么是<code>非上下文无关文法</code>，首先需要让大家注意的是，规范的 HTML 语法，是符合<code>上下文无关文法</code>的，能够体现它<code>非上下文无关</code>的是<strong>不标准的语法</strong>。在此我仅举一个反例即可证明。</p><p>比如解析器扫描到<code>form</code>标签的时候，<strong>上下文无关文法</strong>的处理方式是直接创建对应 form 的 DOM 对象，而真实的 HTML5 场景中却不是这样，解析器会查看 <code>form</code> 的上下文，如果这个 <code>form</code> 标签的父标签也是 <code>form</code>, 那么<strong>直接跳过</strong>当前的 <code>form</code> 标签，否则才创建 DOM 对象。</p><p>常规的编程语言都是<strong>上下文无关</strong>的，而HTML却相反，也正是它<strong>非上下文无关</strong>的特性，决定了<code>HTML Parser</code>并不能使用常规编程语言的解析器来完成，需要另辟蹊径。</p><h3 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h3><p>HTML5 <a href="https://html.spec.whatwg.org/multipage/parsing.html">规范</a>详细地介绍了解析算法。这个算法分为两个阶段:</p><ol><li>标记化。</li><li>建树。</li></ol><p>对应的两个过程就是<strong>词法分析</strong>和<strong>语法分析</strong>。</p><h4 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h4><p>这个算法输入为<code>HTML文本</code>，输出为<code>HTML标记</code>，也成为<strong>标记生成器</strong>。其中运用<strong>有限自动状态机</strong>来完成。即在当当前状态下，接收一个或多个字符，就会更新到下一个状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello sanyuan</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过一个简单的例子来演示一下<code>标记化</code>的过程。</p><p>遇到<code>&lt;</code>, 状态为<strong>标记打开</strong>。</p><p>接收<code>[a-z]</code>的字符，会进入<strong>标记名称状态</strong>。</p><p>这个状态一直保持，直到遇到<code>&gt;</code>，表示标记名称记录完成，这时候变为<strong>数据状态</strong>。</p><p>接下来遇到<code>body</code>标签做同样的处理。</p><p>这个时候<code>html</code>和<code>body</code>的标记都记录好了。</p><p>现在来到&lt;body&gt;中的&gt;，进入<strong>数据状态</strong>，之后保持这样状态接收后面的字符<strong>hello sanyuan</strong>。</p><p>接着接收 &lt;/body&gt; 中的<code>&lt;</code>，回到<strong>标记打开</strong>, 接收下一个<code>/</code>后，这时候会创建一个<code>end tag</code>的token。</p><p>随后进入<strong>标记名称状态</strong>, 遇到<code>&gt;</code>回到<strong>数据状态</strong>。</p><p>接着以同样的样式处理 &lt;/body&gt;。</p><h4 id="建树算法"><a href="#建树算法" class="headerlink" title="建树算法"></a>建树算法</h4><p>之前提到过，DOM 树是一个以<code>document</code>为根节点的多叉树。因此解析器首先会创建一个<code>document</code>对象。标记生成器会把每个标记的信息发送给<strong>建树器</strong>。<strong>建树器</strong>接收到相应的标记时，会<strong>创建对应的 DOM 对象</strong>。创建这个<code>DOM对象</code>后会做两件事情:</p><ol><li>将<code>DOM对象</code>加入 DOM 树中。</li><li>将对应标记压入存放开放(与<code>闭合标签</code>意思对应)元素的栈中。</li></ol><p>还是拿下面这个例子说:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello sanyuan</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，状态为<strong>初始化状态</strong>。</p><p>接收到标记生成器传来的<code>html</code>标签，这时候状态变为<strong>before html状态</strong>。同时创建一个<code>HTMLHtmlElement</code>的 DOM 元素, 将其加到<code>document</code>根对象上，并进行压栈操作。</p><p>接着状态自动变为<strong>before head</strong>, 此时从标记生成器那边传来<code>body</code>，表示并没有<code>head</code>, 这时候<strong>建树器</strong>会自动创建一个<strong>HTMLHeadElement</strong>并将其加入到<code>DOM树</code>中。</p><p>现在进入到<strong>in head</strong>状态, 然后直接跳到<strong>after head</strong>。</p><p>现在<strong>标记生成器</strong>传来了<code>body</code>标记，创建<strong>HTMLBodyElement</strong>, 插入到<code>DOM</code>树中，同时压入开放标记栈。</p><p>接着状态变为<strong>in body</strong>，然后来接收后面一系列的字符: <strong>Hello sanyuan</strong>。接收到第一个字符的时候，会创建一个<strong>Text</strong>节点并把字符插入其中，然后把<strong>Text</strong>节点插入到 DOM 树中<code>body元素</code>的下面。随着不断接收后面的字符，这些字符会附在<strong>Text</strong>节点上。</p><p>现在，<strong>标记生成器</strong>传过来一个<code>body</code>的结束标记，进入到<strong>after body</strong>状态。</p><p><strong>标记生成器</strong>最后传过来一个<code>html</code>的结束标记, 进入到<strong>after after body</strong>的状态，表示解析过程到此结束。</p><h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><p>讲到<code>HTML5</code>规范，就不得不说它强大的<strong>宽容策略</strong>, 容错能力非常强，虽然大家褒贬不一，不过我想作为一名资深的前端工程师，有必要知道<code>HTML Parser</code>在容错方面做了哪些事情。</p><p>接下来是 WebKit 中一些经典的容错示例，发现有其他的也欢迎来补充。</p><ol><li><p>使用&lt;/br&gt;而不是&lt;br&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;<span class="built_in">isCloseTag</span>(brTag) &amp;&amp; m_document-&gt;<span class="built_in">inCompatMode</span>()) &#123;</span><br><span class="line">  <span class="built_in">reportError</span>(MalformedBRError);</span><br><span class="line">  t-&gt;beginTag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部换为&lt;br&gt;的形式。</p></li><li><p>表格离散</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>WebKit</code>会自动转换为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表单元素嵌套</p></li></ol><p>这时候直接忽略里面的<code>form</code>。</p><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>关于CSS样式，它的来源一般是三种: </p><ol><li><strong>link标签引用</strong></li><li><strong>style标签中的样式</strong></li><li><strong>元素的内嵌style属性</strong></li></ol><h3 id="格式化样式表"><a href="#格式化样式表" class="headerlink" title="格式化样式表"></a>格式化样式表</h3><p>首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。</p><p>这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。</p><p>在浏览器控制台能够通过<code>document.styleSheets</code>来查看这个最终的结构。当然，这个结构包含了以上三种CSS来源，为后面的样式操作提供了基础。</p><h3 id="标准化样式属性"><a href="#标准化样式属性" class="headerlink" title="标准化样式属性"></a>标准化样式属性</h3><p>有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如<code>em</code>-&gt;<code>px</code>,<code>red</code>-&gt;<code>#ff0000</code>,<code>bold</code>-&gt;<code>700</code>等等。</p><h3 id="计算每个节点的具体样式"><a href="#计算每个节点的具体样式" class="headerlink" title="计算每个节点的具体样式"></a>计算每个节点的具体样式</h3><p>样式已经被<code>格式化</code>和<code>标准化</code>,接下来就可以计算每个节点的具体样式信息了。</p><p>其实计算的方式也并不复杂，主要就是两个规则: <strong>继承</strong>和<strong>层叠</strong>。</p><p>每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫<code>UserAgent样式</code>。这就是继承规则，非常容易理解。</p><p>然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象，看过《CSS世界》的同学应该对此深有体会，具体的层叠规则属于深入 CSS 语言的范畴，这里就不过多介绍了。</p><p>不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到<code>window.computedStyle</code>当中，也就是可以通过JS来获取计算后的样式，非常方便。</p><h2 id="生成布局树"><a href="#生成布局树" class="headerlink" title="生成布局树"></a>生成布局树</h2><p>现在已经生成了<code>DOM树</code>和<code>DOM样式</code>，接下来要做的就是通过浏览器的布局系统<code>确定元素的位置</code>，也就是要生成一棵<code>布局树</code>(Layout Tree)。</p><p>布局树生成的大致工作如下:</p><ol><li>遍历生成的 DOM 树节点，并把他们添加到<code>布局树中</code>。</li><li>计算布局树节点的坐标位置。</li></ol><p>值得注意的是，这棵布局树值包含可见元素，对于 <code>head</code>标签和设置了<code>display: none</code>的元素，将不会被放入其中。</p><p>有人说首先会生成<code>Render Tree</code>，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成<code>Render Tree</code>的过程了。而布局树的信息已经非常完善，完全拥有<code>Render Tree</code>的功能。</p><p>之所以不讲布局的细节，是因为它过于复杂，一一介绍会显得文章过于臃肿，不过大部分情况下我们只需要知道它所做的工作<strong>是什么</strong>即可，如果想深入其中的原理，知道它是<strong>如何来做的</strong>，我强烈推荐你去读一读人人FED团队的文章<a href="https://www.rrfed.com/2017/02/26/chrome-layout/">从Chrome源码看浏览器如何layout布局</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理一下这一节的主要脉络:<br><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.cdn.xiaoeknow.com/app1yuxgivl3826/image/b_u_61de5084a68c2_65gDgqWw/e5wpxtltodauc6.jpg?imageView2/2/w/200/q/60"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;完成了网络请求和响应，如果响应头中&lt;code&gt;Content-Type&lt;/code&gt;的值是&lt;code&gt;text/html&lt;/code&gt;，那么接下来就是浏览器的&lt;code&gt;解析&lt;/code&gt;和&lt;code&gt;渲染&lt;/code&gt;工作了。&lt;/p&gt;
&lt;p&gt;首先来介绍解析部分，主要分为以</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="浏览器渲染过程" scheme="https://monthlygirl.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 为什么传输更安全？（传统 RSA）</title>
    <link href="https://monthlygirl.github.io/posts/HTTPS_RSA.html"/>
    <id>https://monthlygirl.github.io/posts/HTTPS_RSA.html</id>
    <published>2024-03-01T13:10:30.000Z</published>
    <updated>2024-03-01T13:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈到<code>HTTPS</code>, 就不得不谈到与之相对的<code>HTTP</code>。<code>HTTP</code>的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过<code>WIFI路由器</code>、<code>运营商</code>和<code>目标服务器</code>，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的<strong>中间人攻击</strong>。</p><p>为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。</p><p><code>HTTPS</code>并不是一个新的协议, 而是一个加强版的<code>HTTP</code>。其原理是在<code>HTTP</code>和<code>TCP</code>之间建立了一个中间层，当<code>HTTP</code>和<code>TCP</code>通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给<code>TCP</code>, 响应的，<code>TCP</code>必须将数据包解密，才能传给上面的<code>HTTP</code>。这个中间层也叫<code>安全层</code>。<code>安全层</code>的核心就是对数据<code>加解密</code>。</p><p>接下来我们就来剖析一下<code>HTTPS</code>的加解密是如何实现的。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先需要理解<code>对称加密</code>和<code>非对称加密</code>的概念，然后讨论两者应用后的效果如何。</p><p><code>对称加密</code>是最简单的方式，指的是<code>加密</code>和<code>解密</code>用的是<strong>同样的密钥</strong>。</p><p>而对于<code>非对称加密</code>，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。</p><h3 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h3><p>接着我们来谈谈<code>浏览器</code>和<code>服务器</code>进行协商加解密的过程。</p><p>首先，浏览器会给服务器发送一个随机数<code>client_random</code><br>和一个加密的方法列表。</p><p>服务器接收后给浏览器返回另一个随机数<code>server_random</code>和加密方法。</p><p>现在，两者拥有三样相同的凭证: <code>client_random</code>、<code>server_random</code>和加密方法。</p><p>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的<code>暗号</code>。</p><h3 id="各自应用的效果"><a href="#各自应用的效果" class="headerlink" title="各自应用的效果"></a>各自应用的效果</h3><p>如果用<code>对称加密</code>的方式，那么第三方可以在中间获取到<code>client_random</code>、<code>server_random</code>和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。</p><p>那能不能只用<code>非对称加密</code>呢？理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。后面有机会给大家分享一下 RSA 非对称加密算法的原理，大家就会有更加直观的认识，这里我们先不深究。</p><h2 id="对称加密和非对称加密的结合"><a href="#对称加密和非对称加密的结合" class="headerlink" title="对称加密和非对称加密的结合"></a>对称加密和非对称加密的结合</h2><p>可以发现，对称加密和非对称加密，只用前者会有安全隐患，只用后者性能消耗又太大。那我们能不能把两者结合，保证性能的同时又能保证安全呢？</p><p>其实是可以的，演示一下整个流程：</p><ol><li>浏览器向服务器发送<code>client_random</code>和加密方法列表。</li><li>服务器接收到，返回<code>server_random</code>、加密方法以及公钥。</li><li>浏览器接收，接着生成另一个随机数<code>pre_random</code>, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</li><li>服务器用公钥解密这个被加密后的<code>pre_random</code>。</li></ol><p>现在浏览器和服务器有三样相同的凭证:<code>client_random</code>、<code>server_random</code>和<code>pre_random</code>。然后两者用相同的加密方法混合这三个随机数，生成最终的<code>密钥</code>。</p><p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用<code>对称加密</code>。</p><p>这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而<strong>拿不到pre_random</strong>，也就无法生成最终的密钥了。</p><p>回头比较一下和单纯的使用<strong>非对称加密</strong>, 这种方式做了什么改进呢？本质上是<strong>防止了私钥加密的数据外传</strong>。单独使用<strong>非对称加密</strong>，最大的漏洞在于服务器传数据给浏览器只能用<code>私钥</code>加密，这是危险产生的根源。利用<code>对称和非对称</code>加密结合的方式，就防止了这一点，从而保证了安全。</p><h2 id="添加数字证书"><a href="#添加数字证书" class="headerlink" title="添加数字证书"></a>添加数字证书</h2><p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p><p>事实上<code>HTTPS</code>在上述<code>结合对称和非对称加密</code>的基础上，又添加了<code>数字证书认证</code>的步骤。其目的就是让服务器证明自己的身份。</p><h3 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h3><p>为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫<code>CA</code>(<code>Certificate Authority</code>), 认证通过后 CA 会给服务器颁发<strong>数字证书</strong>。</p><p>这个数字证书有两个作用: </p><ol><li>服务器向浏览器证明自己的身份。</li><li>把公钥传给浏览器。</li></ol><p>这个验证的过程发生在什么时候呢？</p><p>当服务器传送<code>server_random</code>、加密方法的时候，顺便会带上<code>数字证书</code>(包含了<code>公钥</code>), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p><p>现在我们来梳理一下<code>HTTPS</code>最终的加解密过程:<br><img :src="$withBase('/week12/1.jpg')" alt="project"></img></p><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><p>浏览器拿到数字证书后，如何来对证书进行认证呢？</p><p>首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到<code>信息A</code>，然后用公钥解密明文内容得到<code>信息B</code>，两份信息做比对，一致则表示认证合法。</p><p>当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS并不是一个新的协议, 它在<code>HTTP</code>和<code>TCP</code>的传输中建立了一个安全层，利用<code>对称加密</code>和<code>非对称机密</code>结合数字证书认证的方式，让传输过程的安全性大大提高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谈到&lt;code&gt;HTTPS&lt;/code&gt;, 就不得不谈到与之相对的&lt;code&gt;HTTP&lt;/code&gt;。&lt;code&gt;HTTP&lt;/code&gt;的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过&lt;code&gt;</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="浏览器安全" scheme="https://monthlygirl.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
    <category term="HTTPS" scheme="https://monthlygirl.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的特点</title>
    <link href="https://monthlygirl.github.io/posts/http_trait.html"/>
    <id>https://monthlygirl.github.io/posts/http_trait.html</id>
    <published>2024-02-27T13:11:11.000Z</published>
    <updated>2024-02-27T13:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h2><p>HTTP 的特点概括如下:</p><ol><li><p> 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li><li><p> 可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p></li><li><p> 请求-应答。也就是<code>一发一收</code>、<code>有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</p></li><li><p> 无状态。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p></li></ol><h2 id="HTTP-缺点"><a href="#HTTP-缺点" class="headerlink" title="HTTP 缺点"></a>HTTP 缺点</h2><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><h3 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h3><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p><p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><h3 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h3><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP-特点&quot;&gt;&lt;a href=&quot;#HTTP-特点&quot; class=&quot;headerlink&quot; title=&quot;HTTP 特点&quot;&gt;&lt;/a&gt;HTTP 特点&lt;/h2&gt;&lt;p&gt;HTTP 的特点概括如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 灵活可扩展，主要体现在两个方面。一个是</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 报文结构是怎样的？</title>
    <link href="https://monthlygirl.github.io/posts/HTTP_BODY.html"/>
    <id>https://monthlygirl.github.io/posts/HTTP_BODY.html</id>
    <published>2024-02-22T14:09:55.000Z</published>
    <updated>2024-02-22T14:09:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-报文结构是怎样的？"><a href="#HTTP-报文结构是怎样的？" class="headerlink" title="HTTP 报文结构是怎样的？"></a>HTTP 报文结构是怎样的？</h1><p>对于 TCP 而言，在传输的时候分为两个部分:<strong>TCP头</strong>和<strong>数据部分</strong>。</p><p>而 HTTP 类似，也是<code>header + body</code>的结构，具体而言:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始行 + 头部 + 空行 + 实体</span><br></pre></td></tr></table></figure><p>由于 http <code>请求报文</code>和<code>响应报文</code>是有一定区别，因此我们分开介绍。</p><h2 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h2><p>对于请求报文来说，起始行类似下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/1.1</span><br></pre></td></tr></table></figure><p>也就是<strong>方法 + 路径 + http版本</strong>。</p><p>对于响应报文来说，起始行一般张这个样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p>响应报文的起始行也叫做<code>状态行</code>。由<strong>http版本、状态码和原因</strong>三部分组成。</p><p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>展示一下请求头和响应头在报文中的位置:</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://upload-images.jianshu.io/upload_images/19956127-fb6121240c812d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://upload-images.jianshu.io/upload_images/19956127-ce1a64d0eb631fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到<code>http</code>非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><ul><li><ol><li> 字段名不区分大小写</li></ol></li><li><ol start="2"><li> 字段名不允许出现空格，不可以出现下划线<code>_</code></li></ol></li><li><ol start="3"><li> 字段名后面必须<strong>紧接着<code>:</code></strong></li></ol></li></ul><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>很重要，用来区分开<code>头部</code>和<code>实体</code>。</p><p>问: 如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>就是具体的数据了，也就是<code>body</code>部分。请求报文对应<code>请求体</code>, 响应报文对应<code>响应体</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-报文结构是怎样的？&quot;&gt;&lt;a href=&quot;#HTTP-报文结构是怎样的？&quot; class=&quot;headerlink&quot; title=&quot;HTTP 报文结构是怎样的？&quot;&gt;&lt;/a&gt;HTTP 报文结构是怎样的？&lt;/h1&gt;&lt;p&gt;对于 TCP 而言，在传输的时候分为两个部分</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CORS</title>
    <link href="https://monthlygirl.github.io/posts/cors.html"/>
    <id>https://monthlygirl.github.io/posts/cors.html</id>
    <published>2024-01-28T08:37:07.000Z</published>
    <updated>2024-01-28T08:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>跨域资源共享，是基于 HTTP 上一个用来解决跨域的方法，需要服务端和浏览器端同时支持</p><p>CORS 分为简单请求和非简单请求<br>简单请求：简单请求只要满足以下两大条件就是简单请求</p><ol><li>请求方法只能是 GET、POST、HEAD</li><li>请求头中不超出以下几个字段<br> accept，<br> accept-language，<br> context-type, 其中 content-type 只能是 application/x-www-form-urlencoded、text/plain、multipart/form-data，<br> Last-Event-ID</li></ol><p>否则就视为非简单请求，浏览器对于两种请求处理是不一样的</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 origin 字段，用来标识是哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span>/cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//baidu.com</span></span><br><span class="line"><span class="title class_">Host</span>: baidu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>上面头信息中，origin字段用来说明，本次请求来自哪个源。服务器根据这个值决定是否同意这次请求</p><p>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现 这个回应的头信息没有包含 Access-Control-Allow-Origin 字段就知道出错了，从而抛出错误。</p><p>如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:baidu.<span class="property">com</span> <span class="comment">// 该字段是必须的，它的值要么是请求时的 Origin 字段，要么是 *</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credential</span>: <span class="literal">true</span> <span class="comment">// 可选值，表示是否允许发送 Cookie， 默认情况下，Cookie 不包括在 CORS 请求之中，设为 true，cookie 可以包含在请求中，也可以设为 true 如果服务器不要浏览器发送 cookie 就删除该字段。</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="title class_">FooBar</span> <span class="comment">// 可选，cors 请求时，XMLHttpRequest 的只能拿到响应头中 6个基本字段（cache-control、content-language、content-type、expires、last-modified、Pragma），如果想拿其他的，就必须在 Access-Control-Expose-Headers 中指定。</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的，比如请求方法是 PUT、DELETE，或者 Content-type 是 application/json</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检”请求</p><p>预检请求：浏览器会先询问服务器，当前网页域名是否在服务器许可名单之中。以及可以使用哪些 HTTP 头部信息，只有得到肯定答复，浏览器才会正式发出请求，否则就报错</p><p>预检请求 是通过 OPTIONS 发的，表示这个请求是个询问请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">OPTIONS</span> /cors <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:baidu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">PUT</span>  <span class="comment">//表示CORS 会用到哪些请求方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span> <span class="comment">// 额外发送的头部信息</span></span><br><span class="line"><span class="title class_">Host</span>: api.<span class="property">alice</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en-<span class="variable constant_">US</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><h3 id="回应预检请求"><a href="#回应预检请求" class="headerlink" title="回应预检请求"></a>回应预检请求</h3><p>服务器收到“预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段后，确认允许跨域请求，就会做出回应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> ok</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Mon</span>, <span class="number">01</span> <span class="title class_">Dec</span> <span class="number">2024</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Apache</span>/<span class="number">2.0</span><span class="number">.61</span>(<span class="title class_">Unix</span>)</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//baidu.com // 表示允许 baidu.com 的跨域请求</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Encoding</span>: gzip</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">0</span></span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Keep</span>-<span class="title class_">Alive</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头部信息，那么浏览器就会认为 服务器不同意预检请求</p><p>正常响应 CORS 相关字段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>,<span class="variable constant_">POST</span>,<span class="variable constant_">PUT</span> <span class="comment">// 返回服务器支持的所有请求方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span></span><br></pre></td></tr></table></figure><h2 id="通过预检请求"><a href="#通过预检请求" class="headerlink" title="通过预检请求"></a>通过预检请求</h2><p>通过预检请求后，浏览器每次发起都会带有 Origin 字段，服务器响应 也会返回相应的 Access-Control-Allow-Origin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h1&gt;&lt;p&gt;跨域资源共享，是基于 HTTP 上一个用来解决跨域的方法，需要服务端和浏览器端同时支持&lt;/p&gt;
&lt;p&gt;CORS 分为简单请求</summary>
      
    
    
    
    
    <category term="cors" scheme="https://monthlygirl.github.io/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>CDN 缓存是什么</title>
    <link href="https://monthlygirl.github.io/posts/CDN.html"/>
    <id>https://monthlygirl.github.io/posts/CDN.html</id>
    <published>2024-01-28T02:43:27.000Z</published>
    <updated>2024-01-28T02:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDN-缓存是什么？"><a href="#CDN-缓存是什么？" class="headerlink" title="CDN 缓存是什么？"></a>CDN 缓存是什么？</h1><p>首先来了解下什么是 CDN</p><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><p>CDN 内容分发网络，CDN 是 Content Deliver Network 的简称。常说的 CDN 加速指的网站加速或是用户下载资源加速，CDN加速通常是和域名绑定的，会通过 DNS 分离查找找到最近的 CDN 边缘节点 IP</p><p>CDN 可以理解为分布在每个县城的火车票代售点，用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样广东的移动用户请求就不会千里迢迢跑到北京的电信机房（假设源站部署在北京的电信机房上）的服务器上了</p><h2 id="CDN-的优势"><a href="#CDN-的优势" class="headerlink" title="CDN 的优势"></a>CDN 的优势</h2><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li><li>大部分请求在CDN边缘节点完成，CDN 起到了分流作用，减轻了源站的负载压力</li></ol><h2 id="CDN-缓存是什么？-1"><a href="#CDN-缓存是什么？-1" class="headerlink" title="CDN 缓存是什么？"></a>CDN 缓存是什么？</h2><p>用户浏览器和服务器交互，没有接入 CDN 时：<br>用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度</p><p>用户浏览器和服务交互，接入 CDN 时：<br>客户端浏览器会先检查是否有本地缓存是否过期，如果过期，则向 CDN 边缘节点发起请求，CDN 边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个HTTP 请求结束；<br>如果数据已经过期，那么CDN 还需要向源站发起回源请求，来拉取最新的数据</p><h2 id="客户端缓存的缺点"><a href="#客户端缓存的缺点" class="headerlink" title="客户端缓存的缺点"></a>客户端缓存的缺点</h2><p>虽然说浏览器的缓存可以帮助我们提高页面访问速度，但也存在一个缺陷，缓存的CSS、JS、IMAGE 等资源更新了之后浏览器并不知道，还在使用旧资源。<br>这种则需要用户手动强制刷新才能访问新资源</p><p>手动刷新也有以下几个区别</p><ol><li><p>在地址拦中输入网址后按回车<br>这种方式 浏览器会以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存，从而减少浏览器的请求，所以，我们设置的 HTTP 强缓存 Cache-control、Expires 中的 max-age 标记方式只会这种方式有效。</p></li><li><p>按 F5 或 浏览器刷新按钮<br>这种方式，浏览器会在请求中附加必要的协商缓存，但不允许浏览器直接使用本地缓存，所以这种方式它对 ETag、Last-Modified 起作用，对 Cache-control、Expires 无效</p></li><li><p>按 Ctrl + F5<br>这是一种强刷的方式，不使用任何缓存</p></li></ol><h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p>浏览器本地缓存失效后，浏览器会向 CDN 边缘节点发起请求。跟浏览器一样，CDN 边缘节点也存在着一套缓存机制。</p><h2 id="CDN-缓存策略"><a href="#CDN-缓存策略" class="headerlink" title="CDN 缓存策略"></a>CDN 缓存策略</h2><p>CDN 边缘节点的缓存策略因服务商不同而不同，但一般都会遵循 HTTP 标准协议，通过 HTTP 响应头中的 Cache-Control: max-age 字段来设置 CDN 边缘节点数据的缓存时间</p><p>当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据没有过期，则直接将缓存数据返回给客户端，否则 CDN 会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><p>CDN 缓存主要是通过 文件目录和文件后缀名配置 多个维度来指定 CDN 缓存时间。</p><p>CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源。若 CDN 缓存时间太长，会带来数据更新时间慢的问题。</p><h2 id="CDN-缓存刷新"><a href="#CDN-缓存刷新" class="headerlink" title="CDN 缓存刷新"></a>CDN 缓存刷新</h2><p>CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl + F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的 “刷新缓存” 接口来达到清理 CDN 边缘节点缓存的目的。这样开发这更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端子啊访问时，拉取到最新的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CDN-缓存是什么？&quot;&gt;&lt;a href=&quot;#CDN-缓存是什么？&quot; class=&quot;headerlink&quot; title=&quot;CDN 缓存是什么？&quot;&gt;&lt;/a&gt;CDN 缓存是什么？&lt;/h1&gt;&lt;p&gt;首先来了解下什么是 CDN&lt;/p&gt;
&lt;h2 id=&quot;CDN-是什么&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="CDN" scheme="https://monthlygirl.github.io/tags/CDN/"/>
    
    <category term="内容分发网络" scheme="https://monthlygirl.github.io/tags/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vite 构建原理</title>
    <link href="https://monthlygirl.github.io/posts/vite-build.html"/>
    <id>https://monthlygirl.github.io/posts/vite-build.html</id>
    <published>2024-01-21T08:29:27.000Z</published>
    <updated>2024-01-21T08:29:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vite-构建原理"><a href="#Vite-构建原理" class="headerlink" title="Vite 构建原理"></a>Vite 构建原理</h1><ul><li>快速的冷启动：No Bundle + esbuild 预构建</li><li>即时的模块热更新： 基于 ESM 的 HMR，同时利用浏览器缓存策略提升速度</li><li>真正的按需加载： 利用浏览器的 ESM 支持，实现真正的按需加载</li></ul><p>Vite 其核心原理是利用浏览器现在已经支持 ES6 这一特性，碰见 ES6 的 import 就会发送一个 HTTP 请求去加载文件，Vite 启动一个 Koa 服务器拦截这些请求，并在后端进行相应的处理 将项目中使用的文件通过简单的分解与整合，然后再 ESM 格式返回给浏览器。Vite 整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的 webpack 开发编译速度快出许多！</p><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="基于-ESM-的-Dev-server"><a href="#基于-ESM-的-Dev-server" class="headerlink" title="基于 ESM 的 Dev server"></a>基于 ESM 的 Dev server</h3><p>在  Vite 出来之前，传统的 打包工具 如 webpack 是先解析依赖、打包构建再启动开发服务器，Dev server 必须等所有的模块构建完成，当我们修改了 bundle 模块中的一个子模块，整个 bundle 文件都会重新打包然后输出。项目应用越大，启动时间越长。<br>而 Vite 利用浏览器对 ESM 的支持，当 import 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上实现了动态加载。暂时没有用到的路由代码不会参与构建过程。项目应用增多，也不会影响其构建速度</p><h3 id="基于-ESM-的-HMR-热更新"><a href="#基于-ESM-的-HMR-热更新" class="headerlink" title="基于 ESM 的 HMR 热更新"></a>基于 ESM 的 HMR 热更新</h3><p>目前所有的打包工具实现热更新的思路都大同小异，主要是通过 websocket 创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作更新。</p><ul><li>Webpack： 重新编译，请求变更后模块的代码，客户端重新加载</li><li>Vite: 请求变更的模块，再重新加载</li></ul><p>Vite 通过 chokidar 来监听文件系统的变更，只用对发送生变更的模块重新加载，只需要精确的使相关模块与其临近的 HMR 边界连接失效即可，这样 HMR 更新速度就不会因为应用体积的增加而变慢。<br>而 Webpack 还要经历一次打包构建。所以 HMR 场景下，Vite 表现也比 Webpack 好</p><p>Vite 的整个热更新分为 4 步：</p><ol><li>创建一个 websocket 服务端和 client 文件，启动服务</li><li>通过 chokidar 监听文件变更</li><li>当代码变更后，服务端进行判断并推送到客户端</li><li>客户端根据推送的信息执行不同操作的更新。</li></ol><p>Vite本地启动时会创建一个WebSocket连接，同时去监听本地的文件变化<br>当用户修改了本地的文件时，WebSocket的服务端会拿到变化的文件的ID或者其他标识，并推送给客户端<br>客户端获取到变化的文件信息之后，便去请求最新的文件并刷新页面</p><p>客户端：websocket 通信和更新处理<br>当我们配置了热更新且不是 ssr 的时候，Vite 底层在处理 html的时候会把 HMR 相关的客户端代码写入到我们的代码中，当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如（connected、update、custom…）在实际开发热更新中使用最频繁的是 update和full-reload 事件。</p><p>优化：浏览器的缓存策略提高响应速度：**Vite 还利用HTTP加速整个页面的重新加载。设置响应头使得依赖模块(dependency module)进行强缓存，而源码文件通过设置 304 Not Modified 而变成可依据条件而进行更新。</p><h2 id="基于-esbuild-的依赖预编译优化"><a href="#基于-esbuild-的依赖预编译优化" class="headerlink" title="基于 esbuild 的依赖预编译优化"></a>基于 esbuild 的依赖预编译优化</h2><p><strong>为什么需要预构建 ？</strong></p><ol><li>支持 common JS 依赖</li><li>上面提到 Vite 是基于浏览器原生支持 ESM 的能力实现的，但要求用户的代码模块必须是 ESM 模块，因此必须将 common JS 的文件提前处理，转成 ESM 模块并缓存如 node_modules/.vite</li><li>减少模块和请求数量</li></ol><p>Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面性能加载。</p><p><strong>为什么使用 esbuild</strong></p><ol><li><p>编译运行 VS 解释运行<br>大多数前端打包工具都是基于 JavaScript 实现的，大家都知道 JavaScript 是解释型语言，边运行边解释。而 ESBuild 采用 go 编写，该语言可以编译成原生代码，在编译的时候都将语言转为机器语言，在启动时直接执行，更具性能优势。</p></li><li><p>多线程 VS 单线程</p></li></ol><p>JavaScript 本质上是一门单线程语言，直到引入 webworker 之后才有可能在浏览器、Node 中实现多线程操作。<br>Go 天生具有多线程优势</p><ol start="3"><li>对构建流程进行了优化 充分利用 CPU 资源</li></ol><p><strong>实现原理</strong><br>Vite 预编译之后，将文件缓存在 node_modules/.vite 文件夹下。根据以下地方来决定是否需要重新执行预构建</p><ul><li>package.json 中 dependencies 发送变化</li><li>包管理器的 lockfile</li></ul><p>如果想强制让 Vite 重新预构建依赖，可以使用 –force 启动开发服务器，或者直接删掉 node_modules/.vite 文件夹</p><h2 id="基于-Rollup-的-Plugins"><a href="#基于-Rollup-的-Plugins" class="headerlink" title="基于 Rollup 的 Plugins"></a>基于 Rollup 的 Plugins</h2><p>Vite 从 preat 的 WMR 中得到启发，将 Vite Plugins 继承 Rollup Plugins API，在其基础上进行一些扩展，同时 Vite 也基于 Rollup plugins 机制提供了强大的插件 API </p><p><strong>vite 插件是什么</strong><br>使用 vite 插件可以扩展 vite 能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义写一些配置代码，执行在打包过程中。比如解析用户自定义的文件输入，在打包代码前转译代码</p><p>在实际的实现中，vite 只需要基于 rollup 设计的接口进行扩展。</p><p><strong>Vite 钩子函数</strong></p><ul><li>config: 可以在 Vite 被解析之前修改 Vite 的相关配置</li><li>configResolved: 解析Vite 配置后调用，配置确认</li><li>configureserverL: 主要用来转换 index.html，为 dev-server 添加自定义的中间件</li><li>transformindexhmlt: 主要用来转换 index.html，钩子接收当前的 HTML 字符串和转换上下文</li><li>handlehotupdate: 执行自定义 HMR 更新，可以通过 ws 往客户端发送自定义事件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vite-构建原理&quot;&gt;&lt;a href=&quot;#Vite-构建原理&quot; class=&quot;headerlink&quot; title=&quot;Vite 构建原理&quot;&gt;&lt;/a&gt;Vite 构建原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;快速的冷启动：No Bundle + esbuild 预构建&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Vite 构建原理" scheme="https://monthlygirl.github.io/categories/Vite-%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Vite" scheme="https://monthlygirl.github.io/tags/Vite/"/>
    
    <category term="Vue3" scheme="https://monthlygirl.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue 模板编译和渲染</title>
    <link href="https://monthlygirl.github.io/posts/vue-template-compile-render.html"/>
    <id>https://monthlygirl.github.io/posts/vue-template-compile-render.html</id>
    <published>2024-01-13T12:38:22.000Z</published>
    <updated>2024-01-13T12:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板编译与渲染"><a href="#模板编译与渲染" class="headerlink" title="模板编译与渲染"></a>模板编译与渲染</h1><h2 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h2><p>在 Vue 中推崇 使用.vue 文件，在.vue 文件中使用 <template></template> 标签来编写 vue 语法。</p><ul><li>  Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。</li><li>  render 函数 会把模板内容生成对应的 VNode， VNode 经过 patch 过程 从而得到 可渲染的视图中的 VNode</li><li>  最后根据 VNode 创建 真实的 DOM 节点，并插入到视图中，最终完成视图的渲染更新。</li></ul><p>其中，【Vue 会把在 <template></template> 标签 中的内容（类似于原生 HTML）进行编译，把“原生 HTML”的内容找出来，再把“非原生 HTML”找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数。】 这一过程称之为模版编译。</p><h2 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h2><ul><li>  Vue.js 通过编译将 template 模板转换成渲染函数 render，执行渲染函数就可以得到一个虚拟节点树。</li><li>  在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对于的 update 来修改视图。这个视图主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。</li></ul><p>简单点来说，在 Vue 的底层实现上，Vue 将模版编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应式系统。在状态改变时，Vue 会计算出重新渲染组件的最小代价并应用到 DOM 操作上</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/o0pdzflrj8alc6.png" alt="模板转换过程"></p><p>通过以上图帮助理解模板转换成视图的过程，由此也可得出，模板转换视图的关键词：模板函数（render）、VNode、patch</p><ul><li>  渲染函数：用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板（template）编译成渲染函数（render），当然我们也可以不写模板，直接写渲染函数，以获得更好的性能。</li><li>  VNode 虚拟节点：它可以代表一个真实的 DOM 节点。通过 createElement 方法能将 VNode 渲染成 DOM 节点。简单来说 vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。</li><li>  patch： 虚拟 DOM 最核心的部分，它可以将 Vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于 Snabbdom 实现的。并在其基础上做了很多调整和改进。</li></ul><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/kaypjulrj8zejg.png" alt="视图转换"></p><h2 id="模板编译原理"><a href="#模板编译原理" class="headerlink" title="模板编译原理"></a>模板编译原理</h2><p>模板编译中有个环节是将模板编译成 render 函数，这个过程我们把它称作为<strong>编译</strong>。虽然我们可以为组件编写 render 函数，但使用 template 模板更加直观，也更符合我们的开发习惯。</p><p>Vue.js 提供了两个版本，一个是 Runtime + Compiler，一个是 Runtime Only。前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render 函数</p><h3 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\platforms\web\entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="title function_">warn</span>(<span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">    <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span>;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">                    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">                template,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                    shouldDecodeNewlines,</span><br><span class="line">                    shouldDecodeNewlinesForHref,</span><br><span class="line">                    <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                    <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="variable language_">this</span></span><br><span class="line">            );</span><br><span class="line">            options.<span class="property">render</span> = render;</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码之前分析过，由此也可知编译入口如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(</span><br><span class="line">    template,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable language_">this</span></span><br><span class="line">);</span><br><span class="line">options.<span class="property">render</span> = render;</span><br><span class="line">options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br></pre></td></tr></table></figure><p>compileToFunctions 方法就是把模板 template 编译生成 render 以及 staticRenderFns。</p><p>进入 compileToFunctions 方法中可以看到，compileToFunctions 实际上是 createCompiler 方法的返回值，该方法接受一个编译配置参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: string,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看 crateCompiler 方法 看到，它实际又是通过调用 crateCompilerCreator 方法返回的。<br>这个方法中 有个 baseCompile，真正的编译过程都在这个函数。 所以 baseCompile 才是真正的模板编译流程及原理所在。<br>接下来我们从 createCompilerCreator 开始分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompilerCreator</span> (<span class="attr">baseCompile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createCompiler</span> (<span class="attr">baseOptions</span>: <span class="title class_">CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">compile</span> (</span><br><span class="line">      <span class="attr">template</span>: string,</span><br><span class="line">      options?: <span class="title class_">CompilerOptions</span></span><br><span class="line">    ): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> finalOptions = <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions)</span><br><span class="line">      <span class="keyword">const</span> errors = []</span><br><span class="line">      <span class="keyword">const</span> tips = []</span><br><span class="line">      finalOptions.<span class="property">warn</span> = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">        (tip ? tips : errors).<span class="title function_">push</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="comment">// merge custom modules</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">modules</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">modules</span> =</span><br><span class="line">            (baseOptions.<span class="property">modules</span> || []).<span class="title function_">concat</span>(options.<span class="property">modules</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge custom directives</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">directives</span>) &#123;</span><br><span class="line">          finalOptions.<span class="property">directives</span> = <span class="title function_">extend</span>(</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">create</span>(baseOptions.<span class="property">directives</span> || <span class="literal">null</span>),</span><br><span class="line">            options.<span class="property">directives</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy other options</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="string">&#x27;modules&#x27;</span> &amp;&amp; key !== <span class="string">&#x27;directives&#x27;</span>) &#123;</span><br><span class="line">            finalOptions[key] = options[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> compiled = <span class="title function_">baseCompile</span>(template, finalOptions)</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        errors.<span class="property">push</span>.<span class="title function_">apply</span>(errors, <span class="title function_">detectErrors</span>(compiled.<span class="property">ast</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      compiled.<span class="property">errors</span> = errors</span><br><span class="line">      compiled.<span class="property">tips</span> = tips</span><br><span class="line">      <span class="keyword">return</span> compiled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compile,</span><br><span class="line">      <span class="attr">compileToFunctions</span>: <span class="title function_">createCompileToFunctionFn</span>(compile)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCompilerCreator 方法返回了一个 createCOmpiler 的函数，接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法 和 compileToFunctions 属性，这个 compileToFunctions 就是对应 $mount 函数调用的 compileToFunctions 方法， 它又是调用 createCompileToFunction 方法的返回值。<br>接下来看下 createCompileToFunction 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createCompileToFunctionFn</span> (<span class="attr">compile</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">compileToFunctions</span> (</span><br><span class="line">    <span class="attr">template</span>: string,</span><br><span class="line">    options?: <span class="title class_">CompilerOptions</span>,</span><br><span class="line">    vm?: <span class="title class_">Component</span></span><br><span class="line">  ): <span class="title class_">CompiledFunctionResult</span> &#123;</span><br><span class="line">    options = <span class="title function_">extend</span>(&#123;&#125;, options)</span><br><span class="line">    <span class="keyword">const</span> warn = options.<span class="property">warn</span> || baseWarn</span><br><span class="line">    <span class="keyword">delete</span> options.<span class="property">warn</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return 1&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">&#x27;It seems you are using the standalone build of Vue.js in an &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;The template compiler cannot work in this environment. Consider &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;templates into render functions.&#x27;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check cache</span></span><br><span class="line">    <span class="keyword">const</span> key = options.<span class="property">delimiters</span></span><br><span class="line">      ? <span class="title class_">String</span>(options.<span class="property">delimiters</span>) + template</span><br><span class="line">      : template</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile</span></span><br><span class="line">    <span class="keyword">const</span> compiled = <span class="title function_">compile</span>(template, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check compilation errors/tips</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">errors</span> &amp;&amp; compiled.<span class="property">errors</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Error compiling template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">          compiled.<span class="property">errors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">`- <span class="subst">$&#123;e&#125;</span>`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiled.<span class="property">tips</span> &amp;&amp; compiled.<span class="property">tips</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        compiled.<span class="property">tips</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="title function_">tip</span>(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn code into functions</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> fnGenErrors = []</span><br><span class="line">    res.<span class="property">render</span> = <span class="title function_">createFunction</span>(compiled.<span class="property">render</span>, fnGenErrors)</span><br><span class="line">    res.<span class="property">staticRenderFns</span> = compiled.<span class="property">staticRenderFns</span>.<span class="title function_">map</span>(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createFunction</span>(code, fnGenErrors)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check function generation errors.</span></span><br><span class="line">    <span class="comment">// this should only happen if there is a bug in the compiler itself.</span></span><br><span class="line">    <span class="comment">// mostly for codegen development use</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((!compiled.<span class="property">errors</span> || !compiled.<span class="property">errors</span>.<span class="property">length</span>) &amp;&amp; fnGenErrors.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Failed to generate render function:\n\n`</span> +</span><br><span class="line">          fnGenErrors.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; err, code &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;err.toString()&#125;</span> in\n\n<span class="subst">$&#123;code&#125;</span>\n`</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compilerToFunctions 接收3个参数：编译模板 template，编译配置 options 和 Vue 实例 vm<br>最终返回 render 和 staticRenderFns 函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>模板编译过程：template —&gt; compiler(parse,optimize, generate) —&gt; render 函数（VNode）</p><p>模板编译是通过 Compiler 完成，compiler 可以分成 parse、optimize 和 generate 三个阶段，最终得到 render function。</p><p>compile 函数在执行 createCompilerToFunction 的时候作为参数传入，它是 createCompiler 函数中定义的 compile  函数。</p><p>Vue 在实现 compile 的过程中 利用函数柯里化技巧把基础的编译过程函数抽出来，通过 createCompilerCreator(baseCompile) 的方式把真正编译的过程和其他逻辑如对编译配置处理、缓存处理等剥离开。很巧妙的设计</p><p>编译入口最终终于找到了，主要就是执行了如下几个逻辑：</p><ol><li>Parse 解析：解析模板字符串生成 AST<br> Parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成 AST</li><li>Optimize优化：优化语法树<br> Optimize 主要作用是标记 static 静态节点，这是Vue 在编译过程中做优化，后面当 update 视图更新时，patch 过程中 diff 算法会直接跳过静态节点，从而减少 比较的过程 优化 patch 的性能。</li><li>Generate 生成：生成 render<br> Generate 是将 AST 转换成 render function 字符串的过程，得到的结果是 render 字符串已经 staticRenderFns 字符串。<br>最终 baseCompile 的返回值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">ast</span>: ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span></span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最终返回了 ast、render、staticRenderFns, 且通过 generate 处理 ast 之后得到的是个对象。</li></ol><p>经历了这三个阶段后，vue 的 模板 template 就转换成 它 渲染 Vnode 所需的 render 函数了。</p><h2 id="Parse-解析"><a href="#Parse-解析" class="headerlink" title="Parse 解析"></a>Parse 解析</h2><p>解析整个模板的时候它的流程应该是这样子的</p><ul><li>HTML 解析器是主线，先用 HTML 解析器进行解析整个模板，在解析过程中如果碰到文本内容，那么就调用文本解析器来解析文本，如果碰到文本中包含过滤器的那就调用过滤器解析器来解析</li></ul><p>parse 解析流程：</p><ol><li>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML解析器、文本解析器和过滤器解析器。</li><li>文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数 parse 中先调用 HTML 解析器 parseHTML 函数对模板字符串进行解析。</li><li>解析器内维护了一个栈，用来保证构建的 AST 节点层级与真正 DOM 层级一致。</li><li>文本解析器的作用就是将 HTML 解析器解析得到的文本内容进行二次解析，解析文本内容中是否包含变量，如果包含变量，则将变量提取出来进行加工，为后续生成 render 函数做准备。</li></ol><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/9s93vdlrjcbzzg.png" alt="parse解析"></p><h2 id="Optimize-优化"><a href="#Optimize-优化" class="headerlink" title="Optimize 优化"></a>Optimize 优化</h2><p>有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点。</p><p>模板编译的最终目的是用模板生成一个 render 函数，而用 render 函数就可以生成与模板对应的 VNode,之后再进行 patch 算法 完成视图渲染。</p><p>patch 算法 用来对比新旧 VNOde 之间的差异。</p><p>在上面我们还说了，静态节点不管状态怎么变化它是不会变的，因此，我们可以在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，告诉后面 patch 过程 打了标记的节点是不需要对比的，只需要 克隆 一份。</p><p>优化阶段实际上就干了两件事：</p><ol><li>在 AST 中找出所有静态节点并打上标记</li><li>在 AST 中找出所有的静态根节点打上标记<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">optimize</span>(<span class="params">root: ?ASTElement, options:CompilerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    isStaticKey = <span class="title function_">genStaticKeysCached</span>(options.<span class="property">staticKey</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    isPlatformReservedTag = options.<span class="property">isReservedTag</span> || no</span><br><span class="line">    <span class="title function_">markStatic</span>(root)</span><br><span class="line">    <span class="title function_">markStaticRoots</span>(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="标记静态节点"><a href="#标记静态节点" class="headerlink" title="标记静态节点"></a>标记静态节点</h3><p>首先先从根节点开始写，先标记根节点是否为静态美蒂娜，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点还有子节点就继续递归，直到标记完所有节点</p><p>静态节点需满足一下几点要求：</p><ul><li>如果使用了 v-pre，那么他就是静态节点</li><li>如果没有使用 v-pre 那么它需要满足<ul><li>不能使用动态绑定语法 即 v-、@、：开头的属性</li><li>不能使用 v-if、v-else 这些</li><li>不能是内置组件，即标签名不能是slot、component</li><li>不能是自定义组件</li><li>节点的所有属性的key 都必须是静态节点才有的key,</li></ul></li></ul><h3 id="标记静态根节点"><a href="#标记静态根节点" class="headerlink" title="标记静态根节点"></a>标记静态根节点</h3><p>和静态节点类似，都是从 AST 根节点向下递归寻找，它要想成为静态根节点，必须满足</p><ul><li>节点本身必须是静态节点</li><li>必须拥有子节点</li><li>子节点不能是只有一个文本节点</li></ul><h2 id="Generate-生成"><a href="#Generate-生成" class="headerlink" title="Generate 生成"></a>Generate 生成</h2><p>根据模板对应的抽象语法树 AST 生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟DOM。</p><h1 id="模板编译整体流程"><a href="#模板编译整体流程" class="headerlink" title="模板编译整体流程"></a>模板编译整体流程</h1><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/appyawweeut2093/image/b_u_5b2225aa46488_oGKN7IvA/x8odshlrjcc69i.jpg" alt="模板编译"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板编译与渲染&quot;&gt;&lt;a href=&quot;#模板编译与渲染&quot; class=&quot;headerlink&quot; title=&quot;模板编译与渲染&quot;&gt;&lt;/a&gt;模板编译与渲染&lt;/h1&gt;&lt;h2 id=&quot;什么是模板编译&quot;&gt;&lt;a href=&quot;#什么是模板编译&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="模板编译和渲染" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%92%8C%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue 的构建和初始化</title>
    <link href="https://monthlygirl.github.io/posts/vue-build-init.html"/>
    <id>https://monthlygirl.github.io/posts/vue-build-init.html</id>
    <published>2024-01-13T08:06:14.000Z</published>
    <updated>2024-01-13T08:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-的构建和初始化"><a href="#Vue-的构建和初始化" class="headerlink" title="Vue 的构建和初始化"></a>Vue 的构建和初始化</h1><h1 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h1><p>通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本</p><h2 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a>Runtime Only</h2><p>编译时转化，离线编译。</p><p>Runtime Only 版本通常需要借助如  webpack 的 vue-loader工具 把 .vue 文件 编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更 轻量，性能更优。</p><h2 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a>Runtime + Compiler</h2><p>运行时，客户端编译</p><p>如果没对代码做预编译，但又使用了 Vue 的 template 属性 并传入一个字符串，则需要在客户端编译模板，即运行时编译。因为在 Vue2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本，很显然，这个编译过程对性能有一定的损耗。所以我们通常更推荐使用 Runtime- Only 的 Vue.js</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>当代码执行 import Vue from ‘vue’ 的时候，是从这个入口执行代码来初始化 Vue。 Vue 实际 是一个用 Function 实现的类，只能通过 <strong>new Vue()</strong> 实例化。</p><p>为什么 Vue 不用 ES6 的 Class 去实现呢？</p><p>在 Vue 初始化文件中，有很多 xxxMin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，<strong>Vue 按功能把这些扩展分散都多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的</strong>。 这么做的好处就是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p><p>Vue.js 在整改初始化过程中，除了给它的原型 prototype 上扩展方法，还会通过 initGlobal API 给 Vue 这个对象本身扩展全局的静态方法，即 Vue 的全局 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>,<span class="variable constant_">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span></span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了以下几件事情：<br>合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化 data、props、computed、watcher等等。在初始化的最后，如果有检测到 el 属性，则调用 vm.$mount 方法挂在 vm, 挂载的目标就是把模版渲染成最终的 DOM</p><p><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p><h2 id="new-Vue-发生了什么-init"><a href="#new-Vue-发生了什么-init" class="headerlink" title="new Vue 发生了什么 - init"></a>new Vue 发生了什么 - init</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        endTag = <span class="string">`vuw-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">        <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponents</span>) &#123;</span><br><span class="line">        <span class="comment">// 每个子组件初始化时走这里，这里只做了一些性能优化，</span></span><br><span class="line">        <span class="comment">// 将组建配置对象上的一些深层次属性 放到 vm.$options 选项中，以提高代码的执行效率</span></span><br><span class="line">        <span class="title function_">initInternalComponents</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 初始化根组件时走到这里，合并 Vue 的全局配置到根组件的局部配置，如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中</span></span><br><span class="line"><span class="comment">         * 至于每个子组件的选项合并则发生在两个地方：</span></span><br><span class="line"><span class="comment">         * 1. Vue.component 方法注册的全局组件在注册时做了选项合并</span></span><br><span class="line"><span class="comment">         * 2. &#123; component: &#123; xx &#125;&#125; 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并,包括根组件中的 components 配置</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">       )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> ) &#123;</span><br><span class="line">        <span class="comment">// 设置代理，将 vm 实例上的属性代理到 vm._renderProxy</span></span><br><span class="line">        <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化组件实例关系属性，比如 $parent $children $root $refs 等</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化自定义事件，这里需要注意一点，所以我们在 &lt;comp <span class="doctag">@click</span>=&quot;handleClick&quot; /&gt; 上注册的事件，监听者不是父组件， 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件的插槽信息，得到 vm.$slot， 处理渲染函数，得到 vm.$createElement 方法,即 h 函数，将 render函数转为 vnode 的方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="comment">// 调用 beforeCreate 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化组件的 inject 配置，得到 result[key] = val 形式的配置对象，然后对结果数据进行相应式处理，并代理每个 key 到 vm 实例</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm)</span><br><span class="line">    <span class="comment">// 数据响应式的重点，处理 props、method、data、computed、watch</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="comment">// 解析组件配置项上的 provide 对象，挂载到 vm._provided 属性上</span></span><br><span class="line">    <span class="title function_">initProvide</span>(vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 created 钩子函数</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">        <span class="title function_">mark</span>(endTag)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 配置项上 有 el ，则自动调用 $mount 方法，如果没有需要手动调用</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">        vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 初始化主要就干了几件事情，合并配置、初始化生命周期、初始化事件、初始化渲染、执行 beforeCrate 钩子、初始化依赖注入内容、初始化 prop、methods、data、computed、watcher，解析组件配置上的 provide 对象，执行 created 钩子，最后 mount 挂载真实 DOM</p><h2 id="Vue-实例挂载-mount"><a href="#Vue-实例挂载-mount" class="headerlink" title="Vue 实例挂载 - $mount"></a>Vue 实例挂载 - $mount</h2><p>Vue 中是通过 $mount 实例方法去挂在 vm 的，$mount 方法的实现是和平台、构建方式相关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idToTemplate = <span class="title function_">cached</span>(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="title function_">query</span>(id)</span><br><span class="line">    <span class="keyword">return</span> el &amp;&amp; el.<span class="property">innerHTML</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydration?: boolean</span>): <span class="title class_">Components</span> &#123;</span><br><span class="line">    el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">        process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span> </span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="variable language_">this</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">                template = template.<span class="property">innerHTML</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> template, <span class="variable language_">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">            template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (template) &#123;</span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">                <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">                shouldDecodeNewLines,</span><br><span class="line">                shouldDecodeNewlinesForHref,</span><br><span class="line">                <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">                <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">            &#125;, <span class="variable language_">this</span>)</span><br><span class="line">            options.<span class="property">render</span> = render</span><br><span class="line">            options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">                <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">                <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原先原型上的 $mount 方法</span></span><br><span class="line">    <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对 el 做了现在， Vue 不能挂在在 body、html 这样的根节点上，接下来的关键逻辑 — 如果没有定义 render 方法，则会把 el 或 template 字符串转换成 render 方法。在 vue2.0 版本中，所以 vue 的组件渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或 template 属性。最终都会转换成 render 方法， 那么这个过程是 vue 的一个 “在线编译” 的过程，他是调用 compileToFunctions 方法实现的。最后调用原先原型上的 $mount 方法挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">    el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el): <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mountComponents</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>$mount</em> 方法支持传入 2 个参数，第一个是 el, 它表示挂载的元素，可以是字符串，也可以说 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。<br>*<em>$mount</em> 方式的实质是调用 mountComponent 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountComponent 核心就是先实例化一个渲染 watcher，在它的回调函数中调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成 虚拟 Node，最终调用 vm._update 更新 DOM。 Watcher 在这里起到两个作用，一个是初始化的时候会执行毁掉你函数，另一个是当 vm 实例中的监测数据发生变化时执行的回调呢函数。<br>函数最后判断为根节点的时候 设置 vm._isMounted 为true，表示这个实例已经挂载了，同时执行 mounted 钩子函数。<br>这里 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 null 则表示当前是根 vue 实例</p><p>mountComponent 会完成整个渲染工作，包含最核心的 2 个 方法： vm._render 和 vm._update</p><h2 id="渲染-DOM-render"><a href="#渲染-DOM-render" class="headerlink" title="渲染 DOM - render"></a>渲染 DOM - render</h2><p>Vue 的 _render 方法是实例的一个私有方法，他用来把实例渲染成一个虚拟 Node</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">        _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">        vm.<span class="property">$slots</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">          vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>vm._render 最终是通过 执行 createElement 方法并返回的是 vnode，它是一个虚拟 node</p><h2 id="生成虚拟-DOM-createElement"><a href="#生成虚拟-DOM-createElement" class="headerlink" title="生成虚拟 DOM - createElement"></a>生成虚拟 DOM - createElement</h2><p>Vue 利用 createElement 方法创建 VNode，createElement 方法实际上是对 _createElement 方法的封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\vdom\create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: any,</span><br><span class="line">  <span class="attr">data</span>: any,</span><br><span class="line">  <span class="attr">children</span>: any,</span><br><span class="line">  <span class="attr">normalizationType</span>: any,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: boolean</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>((<span class="attr">data</span>: any).<span class="property">__ob__</span>)) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">is</span>)) &#123;</span><br><span class="line">    tag = data.<span class="property">is</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(data.<span class="property">key</span>) &amp;&amp; !<span class="title function_">isPrimitive</span>(data.<span class="property">key</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.<span class="property">key</span>)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-primitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instead.&#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.<span class="property">scopedSlots</span> = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.<span class="property">pre</span>) &amp;&amp; <span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_createElement 方法有 5个参数：</p><ul><li>context 表示 VNode 的上下文环境，它是 Component 类型</li><li>tag 表示标签，它可以是一个 字符串，也可以是一个 Component</li><li>data 表示 VNode 的数据，它是一个 VNodeData 类型</li><li>children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准版 的 VNode 数组</li><li>normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的，经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array</li></ul><p>每个 VNode 有 children，children 的每个元素也是一个 VNode，这样就形成了一个 Vnode tree，它很好的描述了我们的 DOM tree</p><p>回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 Vnode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成。</p><h2 id="渲染真实-DOM-update"><a href="#渲染真实-DOM-update" class="headerlink" title="渲染真实 DOM - update"></a>渲染真实 DOM - update</h2><p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。_update 方法的作用是把 VNode 渲染成真实的 DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\lifecycle.js</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>_update 的核心就是调用 vm.patch 方法，这个方法实际上在不同的平台上有不同的实现方式。比如，服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器渲染中，它指向了 patch 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules form <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = platformModules.<span class="title function_">contact</span>(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">Function</span> = <span class="title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中 nodeOps 封装了一系列 DOM 操作的方法， modules 定义了一些模块的钩子函数的实现。</p><p>createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法。具体源码位置src\core\vdom\patch.js，源码过长就不放出来。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>了解了 Vue 的整个初始化过程，得出</p><ul><li><p>Vue 初始化过程是怎样的(new Vue() 发生了什么)</p><ol><li>_init() 初始化数据、状态等<ul><li>处理组件配置项<ul><li>初始化组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</li><li>初始化每个子组件做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</li></ul></li><li>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs等</li><li>处理自定义事件</li><li>调用 beforeCreate 钩子函数</li><li>初始化组件的 inject配置，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应处理，并代理每个 key 到 vm 实例上</li><li>数据响应式，处理 props、methods、data、computed、watch 等选项</li><li>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</li><li>调用 created 钩子函数</li><li>如果有 el 配置，自动 $mount </li><li>进入挂载阶段</li></ul></li></ol></li><li><p>生命周期过程是什么<br><img src= "/img/bgTop.jpg" data-lazy-src="https://wechatapppro-1252524126.file.myqcloud.com/app3fkyxvw79316/image/b_u_61de508ba9bc4_NiemDvky/ockr6xlrbto2hm.png" alt="vue init"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-的构建和初始化&quot;&gt;&lt;a href=&quot;#Vue-的构建和初始化&quot; class=&quot;headerlink&quot; title=&quot;Vue 的构建和初始化&quot;&gt;&lt;/a&gt;Vue 的构建和初始化&lt;/h1&gt;&lt;h1 id=&quot;构建版本&quot;&gt;&lt;a href=&quot;#构建版本&quot; class=&quot;</summary>
      
    
    
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/categories/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/tags/Vue/"/>
    
    <category term="Vue 源码解析" scheme="https://monthlygirl.github.io/tags/Vue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="构建和初始化" scheme="https://monthlygirl.github.io/tags/%E6%9E%84%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>复杂异步嵌套的执行机制</title>
    <link href="https://monthlygirl.github.io/posts/Interview-event-loop&amp;async/await.html"/>
    <id>https://monthlygirl.github.io/posts/Interview-event-loop&amp;async/await.html</id>
    <published>2024-01-11T13:41:30.000Z</published>
    <updated>2024-01-11T13:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂异步嵌套逻辑分析"><a href="#复杂异步嵌套逻辑分析" class="headerlink" title="复杂异步嵌套逻辑分析"></a>复杂异步嵌套逻辑分析</h1><hr><h2 id="async-await-在事件循环中的表现"><a href="#async-await-在事件循环中的表现" class="headerlink" title="async/await 在事件循环中的表现"></a>async/await 在事件循环中的表现</h2><hr><p>对于不同Chrome 版本，<strong>async/await</strong> 会有两种表现，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不同的 Chrome 版本，会输出两种结果</p><ul><li><strong>1 3 4 2 5</strong></li><li><strong>1 3 4 5 2</strong></li></ul><blockquote><p>根据 最新的 ECMAScript 规范下，第一种为正确表现</p></blockquote><h2 id="最新的-ECMAScript-规范"><a href="#最新的-ECMAScript-规范" class="headerlink" title="最新的 ECMAScript 规范"></a>最新的 ECMAScript 规范</h2><p>最新的 ECMAScript 规范中，await 直接使用 Promise.resolve() 相同的语义，也就是说，如果 await 后面跟的是一个 Promise，则直接返回 Promise 本身。如果不是，则使用 Promise.resolve 包裹后返回。<br>所以上面的代码我们可以理解为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>console.log(2) 在第一轮事件循环时就加入微任务队列，然后 console.log(5) 才加入微任务队列，所以 2 的打印顺序在前。</p><h2 id="老版的-ECMAScript-规范"><a href="#老版的-ECMAScript-规范" class="headerlink" title="老版的 ECMAScript 规范"></a>老版的 ECMAScript 规范</h2><p>await 后不论是否为 Promise，都会产生一个新的 Promise，再将后面的内容 resolve 出去</p><blockquote><p> 其实最初关于 async/await 的相关规范和上述最新规范中行为是一致的，但是中间有一段时间 ECMA 规范有一些变化，最后又变回来了。</p></blockquote><p>根据老版规范，上述代码又可以理解成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve1</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="title function_">resolve2</span>()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 resolve1 内又 resolve 了 一个 Promise，所以在这里已经是异步任务了，而不是立即变为 fulfilled 的状态，所以 console.log(2) 并不是在第一轮事件循环中被加入微任务队列，而console.log(5) 是第一轮事件循环中就被加入到任务队列，最终打印顺序为 1 3 4 5 2</p><h1 id="复杂异步嵌套"><a href="#复杂异步嵌套" class="headerlink" title="复杂异步嵌套"></a>复杂异步嵌套</h1><p>根据上面的分析来做套题，帮助理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;),<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：script start、async1 start、async2、promise1、script end、async2 end、promise2、setTimeout</p><ol><li>定义了 async1、async2 函数，打印 script start </li><li>执行 setTimeout 回调，交由 web API, web API 将它挂入宏任务队列</li><li>执行 async1 函数，打印 async1 start</li><li>执行 async2 函数，打印 async2，将 async2 end 挂入 微任务队列</li><li>执行 new Promise ，同步执行传入构造函数的函数， 打印 promise1，将 promise2 挂入 微任务队列</li><li>打印 script end，宏任务 执行完毕</li><li>执行微任务 打印 async2 end</li><li>执行微任务 打印 promise2，微任务执行完毕，一次事件循环结束</li><li>执行下一个宏任务，查看宏任务队列，打印 setTimeout。</li><li>宏任务和 微任务都执行完毕</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;a href=&quot;#复杂异步嵌套逻辑分析&quot; class=&quot;headerlink&quot; title=&quot;复杂异步嵌套逻辑分析&quot;&gt;&lt;/a&gt;复杂异步嵌套逻辑分析&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;async-await-在事件循环中的表现&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="事件循环" scheme="https://monthlygirl.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
    <category term="async await" scheme="https://monthlygirl.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>重排（reflow）和重绘（repaint）</title>
    <link href="https://monthlygirl.github.io/posts/Interview-reflow-repaint.html"/>
    <id>https://monthlygirl.github.io/posts/Interview-reflow-repaint.html</id>
    <published>2024-01-09T13:21:16.000Z</published>
    <updated>2024-01-09T13:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h1><ol><li>HTML -&gt; 被 HTML 解析器解析成 DOM 树</li><li>CSS -&gt; 被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树 生成一颗渲染树（Render Tree） 这一个过程称之为 Attachment</li><li>生成布局（flow），浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制（paint）在屏幕上，显示出整个页面</li></ol><p>4和5 结合起来也就是我们所说的渲染，同时也是最耗时的部分</p><h1 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h1><p>在网页生成时，至少会渲染一次。在用户访问的过程中，还会不断触发重绘和重排，从而影响性能。所以在开发过程中应该避免页面的重排重绘。</p><h1 id="什么是重绘、重排？"><a href="#什么是重绘、重排？" class="headerlink" title="什么是重绘、重排？"></a>什么是重绘、重排？</h1><p>什么是重绘、重排？从字面意思就可以理解</p><ul><li>重绘：重新绘制，一般发生在布局不变，视觉上变化的时候，比如阴影颜色</li><li>重排：重新排列，一般发生在布局变化或元素大小发生变化时</li></ul><p>如上概念可以得出： </p><ol><li>单单改变元素的外观，肯定不会引起网页的重新生成布局。</li><li>改变元素大小和布局变化时，那元素乃至周边的 DOM 可能都需要重新绘制。</li></ol><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h1 id="重排（reflow）："><a href="#重排（reflow）：" class="headerlink" title="重排（reflow）："></a>重排（reflow）：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><pre><code>当 DOM 的变化影响了元素的几何信息（如位置、大小等），浏览器都需要重新计算元素的几何属性。这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素</code></pre><h2 id="下面的情况会发生重排："><a href="#下面的情况会发生重排：" class="headerlink" title="下面的情况会发生重排："></a>下面的情况会发生重排：</h2><pre><code>+ 页面初始渲染，这是开销最大的一次重排+ 添加/删除可见的 DOM 元素+ 改变元素位置+ 改变元素尺寸，比如 边距、填充、边框、宽度高度等+ 改变元素内容，比如文字数量、图片大小等+ 改变元素字体大小+ 改变浏览器窗口尺寸，比如 resize 事件发生时+ 激活 css 伪类 比如 :hover+ 设置 style 属性的值，+ 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等</code></pre><table><thead><tr><th>常见引起重排的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewNeeded()</td><td></td><td></td></tr></tbody></table><h2 id="重排的影响范围："><a href="#重排的影响范围：" class="headerlink" title="重排的影响范围："></a>重排的影响范围：</h2><pre><code>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围 DOM 重新排列，影响范围有两种：+ 全局范围：从根节点 html 开始对整个渲染树进行重新渲染+ 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</code></pre><h3 id="全局范围重排"><a href="#全局范围重排" class="headerlink" title="全局范围重排"></a>全局范围重排</h3><pre><code>一般情况下当根节点 或 子节点发生重大布局变化时，往往会发生全局范围的重排</code></pre><h3 id="局部范围重排"><a href="#局部范围重排" class="headerlink" title="局部范围重排"></a>局部范围重排</h3><pre><code>只在某个 DOM 内部触发重排，一个元素形成 BFC 后，这个元素内部发生变化不会影响到外部的其他元素，只会影响该元素内部的其他元素</code></pre><h2 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h2><pre><code>重排的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓。通过减少重排的负面影响来提供用户体验的最简单方式就是尽可能的减少重排次数</code></pre><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><pre><code>尽量以局部布局的形式组织 html 结构，尽可能小的影响重排范围+ 不要使用 table 布局，可能一个小改动会造成整个 table 的重新布局。不得已的情况下，可以设置 table-layout: auto; 或者是 table-layout: fixed 这样可以让 table 一行一行的渲染。这样的做法是为了限制 reflow 的影响范围。+ 减少 DOM 嵌套</code></pre><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><ul><li>样式集中改变， 不频繁的操作样式。</li><li>分离 DOM 读写操作，DOM 的多个读写操作，应该放在一起，不要两个读操作之间，加入一个写操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>原来的操作会触发四次重排，修改后只会触发一次，这是因为我们的浏览器的渲染机制。<br>当我们修改元素的几何属性，导致浏览器发生重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定数量或到了一定的时间间隔，浏览器就会批量操作。</p><ul><li><p>将 元素 形成 BFC</p></li><li><p>优化动画<br>  将动画效果应用在 BFC 元素上，减少重排范围。动画效果可以牺牲一些平滑，来换取速度，这中间的度自己衡量。比如实现一个动画 以1个像素单位移动这样最平滑，但是 layout 会过于频繁，大量消耗 CPU 资源，如果以3个像素为单位移动则会好很多</p><ul><li><p>启用 GPU 加速，GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图像操作交给 GPU 来完成。因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p>GPU 加速通常包括以下几个部分： Canvas2D，布局合成， CSS3 转换（transitions），CSS3 3D 变换（transform），WebGl 视频</p></li></ul></li></ul><h1 id="重绘（repaints）"><a href="#重绘（repaints）" class="headerlink" title="重绘（repaints）"></a>重绘（repaints）</h1><p>当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，就叫重绘</p><h2 id="常见引起重绘的属性"><a href="#常见引起重绘的属性" class="headerlink" title="常见引起重绘的属性"></a>常见引起重绘的属性</h2><table><thead><tr><th>常见引起重绘的属性和方法</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td></td><td>background-size</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。Layout： 重排，又叫回流。Paint：重绘，重绘重排这些步骤都是在 CPU 中发生的。 Composite Layers：CPU 把生成的 BitMap 传输到 GPU ，渲染到屏幕上</li><li>CSS3 就是在 GPU 发生的： Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;页面生成的过程：&quot;&gt;&lt;a href=&quot;#页面生成的过程：&quot; class=&quot;headerlink&quot; title=&quot;页面生成的过程：&quot;&gt;&lt;/a&gt;页面生成的过程：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HTML -&amp;gt; 被 HTML 解析器解析成 DOM 树&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="reflow、repaint" scheme="https://monthlygirl.github.io/tags/reflow%E3%80%81repaint/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/posts/Interview-JavaScript.html"/>
    <id>https://monthlygirl.github.io/posts/Interview-JavaScript.html</id>
    <published>2023-12-24T12:19:58.000Z</published>
    <updated>2023-12-24T12:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonJS、AMD、CMD-和-ESM"><a href="#CommonJS、AMD、CMD-和-ESM" class="headerlink" title="CommonJS、AMD、CMD 和 ESM"></a>CommonJS、AMD、CMD 和 ESM</h1><h2 id="一、Common-JS"><a href="#一、Common-JS" class="headerlink" title="一、Common JS"></a>一、Common JS</h2><ol><li>CommonJS 它是通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务端的解决方案，它是以同步的方式来引入模块的。（因为服务端的文件都存储在本地磁盘，所以读取起来非常快，用同步的方式没有问题，但在浏览器端，由于模块加载是使用网络请求的，所以使用 异步的方式更合适）</li><li>CommonJS 输出的是一个只的拷贝，会有缓存，这个值一旦输出，模块内部更新， 对于输出的这个值不会有影响</li><li>CommonJS 是在运行时加载的，CommonJS 模块是个对象，输入时会先加载一整个模块生成一个对象，从这个对象上取值</li></ol><h2 id="二、AMD"><a href="#二、AMD" class="headerlink" title="二、AMD"></a>二、AMD</h2><ol><li><p>AMD 采用 异步方式来加载模块的，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成再去执行回调函数。require.js 实现了 AMD 规范</p></li><li><p>AMD 在使用模块依赖时，必须先声明依赖，并且依赖模块加载完成就立即执行，依赖模块的顺序可能和我们书写的并不一致</p></li></ol><h2 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h2><ol><li>CMD 和 AMD 一样都是为了解决异步模块加载问题。它和 AMD 的区别在于 模块定义时对依赖的处理不同 和依赖模块的执行时机处理不同。</li><li>CMD 模块依赖可以就近声明，使用时再去声明</li><li>CMD 会先将模块依赖下好，等待代码执行时再去执行，所以模块依赖执行顺序和我们书写的顺序一致。</li></ol><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><ol><li><p>ESM 是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</p></li><li><p>ESM 输出的是一个值的引用，即模块内部值更新，所有引用该值的地方都会更新</p></li><li><p>ESM 是在代码解析时生成的，采用静态优化 是静态执行的，因此不能有变量、表达式等这些只有在代码运行时才能得到结果写法。</p></li><li><p>ESM 对外输出的是一个接口，必须和模块内部建议一对一的关系。</p></li></ol><p>5 ESM import 输入的变量都是只读的，并且import 会有提升效果，提升到首部提前执行</p><ol start="6"><li>ESM import 多个重复语句，只会执行一次。</li></ol><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">executor</span>(resolve, reject) </span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onResolveCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span>  <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>))</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onRejectCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span> <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol 表示一个独一无二的值，它引入的原因是 由于 ES5 的对象属性都是字符串，我们再去使用别人提供的对象时，如果要在这个对象上添加属于 有可能会有属性冲突， 如果对象中的每个值都是独一无二的，那么就没有这种问题了，于是引入了 Symbol</p><p>Symbol 是原始数据类型中独一无二的值, js 一共有五种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。<br>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h1 id="cookie、sessionStorage、localStorage-的区别"><a href="#cookie、sessionStorage、localStorage-的区别" class="headerlink" title="cookie、sessionStorage、localStorage 的区别"></a>cookie、sessionStorage、localStorage 的区别</h1><p>这三种 都是浏览器存储信息的一种手段， 共同点：都是保存在浏览器端，且是同源的</p><ol><li><p>cookie：</p><ul><li>存储容量限制，一般是在 几 kb （4kb\5kb）</li><li>cookie 可以设置具体的过期时间，可以是会话级（浏览器关闭时失效）或者具体的过期日期</li><li>cookie 用于客户端和服务器之间传输，每次请求都会被发送到服务器端，因此对于跨域请求和安全性有一定的限制</li><li>可以通过设置域名路径来控制 cookie 的作用域，实现跨子域和跨路径的共享</li></ul></li><li><p>Session Storage</p><ul><li>存储容量可以达几M，5M左右，但是会话级别的，浏览器一关闭 就自动清除</li><li>它只存储在客户端，每次请求不会被发送到服务器端</li><li>仅限于当前源，不同页面间不能共享数据</li></ul></li><li><p>localStorage</p><ul><li>存储容量比 sessionStorage 更大，且数据可以长期保存</li><li>可以持久化存储数据，关闭浏览器会话不会数据被清除</li><li>仅限于当前源，不同页面间不能共享数据</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CommonJS、AMD、CMD-和-ESM&quot;&gt;&lt;a href=&quot;#CommonJS、AMD、CMD-和-ESM&quot; class=&quot;headerlink&quot; title=&quot;CommonJS、AMD、CMD 和 ESM&quot;&gt;&lt;/a&gt;CommonJS、AMD、CMD 和 E</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://monthlygirl.github.io/posts/Interview-Webpack.html"/>
    <id>https://monthlygirl.github.io/posts/Interview-Webpack.html</id>
    <published>2023-12-24T09:28:17.000Z</published>
    <updated>2023-12-24T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js</p><h2 id="1-有哪些常用的-loader"><a href="#1-有哪些常用的-loader" class="headerlink" title="1. 有哪些常用的 loader"></a>1. 有哪些常用的 loader</h2><ul><li>file-loader: 处理文件的 loader,处理文件导入地址并替换成其访问地址，并把文件输出到相应位置</li><li>babel-loader: 将 es6 转 es5</li><li>sass-loader: 将 sass 转 css</li><li>css-loader: 处理样式间的相互引用</li><li>ts-loader: 处理 TS 文件</li><li>vue-loader： 处理 .vue 文件<br>….</li></ul><p>loader 的作用就是用于处理源文件代码，将它们转换成 webpack 可处理的模块，处理源码文件时，针对不同的源码模块使用 不同的 loader 处理</p><p>loader 的执行顺序是从右往左，从下往上，</p><blockquote><p>modules: {<br>    rules: [{<br>        use: [<br>            ‘style-loader’<br>            ‘css-loader’, ‘postcss-loader’, ‘sass-loader’]<br>    }]<br>}</p></blockquote><h2 id="2-常见的-Plugin"><a href="#2-常见的-Plugin" class="headerlink" title="2.常见的 Plugin"></a>2.常见的 Plugin</h2><ul><li>html-webpack-plugin: dist 下生成 html 文件，依赖于 html-loader</li><li>clean-webpack-plugin: 清除目录文件</li><li>mini-css-extract-plugin: 分离样式，提取css 文件，按需加载</li><li>webpack-bundle-analyzer: webpack打包分析插件<br>….</li></ul><h2 id="3-loader-和-plugin-间的区别"><a href="#3-loader-和-plugin-间的区别" class="headerlink" title="3.loader 和 plugin 间的区别"></a>3.loader 和 plugin 间的区别</h2><p>loader 是一个文件转换器，因为 webpack 只能识别 js 和 json 文件，所以其他类型的文件需要通过 loader 进行转换<br>比如： a.scss 转 b.css， 单纯的就是一个 文件转换的过程<br>loader 只运行在打包文件前</p><p>plugin 用于扩展 webpack 的功能，用于执行任意类型的任务，所有 loader 解决不了的事都可以使用 plugin 来解决。如：代码分割、代码压缩<br>plugin 在整个项目编译周期都起作用</p><h2 id="4-plugin-的组成部分"><a href="#4-plugin-的组成部分" class="headerlink" title="4.plugin 的组成部分"></a>4.plugin 的组成部分</h2><ul><li>plugin 本质是一个 node 模块，这个模块到处一个 js 类</li><li>它的原型需要定义一个 apply 方法</li><li>通过 compiler 来获取 webpack 内部钩子，获取打包阶段的各个流程。webpack 的内部钩子 分为 异步 构字 和同步构子，异步钩子需要执行对应回调</li><li>通过 compilation 操作 webpack 内部实例特定的数据</li></ul><h1 id="webpack-和-gulp-的不同"><a href="#webpack-和-gulp-的不同" class="headerlink" title="webpack 和 gulp 的不同"></a>webpack 和 gulp 的不同</h1><ul><li><p>webpack 基于入口，会自动解析入口所需加载的所有资源文件，用不同的loader 来处理不同的文件</p></li><li><p>gulp 是基于任务和流的，找到一个文件模块 对其做一系列的链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web 的构建流程</p></li><li><p>gulp 需要将整个构建 拆成多个 task 并合理控制所有的 task 的调用关系</p></li><li><p>webpack 只需找到入口，并且清楚对不同资源应用什么 loader 进行加工处理</p></li><li><p>gulp 常见 api: gulp.src, gulp.dest, gulp.pipe, gulp.watch 等</p></li></ul><h1 id="npm、yarn、pnpm"><a href="#npm、yarn、pnpm" class="headerlink" title="npm、yarn、pnpm"></a>npm、yarn、pnpm</h1><h2 id="1-npm-3-0之前"><a href="#1-npm-3-0之前" class="headerlink" title="1. npm 3.0之前"></a>1. npm 3.0之前</h2><p>在 npm 3.0 之前，安装项目的 node_modules 包，会出现嵌套结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">  ｜--- foo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br><span class="line">  ｜--- zoo</span><br><span class="line">    ｜-- index.js</span><br><span class="line">    ｜-- package.json</span><br><span class="line">    ｜-- node_modules</span><br><span class="line">        ｜-- bar</span><br><span class="line">        ｜-- index.js</span><br></pre></td></tr></table></figure><p>这种嵌套结构会出现 2 个问题</p><ol><li>层级嵌套太深，导致文件路径过长</li><li>重复安装包，导致项目体积变大</li></ol><p>为了解决这些问题，于是 yarn 横空出世</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn采用 扁平化依赖项来解决 npm 的问题</p><p>扁平化依赖项就是将所有依赖铺平，放在同一级的依赖目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">    |-- foo</span><br><span class="line">        |-- index</span><br><span class="line">    |-- bar</span><br><span class="line">        |-- index</span><br><span class="line">    |-- zoo</span><br><span class="line">        |-- index</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这种层级依赖的管理下， node_modules 中不会有层级深的情况，并且在安装依赖时，会先查找当前 node_modules 中是否有这个包，所有也解决了重复安装包 体积变大的问题。<br>解决了 npm 3.0 之前的问题，后续npm 也延用了 yarn 的方案。</p><p>但同时引进了新的问题 – 幽灵依赖 </p><h2 id="幽灵依赖依赖"><a href="#幽灵依赖依赖" class="headerlink" title="幽灵依赖依赖"></a>幽灵依赖依赖</h2><p>幽灵依赖指的是：当前项目中的package.json 并没有该依赖，在代码中确可以引用。<br>这个原因是因为 npm 包被铺平了，依赖中的依赖也被安装了，所以在当前项目 package.json  没有声明该依赖也可以引用。</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>pnpm 中解决了幽灵依赖的问题。<br>使用 pnpm 管理项目依赖，pnpm 不允许安装 package.json 中没有声明的依赖。</p><p>同时 pnpm 还做了另一个优化，使用 软链接和硬链接 来管理依赖，减少了磁盘空间。</p><h2 id="什么是软链接"><a href="#什么是软链接" class="headerlink" title="什么是软链接"></a>什么是软链接</h2><p>软链接： 相当于一个符号链接，指向目标文件地址，类似 window 电脑的快捷方式。<br>修改软链接，不会影响到目标文件</p><h2 id="什么是硬链接"><a href="#什么是硬链接" class="headerlink" title="什么是硬链接"></a>什么是硬链接</h2><p>硬链接：链接符号存储了引用地址，类似 js 中的对象引用。<br>修改硬链接的内容，引用的目标文件会受到影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"></span><br><span class="line">b.<span class="property">age</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="pnpm-原理"><a href="#pnpm-原理" class="headerlink" title="pnpm 原理"></a>pnpm 原理</h2><p>根据软硬链接实现的<br>使用 pnpm 安装依赖时，在 node_modules 中会出现一个.pnpm 的文件和其他依赖文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">|-- .<span class="property">pnpm</span>/</span><br><span class="line">|-- element/</span><br><span class="line">|-- and</span><br></pre></td></tr></table></figure><p>此时，依赖文件 如 element 中实际是一个软链接，指向了 .pnpm 中的 element<br>即 真实路径是 .pnpm/element.3.2.1/node_modules/element<br><code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules&lt;/name&gt;</code></p><p>在由 pnpm/<name>@<version>/node_modules</name> 硬链接到 .pnpm/store 中去</p><p>所以 pnpm 通过这种方式 不仅解决了幽灵依赖的问题，还减少了磁盘空间，下载速度快。</p><h1 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h1><p>CSS 预处理器本质是为 CSS 增加一些可编程的特性，使 CSS 更加强大。</p><ol><li><p>postcss<br> 提供了可以用 JS 代码来处理 CSS，负责把 CSS 代码解析成 AST，再由插件对 AST 进行处理，插件可以实现多样化，如：支持变量和混入，增加浏览器前缀等</p><p> postcss 的作用</p><ul><li>将 css 解析为 JS 可操作的 AST</li><li>调用差距处理 AST 并等到结果</li></ul></li></ol><p>postcss 一般配合 构建工具使用<br>常用的有：<br>    auto prefixer<br>    postcss-px-to-viewport<br>    cassnano 压缩css 等</p><ol start="2"><li><p>sass 在完全兼容 css 的前提下，提供变量、嵌套、混合 自定义函数等编程能力，less 同理</p></li><li><p>sass 和 less 的区别</p><ul><li>sass 和 less 在语法上有些共性，如：嵌套规则、运算、作用域等</li><li>主要的不同在于它们的实现方式<br>less 基于 js， sass 基于 ruby<br>变量的区别： less 用 @， sass 用 $<br>sass 支持条件语句 if{} else{} for{}，less 不支持</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;webpack 的作用：将前端代码模块编译打包成浏览器可以识别的 html + css + js&lt;/</summary>
      
    
    
    
    
    <category term="Webpack" scheme="https://monthlygirl.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://monthlygirl.github.io/posts/Interview-CSS.html"/>
    <id>https://monthlygirl.github.io/posts/Interview-CSS.html</id>
    <published>2023-12-22T10:09:53.000Z</published>
    <updated>2023-12-22T10:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Css-的优先级"><a href="#Css-的优先级" class="headerlink" title="Css 的优先级"></a>Css 的优先级</h1><p>important &gt; 内联样式 &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器</p><h1 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别"></a>页面导入样式时，使用 link 和 @import 有什么区别</h1><ol><li><p>link 属于 XHTML 标签，除了加载 CSS 外 还能用于定义 rel 等属性； @import 是提供给 css 的，只能用于加载 css</p></li><li><p>页面被加载时 link 会同时被加载，而 import 引用的 css 会等到页面加载完后在加载</p></li><li><p>import 有兼容性问题，只有在 IE5以上才能被识别，link 是 XHTML 标签，没有兼容性问题</p></li><li><p>link 支持使用 js 控制 DOM 去改变样式，import 不支持</p></li></ol><h1 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h1><p>css 盒模型 分为 IE 盒模型(border-box) + W3C 盒模型(content-box)<br>盒模型包括：content + padding + border + margin<br>IE 盒模型 和 W3C 盒模型的区别是 IE 盒模型的 content 包含 padding + border</p><h1 id="CSS-选择器有哪些？-哪些属性可以继承"><a href="#CSS-选择器有哪些？-哪些属性可以继承" class="headerlink" title="CSS 选择器有哪些？ 哪些属性可以继承"></a>CSS 选择器有哪些？ 哪些属性可以继承</h1><ol><li>id 选择器</li><li>class 选择器</li><li>标签选择器</li><li>相邻选择器</li><li>子代选择器</li><li>属性选择器</li><li>通配符选择器</li><li>伪类选择器</li></ol><p>可继承属性：font-size,font-family, color 等<br>不可继承：border、padding、margin、width、height 等</p><h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p>区别：<br>    1. 伪类本质上是为了祢补常规css 选择器不足<br>    2. 伪元素的本质是创建了一个有内容的虚拟元素<br>    3. css3 中 伪类和伪元素的写法不同</p><p>伪类有： :active, :hover, :checked :nth-child 等<br>伪元素： ::after、::before、::first-letter 等</p><h1 id="css-的-content-属性的作用"><a href="#css-的-content-属性的作用" class="headerlink" title="css 的 content 属性的作用"></a>css 的 content 属性的作用</h1><p>css 的 content 属性 专门应用在 before / after 上，用来插入生成内容</p><h1 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h1><p>BFC 指的是 块级格式化的上下文，一个元素形成了BFC 后，那么它的内部元素变化不会影响到外部元素，同样外部元素变化也不会影响到内部元素。<br>一个 BFC 就像是一个隔离区域，和其他区域互不影响。<br>一般来说，一个根元素就是一个 BFC，浮动和绝对定位也会形成 BFC， display 属性为 inline-block、flex 时也会创建 BFC 。overflow 的值不为 visible 时也会创建 BFC</p><h1 id="什么是-IFC"><a href="#什么是-IFC" class="headerlink" title="什么是 IFC"></a>什么是 IFC</h1><p>IFC 指的是 行级格式化上下文，它有着一些布局规则：</p><ol><li>行级上下文内部的盒子会在水平方向一个一个的方知</li><li>当一行不够时，会自动切换下一行</li><li>行级上下文的高度有内部高度最高的内联盒子决定。</li></ol><h1 id="什么是浮动、高度塌陷？如何清除浮动"><a href="#什么是浮动、高度塌陷？如何清除浮动" class="headerlink" title="什么是浮动、高度塌陷？如何清除浮动"></a>什么是浮动、高度塌陷？如何清除浮动</h1><p>在文档流中，父元素的高度默认是由子元素撑开的<br>也就是子元素多高，父元素就多高<br>但是当为 子元素设置浮动后 float ，子元素会脱离文档流<br>此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷</p><p>父元素高度塌陷，父元素下的所有元素都会向上移动。</p><p>通过清除浮动、设定父元素高度可以解决此问题，但我们一般不推荐写死父元素的高度来解决。</p><p>清除浮动的方式：</p><ol><li>使用 clear 来清除浮动</li></ol><p>clear 一般配合伪元素来一起使用</p><p>.div::before {<br>    content: ‘’;<br>    display: block;<br>    clear: both;<br>}</p><ol start="2"><li><p>使用 BFC 来清除浮动（BFC 中可以使用影响最小的 overflow: hidden 来清除浮动）</p></li><li><p>BFC 有兼容性问题，对于I E也可以使用 zoom: 1 来清除浮动<br>zoom 属性是 IE 浏览器专有属性，它可以设置或检索对象的缩放比例，解决 ie 下比较奇葩的bug。触发ie 的haslayout 属性</p></li></ol><p>原理是所设置的元素会被扩大和缩小，高度和宽度会重新计算，触发重新渲染。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Css-的优先级&quot;&gt;&lt;a href=&quot;#Css-的优先级&quot; class=&quot;headerlink&quot; title=&quot;Css 的优先级&quot;&gt;&lt;/a&gt;Css 的优先级&lt;/h1&gt;&lt;p&gt;important &amp;gt; 内联样式 &amp;gt; id 选择器 &amp;gt; class 选择器</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://monthlygirl.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
