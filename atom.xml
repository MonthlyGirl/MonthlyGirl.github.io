<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月刊少女野崎君のBlog</title>
  
  
  <link href="https://monthlygirl.github.io/atom.xml" rel="self"/>
  
  <link href="https://monthlygirl.github.io/"/>
  <updated>2021-06-16T21:19:49.000Z</updated>
  <id>https://monthlygirl.github.io/</id>
  
  <author>
    <name>月刊少女野崎君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码精进之路》学习日志</title>
    <link href="https://monthlygirl.github.io/2021/06/code.html"/>
    <id>https://monthlygirl.github.io/2021/06/code.html</id>
    <published>2021-06-16T21:19:49.000Z</published>
    <updated>2021-06-16T21:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p><code>变量名应该是名词，能够正确地描述业务，有表达力。如果一个变量名需要用注释来补充说明，那很有可能说明命名有问题</code>。</p><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p><code>函数名要具体，它体现的是做什么，而不是怎么做。</code></p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p><code>类名是一组数据和操作的封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。</code><br>实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如Customer,Employee等等；辅助类是辅佐实体类一起完成业务逻辑得，其命名要能够通过后缀来体现功能，例如，用来为Customer 做控制路由的控制类CustomerController，对于辅助类，尽量不要用Helper,Util之类的后缀，因为其含义太过笼统。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p><code>包代表了一组有关系的类的集合，起到了分类组合和命名空间的作用，包名应该能够反映一组类在更高抽象层次上的联系，例如Apple、Pear，我们可以将它们放在一个包中，命名为fruit。包的命名要适合，不能太抽象也不能太具体。如Apple，那么将Pear、Orange放进包中就不适合了；如果太抽象，称为Object，Object无所不包，这便失去了用包来限定范围的作用。</code></p><h2 id="模块名"><a href="#模块名" class="headerlink" title="模块名"></a>模块名</h2><p><code>相对于包来说，模块的粒度更大，通常一个模块包含了多个包，模块命名要有唯一性，另外名称要反映模块在系统中的职能</code></p><h2 id="命名保持一致性"><a href="#命名保持一致性" class="headerlink" title="命名保持一致性"></a>命名保持一致性</h2><p>保持命名的一致性，可以提高代码的可读性，每个概念对应一个词。在项目，通常约定方法名，如：crud操作中 create 新增，add 添加，remove 删除。<br>使用对仗词，遵守对仗词的命名规则有助于保持一致性，从而提高代码的可读性。像first/last这样的对仗词就很容易理解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>像Brian W.Kernighan 说的那样：“别给糟糕的代码加注释—重新写吧。”<br>注释，不要复述功能，注释要能够解释代码背后的意图，而不是对功能的简单重复，真正的高手是尽量不写注释。</p><p><strong>很多人（包括我在没阅读这边书之前）觉得命名规范只是细节，但命名其实很难。书中在这一章开头就引用了两个名人的谚语，言简意赅的表达了命名的重要性。<code>就像Stack OverFlow的创始人Joel Spolsky说的：“起一个好名字应该很难，因为好名字需要把要以浓缩在一到两词中”，Martin Fowler也表示过“在计算机科学中有两件难事：缓存失效和命名”</code>；所以好的命名可以保证代码不仅是被机器执行的指令，更是人和人之间沟通的桥梁。也像channing哥说的，好的代码看着，不是在看代码，而是像看一本书</strong></p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ol><li>代码格式，代码格式关系到代码的可读性，因此需要遵从一定的规范，包括缩进、水平对齐、注释格式等</li><li>命名规范，每种语言都有自己独特的命名风格，javascript是弱类型语言，会使用匈牙利命名法的习惯（这个还第一次见）</li><li>异常规范，要统一处理异常，异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码，这种不一致性通常会让人摸不着头脑，增加了服务的使用成本和沟通成本</li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数数量"><a href="#参数数量" class="headerlink" title="参数数量"></a>参数数量</h2><p>最理想的参数数量是零（零参函数），其次是一（一元函数），再次是二（二元函数），应尽量避免三（三元函数）<br>如果函数需要3个以上参数，就说明其中一些参数应该封装为类了。</p><h2 id="短小函数"><a href="#短小函数" class="headerlink" title="短小函数"></a>短小函数</h2><p>函数的第一规则是要短小，第二规则是要更短小。有时保持代码的逻辑不变，只是把长方法改成多个短方法，代码的可读性就能提高很多。超长方法是典型代码的“坏味道”，对超长方法的结构化分解是提升代码可读性最有效的方式之一。</p><h2 id="职责单一"><a href="#职责单一" class="headerlink" title="职责单一"></a>职责单一</h2><p>一个方法只做一件事情（华哥跟我说了好多次，拆分函数，哪怕只有一句话，只要有助于语义显性化的表达，也是值得的），也就是函数级别的单一职责原则（SRP），遵循SRP不仅可以提升代码的可读性，还行提升代码的可复用性。因为职责越单一，功能越内聚，</p><h2 id="精简辅助代码"><a href="#精简辅助代码" class="headerlink" title="精简辅助代码"></a>精简辅助代码</h2><p>辅助代码，它不是处理业务逻辑的核心代码，但如判空、打印日志、缓存检查等等，这些代码往往会在多个函数中重复冗余，如果辅助代码太多，会极大地干扰代码的可读性。因此我们应该尽量减少辅助代码对业务代码的干扰。让函数中的代码能直观第体现业务逻辑，而不是让业务代码淹没在辅助代码中。</p><h2 id="组合函数模式"><a href="#组合函数模式" class="headerlink" title="组合函数模式"></a>组合函数模式</h2><p>组合函数要求所有的公有函数读起来像一系列执行步骤的概要，而这些步骤的真正实现细节是在私有函数里面。组合函数有助于代码保持精炼并易于复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近拜读导师推荐的一本书 《代码的精进之路》 在这本书中，作者引用了许多名人谚语，一针见血，总是别有一番风味也能让你幡然醒悟。&lt;/p&gt;
&lt;h1 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="学习指南" scheme="https://monthlygirl.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>vue3.0</title>
    <link href="https://monthlygirl.github.io/2021/04/vue3.0.html"/>
    <id>https://monthlygirl.github.io/2021/04/vue3.0.html</id>
    <published>2021-04-01T21:59:31.000Z</published>
    <updated>2021-04-01T21:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-0的新特性及Vue3-0带来的新变化"><a href="#Vue3-0的新特性及Vue3-0带来的新变化" class="headerlink" title="Vue3.0的新特性及Vue3.0带来的新变化"></a>Vue3.0的新特性及Vue3.0带来的新变化</h1><p>vue3.0 2020年9月发布,命名为One p</p><h2 id="Vue3-0-带来的新变化"><a href="#Vue3-0-带来的新变化" class="headerlink" title="Vue3.0 带来的新变化"></a>Vue3.0 带来的新变化</h2><ul><li>性能的提升 1.3~2x<br>与vue2.x相比,mount 50%提升,内存占用小120%<br>核心代码+ Composition API:13.5kb,最小11.75kb  可以单独使用<br>所有的runtime:22.5kb(vue2是32kb)</li></ul><h1 id="为什么会有这么大的性能提升"><a href="#为什么会有这么大的性能提升" class="headerlink" title="为什么会有这么大的性能提升?"></a>为什么会有这么大的性能提升?</h1><h2 id="Compiler-原理"><a href="#Compiler-原理" class="headerlink" title="Compiler 原理"></a>Compiler 原理</h2><ol><li>静态的节点和静态绑定的class和id不再作更新处理(hoistStatic-&gt;SSR优化)</li><li>结合打包标记PatchFlag,进行更新分析<br>在编译过程中会将template编译成ast语法树,ast是一个抽象的语法树,动态的内容打上标记,在更新的时候只更新动态的内容</li><li>事件监听器Cache缓存处理(cacheHandlers)</li><li>hoistStatic 自动针对多静态节点进行优化,输出字符串</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-0的新特性及Vue3-0带来的新变化&quot;&gt;&lt;a href=&quot;#Vue3-0的新特性及Vue3-0带来的新变化&quot; class=&quot;headerlink&quot; title=&quot;Vue3.0的新特性及Vue3.0带来的新变化&quot;&gt;&lt;/a&gt;Vue3.0的新特性及Vue3.0</summary>
      
    
    
    
    <category term="Vue" scheme="https://monthlygirl.github.io/categories/Vue/"/>
    
    
    <category term="vue3.0 Compiler" scheme="https://monthlygirl.github.io/tags/vue3-0-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的各个版本</title>
    <link href="https://monthlygirl.github.io/2021/03/http-version.html"/>
    <id>https://monthlygirl.github.io/2021/03/http-version.html</id>
    <published>2021-03-01T20:51:53.000Z</published>
    <updated>2021-03-01T20:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>HTTP 是超文本传输协议,它定义了客户端和服务器之间交换报文的格式和方式,默认采用80端口,它使用TCP作为传输层协议,保证了数据传输的可靠性</p><p>HTTP 是一个无状态的协议,HTTP 服务器不会保存关于客户端的任务信息</p><p>HTTP 有两种连接模式,一种是持续连接,一种是非持续连接;<br>非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接;持续连接,TCP 连接默认不关闭,可以被多个请求复用;采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间; </p><p>在HTTP1.0 以前使用的非持续的连接,但是可以在请求时,加上Connection: keep-alive 来要求服务器不要关闭 TCP 连接</p><p>在HTTP1.1以后默认采用的是持续的连接;目前对于同一个域,大多数浏览器支持同时建立 6 个持久连接</p><h1 id="HTTP-协议的各个版本"><a href="#HTTP-协议的各个版本" class="headerlink" title="HTTP 协议的各个版本"></a>HTTP 协议的各个版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议; 它不涉及数据包传输,主要规定了客户端和服务器之间的通信格式,默认使用80端口</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>最早的版本是0.9版本,该版本及其简单,只有一个命令 <code>GET</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / index.<span class="property">html</span></span><br><span class="line"><span class="comment">// TCP 连接建立后,客户端向服务器请求网页 index.html</span></span><br></pre></td></tr></table></figure><p>协议规定,服务器只能回应 HTML 格式的字符串,不能回应别的格式<br>服务器发送完毕,就关闭 TCP 连接</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP1.0 版本发布,内容大大增加</p><ol><li>首先,任何格式内容都可以发送; 可以传输文字 / 图像 / 视频 / 二进制 文件 </li><li>除了 <code>GET</code> 命令,还引入了 <code>POST</code> / <code>HEAD</code> 命令,使传输信息变得更丰富</li><li>HTTP 请求和回应格式也发生改变了,每次通信都必须包含头信息,用来描述一些元数据</li><li>新增状态码 / 缓存 / 内容编码 / 字符编码 /等等</li></ol><h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p>字符编码,1.0版规定,头信息必须是 ASCII 码,后面的数据可以是任何格式;<br>因此服务器回应的时候,必须告诉客户端,数据是什么格式,这就是 <code>Content-type</code> 字段的作用<br>常见的 <code>Content-type</code> 字段的值</p><ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg<br>…</li></ul><h3 id="Content-Encoding-字符"><a href="#Content-Encoding-字符" class="headerlink" title="Content-Encoding 字符"></a>Content-Encoding 字符</h3><p>由于发送的数据可以是任何格式,因此可以把数据压缩后再发送; <code>Content-Encoding</code> 字段说明数据的压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure><p>客户端请求时,用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gizp,deflate</span><br></pre></td></tr></table></figure><h3 id="HTTP-1-0-的缺点"><a href="#HTTP-1-0-的缺点" class="headerlink" title="HTTP/1.0 的缺点"></a>HTTP/1.0 的缺点</h3><p>每次 TCP 连接只能发送一个请求,发送数据完毕,连接就关闭,如果还要请求其他资源,就必须再新建一个连接<br>TCP 连接的新建成本高,所以 HTTP/1.0 版本性能较差<br>为了解决这个问题,有些浏览器在请求时,用了一个非标准的 <code>Connection</code> 字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这个字符要求服务器不要关闭 TCP 连接,以便其他请求复用,服务器同样回应这个字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>:keep-alive</span><br></pre></td></tr></table></figure><p>这样一个可以复用的 TCP 连接就建立了,直到客户端或服务器主动关闭连接,但是,这不是标准字段,不同实现的行为可能不一致,因此不是根本的解决方法</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1版本的发布,它进一步完善了 HTTP 协议</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>1.1版本的最大变化,就是引入了持久连接,即 TCP 连接默认不关闭,可以被多个请求复用,不用声明 <code>Connection:keep-alive</code><br>客户端和服务器发现对方一段时间没有活动,就可以主动关闭连接;不过,规范的做法是,客户端在最后一个请求时,发送 <code>Connection: close</code>,明确要求服务器关闭 TCP 连接,对于同一个域名,大多数浏览器允许同时建立 6 个持久连接</p><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>1.1版本引入了管道机制,即在同一个 TCP 连接里面,客户端可以同时发送多个请求,这样就进一步改进了 HTTP 协议的效率</p><p>举例来说,客户端需要请求两个资源,在1.1版本以前的做法是,在同一个 TCP 连接里面,先发送 A 请求,然后等待服务器做出回应,收到后再发送B请求,管道机制则是允许浏览器同时发送A请求和B请求,但服务器还是按照顺序,先回应A请求,完成后再回应B请求</p><p>另外增加了 <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> 等方法</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然1.1版本允许复用 TCP 连接,但是同一个 TCP 连接里面,所有的数据通信是依次进行的,服务器只有处理完一个回应,才会进行下一个回应,要是前一个回应特别慢,后面就会 有许多请排队等着,这称为 <code>队头阻塞</code><br>为了避免这个问题,只有两种方法: 一是减少请求数, 二是同时打开多个持久连接,这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。 </p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/2 是谷歌自行研发的 SPDY 协议,主要解决 HTTP/1.1 效率不高的问题</p><p>HTTP/2 主要有以下新的特性:</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/2 是一个二进制协议,在 HTTP/1.1 版本中,报文的头信息必须是文本(ASCII编码),数据体可以是文本,也可以是二进制,HTTP/2 则是一个彻底的二进制协议,头信息和数据体都是二进制的,并且统称为 “ 帧 “ ,可以分为头信息帧和数据帧<br>帧的概念是它实现多路复用的基础</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 实现了多路复用,HTTP/2 仍然复用 TCP 连接,但是一个连接里,客户端和服务器都可以同时发送多个请求或回应,而且不用按照顺序一一发送,这样就避免了 “队头阻塞” 的问题</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 使用了数据流的概念,因为HTTP/2 的数据包不是按顺序发送的,同一个连接里面连续的数据包,可能属于不同的请求;因此,必须要对数据包做标记,指出它属于哪个请求;HTTP/2 将每个请求或回应的所有数据包,称为一个数据流;<br>每个数据流都有一个独一无二的编号;数据包发送的时候,都必须标记数据流 ID ,用来区分它属于哪个数据流</p><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP/2 实现了头信息压缩,由于 HTTP 1.1 协议不带有状态,每次请求都必须附上所有信息,所以请求的很多字段都是重复的,比如 Cookie 和 User Agent,一模一样的内容,每次请求都必须附带,这会浪费很多带宽,也影响速度</p><p>HTTP/2 对这一点做了优化,引入了头新压缩机制,一方面,头信息使用 gzip 或 compress 压缩后再发送;另一方面,客户端和服务器同时维护一张头信息表,所有字段都会存入这个表,生成一个索引号,以后就不发送同样字段了,只发送索引号,这样就能提供速度了</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求,主动向客户端发送资源,这叫做服务器推送,使用服务器推送,提前给客户端提送必要的资源,这样就可以相对减少一些延迟时间,这里需要注意的是 HTTP2 下服务器主动推送的是静态资源和 webSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的</p><h3 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h3><p>因为 HTTP/2 使用了多路复用,一般来说同一域名下只需要使用一个 TCP 连接,由于多个数据流使用同一个 TCP 连接,遵守同一个同一个流量状态控制和拥塞控制,只要一个数据流遭遇拥塞,剩下的数据流就没法发出去,这样就导致了后面的所有数据都被阻塞, HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题,与它本身的实现没有多大关系</p><h2 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h2><p>由于 TCP 本身存在的一些限制,Google 就开发了一个基于 UDP 协议的 QUIC 协议,并且使用在了 HTTP/3上,QUIC 协议在 UDP 协议上实现了 多路复用 / 有序交付 / 重传 等等功能</p><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ol><li>HTTP 报文使用明文的方式发送,可能被第三方窃听</li><li>HTTP 报文可能被第三方截取后修改通信内容,接收方没有办法发现报文内容的修改</li><li>HTTP 还存在认证的问题,第三方可以冒充他人参与通信</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS 指的是超文本传输安全协议,HTTPS 是基于 HTTP 协议的,不过它会使用 TLS/SSL 来对数据加密,使用 TLS/SSL 协议,所有的信息都是加密的,第三方没有办法窃听;并且它提供了一种校验机制,信息一旦被篡改,通信的双方会立刻发现,它还配备了身份证书,防止身边被冒充的情况出现</p><h2 id="TLS-握手实现原理"><a href="#TLS-握手实现原理" class="headerlink" title="TLS 握手实现原理"></a>TLS 握手实现原理</h2><p>TLS 的握手过程主要用到了三个方法来保证传输的安全</p><ol><li><p>首先的对称加密的方法,对称加密的方法是,双方使用同一个密钥对数据进行加密和解密,但对称加密存在的一个问题就是如何保证密钥传输的安全性,因为密钥还是会通过网络传输的,一旦密钥被其他人获取到,那么整个加密过程就毫无作用;这就要用到非对称加密的方法</p></li><li><p>非对称加密的方法是,我们拥有两个密钥,一个是公钥,一个是私钥,公钥是公开的,私钥是保密的,用私钥加密的数据只有对应的公钥才能解密,我们可以将公钥公布出去,任务想和我们通信的客户,都可以使用我们提供的公钥对数据进行加密,然后使用私钥进行解密,这样就能保证数据的安全了,但是非对称加密有一个缺点就是加密的过程很慢,因此如果每次通信都使用非对称加密的方法的话,反而会造成等待时间过长的问题; 因此我们可以使用对称加密和非对称加密结合的方法,因为对称加密方式的缺点就是无法保证密钥的安全传输,因此我们可以以非对称加密方式来对对称加密的密钥进行传输,然后以后通信使用对称加密的方式来加密,这样就解决了两个方法各种存在的问题</p></li><li><p>但是现在的方法也不一定是安全的,因为我们没有办法确定我们得到的公钥就一定是安全的公钥,可能存在一个中间人,截取了对方发给我们的公钥,然后将他自己的公钥发送给我们,当我们使用他的公钥加密后发送的信息,就可以被他用自己的私钥解密,然后伪装我们以同样的方法向对方发送信息,这样我们的信息就被窃取了,然而我们自己还不知道<br>为了解决这样的问题,我们可以使用数字证书的方式,首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要,然后让有公信力的认证中心,用它的私钥对消息摘要加密,形成签名,最后将原始的信息和签名结合在一起,称为数字证书,当接收方接收到数字证书的时候,先根据原始信息使用同一的 Hash 算法生成一个摘要,然后使用公证处的公钥来对数字证书中的摘要进行解密,最后将解密的摘要和我们生成的摘要进行对比,就能发现我们得到的信息是否被更改了这个方法最重要的是认证中心的可靠性,一般浏览器里会内置一些顶层的认证中心的证书,相当与我们自动信任了他们,只有这样我们才能保证数据的安全</p></li></ol><h1 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h1><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和HTTPS 使用端口不一样,前者是80, 后者是443</li><li>HTTP 协议运行在 TCP 之上,所有传输的内容都是明文,HTTPS 运行在 SSL/TLS 之上, SSL/TLS 运行在 TCP 之上,所有传输的内容都是密文传输 </li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h1&gt;&lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP HTTPS" scheme="https://monthlygirl.github.io/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://monthlygirl.github.io/2021/03/JavaScript.html"/>
    <id>https://monthlygirl.github.io/2021/03/JavaScript.html</id>
    <published>2021-03-01T13:04:53.000Z</published>
    <updated>2021-03-01T13:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li>在 js 中我们是使用构造函数来新建一个对象的,每一个构造函数的内部都有一个 prototype 属性,这个属性是一个对象,这个对象上包含了该构造函数的所有实例共享的属性和方法</li><li>当我们使用构造函数新建了一个对象后,在这个对象的内部包含一个指针 <code>__proto__</code>,这个指针指向该对象所属构造函数的 prototype 属性对应的值, 在ES5 中这个指针被称为 对象 的原型</li><li>一般来说我们是不能够获取到这个值的,但是现在的浏览器都实现了 <strong>proto</strong> 属性,让我们可以访问这个属性,但是最后不要用这个属性, 因为它不是规范中规定的</li><li>ES5 中新增了一个Object.getPrototypeOf()方法,我们可以通过这个方法来获取对象的原型</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>当我们访问一个对象的属性时,如果这个对象内部不存在这个属性,那么它就会去它的原型对象里找这个属性,这个原型对象又会有自己的原型,于是就这样一直找下去,这也就是原型链的概念.</li><li>原型链的尽头一般来说都是 object.prototype </li></ul><h2 id="原型和原型链的特点"><a href="#原型和原型链的特点" class="headerlink" title="原型和原型链的特点"></a>原型和原型链的特点</h2><ul><li>JavaScript 对象是通过引用来传递的,我们创建的每一个新对象实体中并没有 一份属于自己的原型,当我们修改原型时,与之相关的对象也会继承这一改变</li></ul><h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a>js 获取原型的方法</h2><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol><li>作用域: 当前代码对变量的访问权限(函数作用域,es6 let const 声明的块级作用域)</li><li>作用域链: 内层作用域访问一个变量,首先会在当前作用域的父级找,如果没找到,在往上一层找,直到找到全局,如果还没有找到就宣布放弃,这种一层一层向上的关系,就是作用域链,即以链式的方式访问变量</li></ol><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><ul><li>垃圾回收机制: 会自动释放内存,就是说一个函数执行完毕,内存中的空间会被释放,再一次调用的时候,函数内部会被重新赋值</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>读取函数内部的变量,让全局访问局部变量</li><li>延长变量的生命周期<h2 id="闭包的使用方式"><a href="#闭包的使用方式" class="headerlink" title="闭包的使用方式"></a>闭包的使用方式</h2></li></ol><ul><li>就是函数内部嵌套着另一个函数,这个函数在外部别调用,所以内存不会被回收,从而延长变量的生命周期</li></ul><h1 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h1><ul><li>递归就是函数自己调用函数自己,递归一定要有结束条件,否则会陷入死循环</li><li>使用场景: 遍历树的结构</li></ul><h1 id="js的异步机制"><a href="#js的异步机制" class="headerlink" title="js的异步机制"></a>js的异步机制</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/">《js的异步机制》</a></a></p><h1 id="事件循环机制-Event-Loop"><a href="#事件循环机制-Event-Loop" class="headerlink" title="事件循环机制(Event Loop)"></a>事件循环机制(Event Loop)</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/"><a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/">《事件循环机制Event Loop》</a></a></p><h1 id="什么是-Promise-对象-什么是-Promise-A"><a href="#什么是-Promise-对象-什么是-Promise-A" class="headerlink" title="什么是 Promise 对象? 什么是 Promise/A+ ?"></a>什么是 Promise 对象? 什么是 Promise/A+ ?</h1><ol><li>promise对象是异步编程的一种解决方案,最早由社区提出,promise/A+规范是javascript promise的规范,规定了一个promise所必须具有的特性</li><li>Promise 是一个构造函数,它接收一个函数作用参数, 并且返回一个promise实例,一个promise实例有三种状态,分别是pending,resolve,reject,对应着进行中,已完成,已失败,一个实例的状态只能由 pending 转换为 resolve 或由 pending 转换为 reject ,状态一经改变就凝固了,无法再改变,我们可以在异步操作结束后调用这两个函数改变promise的状态,一个状态一经改变可以通过 then 注册回调函数,可以立即得到结果</li></ol><h1 id="ES5-继承和-ES6-继承的区别"><a href="#ES5-继承和-ES6-继承的区别" class="headerlink" title="ES5 继承和 ES6 继承的区别"></a>ES5 继承和 ES6 继承的区别</h1><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><ul><li>ES5 的继承实质: 先创建子类,再实例化父类,并将父类的方法添加到子类的this中;可以通过原型或构造函数机制来实现</li><li>ES6 实质: 先创建父类,实例化子类通过调用super方法访问父类后,在通过修改this实现继承,super关键字指代父类的实例,即父类的this对象,在子类构造函数中,如果不调用super方法,子类得不到this对象</li><li>ES6 实现继承是通过关键字 <code>extends</code> <code>super</code> 来实现继承</li></ul><h1 id="new-的时候做了什么"><a href="#new-的时候做了什么" class="headerlink" title="new 的时候做了什么"></a>new 的时候做了什么</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型,将对象的原型设置为函数的 prototype 对象</li><li>让函数的 this 指向这个对象,执行构造函数的代码,为这个新对象添加属性</li><li>判断函数的返回值类型,如果是值类型,返回创建的对象;如果是引用类型,就返回这个引用类型的对象</li></ol><p>详情请看本站文章 <a href="http://localhost:4000/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"><a href="http://guestljz.gitee.io/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/">《如何实现一个 new》</a></a></p><h1 id="Ajax是什么-如何创建一个Ajax"><a href="#Ajax是什么-如何创建一个Ajax" class="headerlink" title="Ajax是什么? 如何创建一个Ajax?"></a>Ajax是什么? 如何创建一个Ajax?</h1><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li>AJAX,异步的 JavaScript 和 XML ,是一种实现 无页面刷新 获取数据的 混合技术 ,简单来说就是JavaScript执行异步请求<h2 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h2></li><li>比如,领导要找张三汇报工作,于是领导就委托秘书帮忙去叫张三,然后领导就继续忙自己的工作,直到秘书告诉领导张三到了,接着张三就开始汇报工作</li><li>AJAX 请求数据的流程 就跟 “领导找张三汇报工作相似” , 其中的核心 就是 <strong>秘书</strong>,<strong>秘书</strong>相当于浏览器的XMLHttpRequest对象,当浏览器发出HTTP请求与接收HTTP响应时,浏览器可以接着做其他的事情,直到收到xhr返回的数据渲染页面</li></ul><h2 id="AJAX-实现流程"><a href="#AJAX-实现流程" class="headerlink" title="AJAX 实现流程"></a>AJAX 实现流程</h2><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><h2 id="AJAX的状态"><a href="#AJAX的状态" class="headerlink" title="AJAX的状态"></a>AJAX的状态</h2><ul><li>0 表示未初始化,尚未调用open方法</li><li>1 启用open方法,数据发生</li><li>2 表示已调用open方法 接收到响应</li><li>3 表示正在解析</li><li>4 表示已完成</li></ul><p>详情请看本站文章 <a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/"><a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/">《Ajax》</a></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象,是一种编程开发思想,面向对象编程,它将真实世界各种复杂的关系,抽象为一个个对象,然后进行分工合作,完成对真实世界的模拟</li><li>面向对象的特性: 封装 / 多态 / 继承</li><li>面向对象就是对 <strong>现实世界理解和抽象的方法</strong><br>我对面向对象的理解就是: 面向对象的编程方式就是让每一个类都只做一件事,面向过程会让一个类越来越全能,就像是一个管家一样做了所有的事;而面向对象像是雇佣了一群职员,每个人做一件小事,各司其职,最终合作共赢</li></ul><h1 id="JSON-parse-和JSON-stringify"><a href="#JSON-parse-和JSON-stringify" class="headerlink" title="JSON.parse()和JSON.stringify()"></a>JSON.parse()和JSON.stringify()</h1><p>JSON.parse()把字符串解析成对象<br>JSON.stringify()从对象中解析出字符串</p><h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>详情请看本站文章 <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">《事件模型》</a></a> </p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托本质上是利用了浏览器事件冒泡的机制,因为事件在冒泡过程中会上传到父节点,并且父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件代理</p><p>使用事件代理我们可以不不必要为每一个子元素都绑定一个监听事件,这样减少了内存上的消耗,并且使用事件代理我们还可以实现事件的动态绑定,比如说新增了一个子节点,我们并不需要单独第为它添加一个监听事件,它所它发生的事件会交给父元素中的监听函数来处理</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行环境(即执行上下文中)存在着执行代码的的私有作用域,上层作用域的指向,方法的参数,这个作用域中定义的变量以及这个作用域的this对象等等</p><h1 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h1><p>基本数据类型: 栈内存 先进后出<br>复杂数据类型: 堆内存 优先队列,复杂数据类型将值报存在堆中,将值对应的指针保存在栈中,通过栈中的指针来获取堆中的值</p><h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>详情请看本站文章  <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/">《模块化》</a></a></p><h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><p><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/">《ES6 中新增特性》</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件模型</title>
    <link href="https://monthlygirl.github.io/2021/03/Event_Model.html"/>
    <id>https://monthlygirl.github.io/2021/03/Event_Model.html</id>
    <published>2021-03-01T13:04:53.000Z</published>
    <updated>2021-03-01T13:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事件模型</p><h2 id="DOM0-级模型"><a href="#DOM0-级模型" class="headerlink" title="DOM0 级模型"></a>DOM0 级模型</h2><ul><li>第一周事件模型是最早的 DOM0 级模型,这种模型不会传播,所以没有事件流的概念,但是现在有的浏览器支持一冒泡的方式实现,它可以在网页中直接定义监听函数,也可以通过 js 属性来指定监听函数,这种方式是所有浏览器都兼容的</li></ul><h2 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h2><ul><li>第二种事件模型 是 IE 事件模型,在该事件模型中,一次事件共有两个过程,事件处理阶段,和事件冒泡阶段;事件处理阶段会首先执行目标元素绑定的监听事件;然后是事件冒泡阶段,冒泡指的是事件从目标元素冒泡到 document,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,这种模型通过 attachEvent 来添加监听函数,可以添加多个监听函数,会按顺序一次执行</li></ul><h2 id="DOM2-级模型"><a href="#DOM2-级模型" class="headerlink" title="DOM2 级模型"></a>DOM2 级模型</h2><ul><li>第三种是 DOM2 级事件模型,在该事件模型中,一次事件共有三个过程,第一个过程是事件捕获阶段;事件捕获指的是事件从 document 一直向下传播到目标元素,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,后面这两个阶段和 IE 事件模型的两个阶段相同,这种事件模型,事件绑定函数式 addEventListener,其中第三个参数可以指定事件是否在捕获阶段执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三种事件模型是什么&quot;&gt;&lt;a href=&quot;#三种事件模型是什么&quot; class=&quot;headerlink&quot; title=&quot;三种事件模型是什么?&quot;&gt;&lt;/a&gt;三种事件模型是什么?&lt;/h1&gt;&lt;p&gt;事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM0级 DOM2级" scheme="https://monthlygirl.github.io/tags/DOM0%E7%BA%A7-DOM2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://monthlygirl.github.io/2021/03/Module.html"/>
    <id>https://monthlygirl.github.io/2021/03/Module.html</id>
    <published>2021-03-01T13:04:53.000Z</published>
    <updated>2021-03-01T13:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所以并没有模块化的概念,但随着程序越来越复杂,代码的模块化开发变得越来越重要</p><p>由于函数具有独立作用域的特点,最原始的写法是使用函数来作为模块,几个函数作用一个模块,但是这种方法容易造成全局污染,且模块间没有联系</p><p>后来提出了对象的写法,通过将函数作为一个对象的方法来实现,这样解决了直接使用函数作用模块的一些缺点,但是这种办法会暴露所以的模块成员,外部代码可以修改内部属性的值</p><p>也可以使用立即执行函数的写法,通过利用闭包来实现模块私有作用域的建立,同时不会对全局作用域造成污染</p><p>简单来说:模块化就是 把函数作为模块 ,<br>缺陷: 污染全局变量, 模块成员之间没什么关系<br>方法: 面向对象思想 ,并使用立即执行函数 ,实现闭包 避免了变量污染 同时同一模块内的成员也有了关系 在模块外部无法修改我们没有暴露出来的变量、函数 这就是简单的模块</p><h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="headerlink" title="js 的几种模块规范"></a>js 的几种模块规范</h2><ol><li><p>CommonJS 方法,它通过 require 来引入模块,通过 module.exports 定义模块的输出接口,这种模块加载方案是 服务端的解决方法,它是以同步的方式来引入模块的,因为在服务DAU文件都存储在本地磁盘,读取非常快,所以以同步的方式加载没有问题但如果是在浏览器端,由于模块加载时使用网络请求,因此使用异步加载的方式更加合适</p></li><li><p>AMD 方法,这种方法采用异步加载的方式来加载模块,模块的加载不影响后面语句的执行,所有依赖这个模块的语句都定义在一个回调函数里,等到加载完成后再执行回调函数 require.js 实现了 AMD 规范</p></li><li><p>CMD 方案,这种方案和 AMD 方案都是为了解决异步模块加载的问题,sea.js实现了 CMD 规范,它和require.js 的区别在于模块定义时对依赖的处理不同对依赖模块的执行时机的处理也不同</p></li><li><p>ES6 提出的方案,使用 import 和 export 的形式来导入导出模块,这种方案和上面三种方案都不同</p></li></ol><h1 id="AMD-和-CMD-规范的区别"><a href="#AMD-和-CMD-规范的区别" class="headerlink" title="AMD 和 CMD 规范的区别"></a>AMD 和 CMD 规范的区别</h1><p>主要区别在两个方面</p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同,AMD 推崇依赖前置,在定义模块的时候就要声明其依赖的模块,而 CMD 推崇就近依赖,只有利用某个模块的时候再去 require</p></li><li><p>第二个方面试依赖模块的执行时机处理不同,首先 AMD 和 CMD 对于模块的加载方式都是异步加载,不过他们在于模块的执行时机,AMD 在依赖模块加载完成后就直接执行依赖模块,依赖模块的执行顺序和我们书写的顺序不一定一致,而 CMD 在依赖模块加载完成后并不执行,只是下载而已,等到所有的依赖模块都加载好后,进入回调函数逻辑,遇到require语句时才执行对应模块</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化开发怎么做&quot;&gt;&lt;a href=&quot;#模块化开发怎么做&quot; class=&quot;headerlink&quot; title=&quot;模块化开发怎么做&quot;&gt;&lt;/a&gt;模块化开发怎么做&lt;/h1&gt;&lt;p&gt;模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="模块化" scheme="https://monthlygirl.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6中新增的特性</title>
    <link href="https://monthlygirl.github.io/2021/02/ES6.html"/>
    <id>https://monthlygirl.github.io/2021/02/ES6.html</id>
    <published>2021-02-27T17:09:02.000Z</published>
    <updated>2021-02-27T17:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><h1 id="新增块级作用域"><a href="#新增块级作用域" class="headerlink" title="新增块级作用域"></a>新增块级作用域</h1><h2 id="通过let-定义块级作用域"><a href="#通过let-定义块级作用域" class="headerlink" title="通过let 定义块级作用域"></a>通过let 定义块级作用域</h2><ol><li>没有变量提升,变量必须先声明后使用</li><li>通过let 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a)  //报错 必须先定义后使用</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>   <span class="comment">//在全局中定义可以在全局中使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// let a =  1  // 报错不能重复定义相同的变量名</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>   <span class="comment">//只能在当前块,当前大括号中使用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过const声明"><a href="#通过const声明" class="headerlink" title="通过const声明"></a>通过const声明</h2><ol><li>const声明变量的同时必须初始化,一旦初始化后这个变量的值就不允许修改</li><li>const声明变量也是一个块级作用域的变量,只能在当前块使用</li><li>const声明的变量也没有变量提升,必须先声明后使用</li><li>const 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//报错,a不允许修改</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="新增函数特性"><a href="#新增函数特性" class="headerlink" title="新增函数特性"></a>新增函数特性</h1><h2 id="函数可以设置默认参数"><a href="#函数可以设置默认参数" class="headerlink" title="函数可以设置默认参数"></a>函数可以设置默认参数</h2><p>在我们调用函数时,如果设置了默认形参,如果没有给函数传参,那么函数可以使用默认形参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b )  <span class="comment">//输出 a=1,b=2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun2</span>(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//输出 a=10,b=20</span></span><br><span class="line"><span class="title function_">fun2</span>(<span class="number">10</span>) <span class="comment">//输出 a=10,b=2</span></span><br></pre></td></tr></table></figure><p>同样,在构造函数中也可以使用此方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,sex,age=<span class="number">10</span></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">sex</span> =sex</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> guestljz = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;guestljz&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;guestljz: &#x27;</span>, guestljz);  <span class="comment">//guestljz: Person &#123;name: &quot;guestljz&quot;, age: 10, sex: &quot;女&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5中的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun3</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数的几种写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun4</span>= (<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3.</span>..</span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 书写语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果箭头函数只有一个形参,可以省略括号不写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun5</span> = abc=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数的花括号后面只有一句语句,可以省略花括号不写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun6</span> = abc=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数花括号后面只有一句语句,并且需要立即返回一个值,那么可以将花括号改写成 ()</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun7</span> = abc =&gt; ( n=abc )</span><br></pre></td></tr></table></figure><p>使用箭头函数,我们可以使用多种方式书写函数,并且更简洁,更方便<br>但值得注意的是,在箭头函数中,没有this,换句话说,箭头函数中的this是外部作用域中的this</p><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>关于this指向问题相关 参考  <a href="https://guestljz.gitee.io/2021/02/27/JavaScript/this%E6%8C%87%E5%90%91/">《this指向问题》</a></p><h1 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h1><p>将一个个数据打开成为一个个的状态,通过用它来展开数组或对象,也可以在函数传递参数的时候使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)   <span class="comment">//输出 [1,2,3,4,5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(..<span class="property">arr</span>)  <span class="comment">//输出 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将多个数组合并成一个数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> newArr2 = [...arr2,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr2) <span class="comment">//输出一个新数组  [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给函数传递参数使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun8</span>()=<span class="function">(<span class="params">a,b,c</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c: &#x27;</span>, c);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b: &#x27;</span>, b);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="title function_">fun8</span>(...arr3)</span><br></pre></td></tr></table></figure><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>快速从对象或者数组中获取成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象中的结果赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125;=&#123;<span class="attr">foo</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">bar</span>:<span class="string">&#x27;bbb&#x27;</span>&#125;  <span class="comment">//foo = aaa, bar=bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成这种形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">  <span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name,age,gender &#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>:a&#125; = obj </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> a = obj.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换变量</span></span><br><span class="line"><span class="keyword">let</span> [n1,n2] = [n2,n1]</span><br></pre></td></tr></table></figure><h1 id="新增字符串方法"><a href="#新增字符串方法" class="headerlink" title="新增字符串方法"></a>新增字符串方法</h1><h2 id="string-includes"><a href="#string-includes" class="headerlink" title="string.includes()"></a>string.includes()</h2><p>  判断字符串是否包含一个指定的值,返回一个布尔值,表示是否找到了参数字符串。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;d&quot;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p> 还支持第二个参数,从哪个位置开始查找<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.<span class="title function_">includes</span>(<span class="string">&quot;g&quot;</span>,<span class="number">4</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="string-startsWith"><a href="#string-startsWith" class="headerlink" title="string.startsWith()"></a>string.startsWith()</h2><p>表示参数字符串是否在原字符串的头部,返回一个布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>同样也支持第二个参数,表示从哪个位置开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;abc efg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.<span class="title function_">startsWith</span>(<span class="string">&quot;efg&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="string-endsWith"><a href="#string-endsWith" class="headerlink" title="string.endsWith()"></a>string.endsWith()</h2><p> 返回布尔值，表示参数字符串是否在原字符串的尾部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.<span class="title function_">endsWith</span>(<span class="string">&quot;g&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也支持第二个参数,这个第二参数表示,从第0个到第n个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.<span class="title function_">endsWith</span>(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还有许多,详看 阮一峰的es6教程</p><h1 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h1><ul><li>Map 和 Set 是 ES6 新增的两个数据类型</li><li>都是属于内置构造函数</li><li>使用 new 的方式来实例化使用</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>Set 是一个构造函数,用来生成 Set 数据结构,它类似于数组,但是成员的值都是唯一的 , 没有重复的,初始化 Set 可以接受一个数组或类数组对象作为参数,也可以创建一个空的 Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">        size: (...)</span></span><br><span class="line"><span class="comment">        __proto__: Set</span></span><br><span class="line"><span class="comment">        [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">        length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>我们可以在 new 的时候直接向内部添加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化的时候直接添加数据,要以数组的形式添加</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Set(7) &#123;1, 2, 3, &#123;…&#125;, ƒ, …&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Set</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(7)</span></span><br><span class="line"><span class="comment">    0: 1</span></span><br><span class="line"><span class="comment">    1: 2</span></span><br><span class="line"><span class="comment">    2: 3</span></span><br><span class="line"><span class="comment">    3: Object</span></span><br><span class="line"><span class="comment">    4: function () &#123;&#125;</span></span><br><span class="line"><span class="comment">    5: true</span></span><br><span class="line"><span class="comment">    6: &quot;hwllo&quot;</span></span><br><span class="line"><span class="comment">    length: 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>看上去是一个类似数组的数据结构,但不是数组,是<strong>Set 数据结构</strong></p></li></ul></li></ul><h3 id="常用的方法和属性"><a href="#常用的方法和属性" class="headerlink" title="常用的方法和属性"></a>常用的方法和属性</h3><ul><li><p><code>size</code> : 用来获取该数据结构中有多少数据的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">//7</span></span><br></pre></td></tr></table></figure><ul><li>看上去是一个和数组数据类型差不多的数据结构,而且也看到的 length 属性</li><li>但是不能使用,想要获取该数据类型中的成员数量,<strong>需要使用 size 属性</strong></li></ul></li><li><p><code>add</code> : 用来向该数据类型中追加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">0</span>)</span><br><span class="line">s.<span class="title function_">add</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>&#125;)</span><br><span class="line">s.<span class="title function_">add</span>(&#123;<span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有点饿了&quot;</span>)&#125;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>这个方法就是向该数据类型中追加数据使用的</li></ul></li><li><p><code>delete</code> : 用来删除该数据结构中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">s.<span class="title function_">delete</span>(&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清空数据结构中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> : 查询数据结构中有没有某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">0</span>))  <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(&#123;&#125;))  <span class="comment">// true</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code> : 用来遍历 Set 数据结构的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s&#x27;</span>, s.<span class="property">size</span>)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数据结构的每一项</span></span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function"><span class="params">ietm</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ietm: &#x27;</span>, ietm);</span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ietm:  1</span></span><br><span class="line"><span class="comment">  ietm:  2</span></span><br><span class="line"><span class="comment">  ietm:  3</span></span><br><span class="line"><span class="comment">  ietm:  &#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  ƒ ()&#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  true</span></span><br><span class="line"><span class="comment">  ietm:  hello</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>方法介绍差不多了,但是有一个问题出现了,那就是</p></li><li><p>我们的方法添加 / 删除 / 查询 ,没有获取</p></li><li><p>获取 Set 结构里面的数据需要借助一个  <code>...</code> 展开运算符</p></li><li><p>把他里面的东西都放到一个数组里面去,然后再去获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">const</span> a = [...s1]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a: &#x27;</span>, a)</span><br><span class="line"><span class="comment">// 输出 a: (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>,a[<span class="number">0</span>])  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>又有一个问题出现了,new的时候需要以数组的形式传递</p></li><li><p>然后获取的时候又要转成数组的形式获取</p></li><li><p>那为什么不一开始就定义数组,为什么要弄一个 Set 数据类型?</p></li><li><p>这不得不提到一个 Set 的特点</p></li><li><p><strong>Set 不允许存储重复的数据</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">2</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">3</span>)  <span class="comment">//此时 size 是4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><p>Map 是一个构造函数,用来生成 Map 数据结构,它类似于对象,也是键值对的集合,但是”键”可以是非字符串,初始化 Map 需要一个二维数组,或者直接初始化一个空的 Map:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Map(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Map</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">    length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>在对象中不管存储什么, key 一定是一个字符串类型,对象是一个键值对 的集合 key : value</p></li><li><p>但是在 Map 里面,key 可以任意数据类型</p></li><li><p>Map 也可以叫做 (值 = 值) 的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"> <span class="comment">//   初始化的时候就给一些值</span></span><br><span class="line"> <span class="comment">//   传递的参数需要是一个数组</span></span><br><span class="line"> <span class="comment">//   数组需要是一个 二维数组</span></span><br><span class="line"> <span class="comment">//   二维数组里面的每一个小数组接受两个数据</span></span><br><span class="line"> <span class="comment">//   这个两个数据可以是任意数据类型</span></span><br><span class="line"> <span class="comment">//   这个两个数据第一个就是 key，第二个就是 value</span></span><br><span class="line"> <span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>], [&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;, <span class="number">18</span>]])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性"></a>常用方法和属性</h3><ul><li><p><code>size</code> ： t用来获取该数据类型中数据的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>delete</code> : 用来删除该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line">  m.<span class="title function_">delete</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>set</code> : 用来向该数据集合中添加数据使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>get</code> : 用来获取该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="literal">true</span>)) <span class="comment">// function () &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清除数据集合中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">clear</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> ： 用来判断数据集合中是否存在某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="literal">true</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>forEach ：遍历 MAP 数据集合中的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">m.<span class="title function_">set</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><ul><li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p></li><li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 **``**（反引号）</p></li><li><p>区别是使用 **``**（反引号）我们可以在字符串里面使用 <code>$&#123;变量名&#125;</code> 拼接变量</p></li><li><p>使用 单引号再字符串中不能直接换行,使用反引号可以直接换行</p></li></ul><h1 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h1><ul><li><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p></li><li><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></li><li><p>在创建symbol类型数据时的参数只是作为标识使用，直接使用 Symbol() 也是可以的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;xm&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( s );</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">typeof</span> s );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</span></span><br><span class="line"> <span class="keyword">var</span> xm = <span class="title class_">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     [xm] : <span class="string">&quot;小明&quot;</span> <span class="comment">//对象的属性是Symbol类型</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Symbol类型的属性 取值是 必须 obj[xm] 不能用obj.xm</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj[xm] );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> s4 = <span class="title class_">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xm&#x27;</span>,</span><br><span class="line">     [s4]: <span class="string">&#x27;xh&#x27;</span>,</span><br><span class="line">     [<span class="title class_">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &quot;xm&quot;, Symbol(): &quot;xh&quot;, Symbol(age): 18&#125;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// xm</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[s4]); <span class="comment">// xh 访问对象的Symbol属性的值</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改symbol类型的属性</span></span><br><span class="line"> obj[xm] = <span class="string">&quot;web前端&quot;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj[xm] );</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> <span class="comment">//对象的Symbol属性不会被遍历出来（可以用来保护对象的某个属性）</span></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&quot;sname&quot;</span>:<span class="string">&quot;小明&quot;</span>,</span><br><span class="line">     <span class="string">&quot;skill&quot;</span> : <span class="string">&quot;web&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="title class_">Symbol</span>();</span><br><span class="line"> obj[age] = <span class="number">18</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( obj );</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; -&gt; &quot;</span> + obj[key] );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">     [id]: <span class="string">&#x27;007&#x27;</span>,</span><br><span class="line">     [<span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;xiaocuo&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> arr = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[Symbol(id),Symbol(name)]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[arr[<span class="number">0</span>]]);  <span class="comment">//&#x27;007&#x27;  访问对象的Symbol属性的值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</span></span><br><span class="line"> <span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( s1 === s2 ); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 官方提供了全局注册并登记的方法：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建 </span></span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回 </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name1 === name2); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过symbol对象获取到参数值：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;丽丽&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name1));  <span class="comment">// &#x27;张三&#x27;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name2)); <span class="comment">// &#x27;丽丽&#x27;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6-中新增特性&quot;&gt;&lt;a href=&quot;#ES6-中新增特性&quot; class=&quot;headerlink&quot; title=&quot;ES6 中新增特性&quot;&gt;&lt;/a&gt;ES6 中新增特性&lt;/h1&gt;&lt;h1 id=&quot;新增块级作用域&quot;&gt;&lt;a href=&quot;#新增块级作用域&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://monthlygirl.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>this指向</title>
    <link href="https://monthlygirl.github.io/2021/02/this.html"/>
    <id>https://monthlygirl.github.io/2021/02/this.html</id>
    <published>2021-02-27T14:31:25.000Z</published>
    <updated>2021-02-27T14:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><p>this是一个使用在作用域里面的关键字<br>this的指向只跟函数调用有关</p><ul><li>在全局中使用this,this === window ,this指向全局,但很少在全局中使用</li><li>一个函数的this指向只和函数的调用有关(箭头函数除外),不管怎么定义,在哪定义,分以下几种情况<ol><li>函数在全局中调用,那么this就指向全局</li><li>对象调用,this就指向当前对象</li><li>事件处理函数,this指向事件源</li><li>定时器处理函数,this指向window</li></ol></li></ul><h1 id="强行改变this指向"><a href="#强行改变this指向" class="headerlink" title="强行改变this指向"></a>强行改变this指向</h1><p>在ES5的函数中使用this,因为当不同的函数在不同的作用域中调用,this的指向也就不一样,通常需要强行改变this指向,改变this指向可以通过以下三种方法 </p><h2 id="1-call"><a href="#1-call" class="headerlink" title="1. call()"></a>1. call()</h2><ul><li>直接在函数名后面使用</li><li>正常调用方式: fn(),obj.fn()</li><li>强行改变this指向方式: fn.call(),obj.call()</li><li>参数(两个参数及以上)<br>call(参数1,参数2…)<br>第一个参数表示: this要指向哪里,不传或传null,表示this指向window<br>第二个参数开始:传递给函数的参数,供函数内部使用</li><li>作用: 改变函数内部的this指向</li><li>特点: 会直接调用函数,函数会被立即执行</li></ul><h2 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply()"></a>2. apply()</h2><p>   使用方式与call一样</p><ul><li>参数:<br>apply(参数1,参数2)<br>第一个参数表示:改变this指向的对象,不传或传null,表示this指向window<br>第二个参数:是一个数组或伪数组,数组中存放传递给函数 的参数,供函数内部使用</li><li>作用:改变函数内部的this指向,函数会被立即执行</li><li>特点: 改变函数传参的方式</li></ul><h2 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. bind()</h2><p>  使用方式和前两个一样,参数与call一样</p><ul><li>作用: 改变函数内部this指向,函数不会被立即执行</li><li>特点:<br>不会直接调用函数,返回一个新函数,这个新函数中的this指向已经改变,在我们需要时调用执行即可<br>bind改变过后,this指向不会再改变了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向问题&quot;&gt;&lt;a href=&quot;#this指向问题&quot; class=&quot;headerlink&quot; title=&quot;this指向问题&quot;&gt;&lt;/a&gt;this指向问题&lt;/h1&gt;&lt;p&gt;this是一个使用在作用域里面的关键字&lt;br&gt;this的指向只跟函数调用有关&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="this" scheme="https://monthlygirl.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>React总结</title>
    <link href="https://monthlygirl.github.io/2021/02/React.html"/>
    <id>https://monthlygirl.github.io/2021/02/React.html</id>
    <published>2021-02-22T21:49:17.000Z</published>
    <updated>2021-02-22T21:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React中的key的作用"><a href="#React中的key的作用" class="headerlink" title="React中的key的作用"></a>React中的key的作用</h1><blockquote><p>key可以帮助React跟踪循环列表中的虚拟DOM,以此来了解哪些元素是已更改 / 添加 / 删除 的</p><p>react利用key来识别组件,它是一种唯一标识,相同的key React会认为是同一个组件,后续相同key对应组件都不会被创建</p><p>有了key属性后,就可以与组件建立相应的关系,react根据key来决定组件是销毁还是更新</p><p>如果key相同,组件的属性有所变化,那么react只更新组件对应的属性,没有变化则不更新</p><p>key值不同,那么react先销毁该组件,然后在重新创建组件</p></blockquote><h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><h3 id="1-挂载阶段-有3个常用的生命周期"><a href="#1-挂载阶段-有3个常用的生命周期" class="headerlink" title="1.挂载阶段,有3个常用的生命周期"></a>1.挂载阶段,有3个常用的生命周期</h3><ol><li>construtor()<br>实例被初始化时会调用这个函数,是所有生命周期中第一个执行的函数,可以在这里定义声明式变量</li><li>componentDidMount()<br>实例初始化完成,这个生命周期只执行一次,再次更新视图时不执行,可以在这里修改state,调接口,建立长连接</li><li>render()<br>所有生命周期中必须要有的生命周期,且一定要有返回值,并且返回的是一个jsx对象,它在挂载阶段和更新阶段都会zhixing</li></ol><h3 id="2-更新阶段-有2个常用的生命周期"><a href="#2-更新阶段-有2个常用的生命周期" class="headerlink" title="2.更新阶段,有2个常用的生命周期"></a>2.更新阶段,有2个常用的生命周期</h3><ol><li>componentUpdate()<br>它表示视图已更新完成,每次更新State中的数据,都会执行componentUpdate()和render()</li><li>shouldComponentUpdate()<br>它的作用是在类组件中提升性能,抽离出不参与视图渲染的数据,让它们不参与diff运算<br>这个生命周期必要要有一个返回值,且返回值是一个布尔值,返回false时不更新</li></ol><h3 id="3-销毁阶段-只有一个生命周期"><a href="#3-销毁阶段-只有一个生命周期" class="headerlink" title="3.销毁阶段,只有一个生命周期"></a>3.销毁阶段,只有一个生命周期</h3><ol><li><p>componentWillUnMount()<br>它表示组件将要被销毁,一般在这里清除定时器 / 缓存 / 长连接 等</p><h1 id="调用setState之后发生了什么"><a href="#调用setState之后发生了什么" class="headerlink" title="调用setState之后发生了什么"></a>调用setState之后发生了什么</h1></li></ol><ul><li>在代码中调用setState之后,React会将传入的参数对象与当前的状态进行合并,然后触发调和过程</li><li>经过调和过程,React会以相对高效的方式根据新的状态构建React虚拟DOM树,并且开始准备重新渲染UI界面</li><li>React在得到虚拟DOM树后,会先比较新得到的树和老树的差异,然后根据diff运算进行界面的最小化渲染</li><li>在diff运算算法中,React能够精确的知道哪些元素发生了变化,以及应该如何变化,这就保证了按需更新,而不是全部更新</li></ul><h1 id="多次触发setState-那么render会执行几次"><a href="#多次触发setState-那么render会执行几次" class="headerlink" title="多次触发setState,那么render会执行几次"></a>多次触发setState,那么render会执行几次</h1><ul><li>多次的setState最终会合并成一次render,因为setState不能立即修改state的值,而是将它放到一个任务队列中,最终多个setState会被合并,一次性更新页面</li><li><strong>传入对象会被合并</strong></li><li><strong>传入函数不会被合并,函数无法合并</strong></li></ul><h1 id="setState什么时候同步-什么时候异步"><a href="#setState什么时候同步-什么时候异步" class="headerlink" title="setState什么时候同步?什么时候异步?"></a>setState什么时候同步?什么时候异步?</h1><ol><li>如果是由React引发的事件处理(如:通过onClinck触发的事件处理),此时<code>setState</code>是异步的,它不会同步更新<code>this.state</code>,并且多个<code>setState</code>在执行过程中会被合并;除此之外,<code>setState</code>是同步的,而这里的”除此之外”是指绕过react,使用原生DOM事件(如addEventListener)调用<code>setState</code>,还有通过 <code>setTimeOut</code> / <code>setInterval</code> 执行<code>setState()</code>,此时<code>setState</code>是同步的</li></ol><h1 id="为什么要调用setState而不是直接修改state"><a href="#为什么要调用setState而不是直接修改state" class="headerlink" title="为什么要调用setState而不是直接修改state"></a>为什么要调用setState而不是直接修改state</h1><ul><li>如果你尝试直接state,那么react将接收不到state被修改的信息,即它无法知道它需要重新渲染组件;因此需要调用 <code>setState()</code>方法,这样react才会更新UI组件</li></ul><h1 id="this-setState-之后React都做了哪些工作"><a href="#this-setState-之后React都做了哪些工作" class="headerlink" title="this.setState 之后React都做了哪些工作"></a>this.setState 之后React都做了哪些工作</h1><ul><li>shouldcomponentUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><h1 id="虚拟DOM是如何工作的"><a href="#虚拟DOM是如何工作的" class="headerlink" title="虚拟DOM是如何工作的"></a>虚拟DOM是如何工作的</h1><ul><li>当数据发生变化时,比如setSTate时,会引起组件的重新渲染,整个UI都会以虚拟DOM的形式重新渲染</li><li>然后React就会收集差异进行diff运算,diff运算会找出虚拟DOM中的脏节点</li><li>最后将差异队列中的差异渲染到真实的DOM上</li></ul><h1 id="为什么要使用虚拟DOM"><a href="#为什么要使用虚拟DOM" class="headerlink" title="为什么要使用虚拟DOM"></a>为什么要使用虚拟DOM</h1><ul><li>频繁的DOM操作,会导致页面的重绘和回流,出于性能考虑,我们要减少页面的重绘和回流<h2 id="什么是重绘"><a href="#什么是重绘" class="headerlink" title="什么是重绘"></a>什么是重绘</h2></li><li>当DOM树中一些元素需要更新属性,而这些属性只是影响元素的外观,风格,不影响元素的布局时,称为重绘,比如:修改background-color,这就叫重绘<h2 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h2></li><li>当DOM树中,因为元素的尺寸,规模,布局时需要重新构建时,便称为回流,一个DOM树中,至少经历一次回流,就是页面初始化渲染时<h2 id="重绘和回流的区别"><a href="#重绘和回流的区别" class="headerlink" title="重绘和回流的区别"></a>重绘和回流的区别</h2></li><li>回流一定会引起重绘,重绘不一定会引起回流,比如当整个页面只有颜色发生改变时就只会发生重绘而不会引起回流</li><li>如果是元素的布局或几何属性发生改变时,就会引起回流,比如改变div的大小,加padding,margin等</li></ul><h1 id="虚拟DOM为什么会提高性能"><a href="#虚拟DOM为什么会提高性能" class="headerlink" title="虚拟DOM为什么会提高性能"></a>虚拟DOM为什么会提高性能</h1><ul><li>虚拟DOM相当于在js和真实的DOM中间加了一层缓存,利用DOM的diff避免过多的操作真实DOM,从而提升性能</li><li>用javascript对象表示DOM树</li><li>然后用这个对象树构建一个真正的DOM树,插到文档当中,当状态变更的时候,重新构造一颗新的对象树</li><li>之后进行diff运算,进行新老两树相比较,记录两颗树的差异从而将差异渲染到真实的DOM树中</li></ul><h1 id="diff运算原理"><a href="#diff运算原理" class="headerlink" title="diff运算原理"></a>diff运算原理</h1><ul><li>在传统做法中,diff运算是一个深度递归的过程,则就是将整颗树进行循环遍历进行比较,从而找出不同,效率低下,算法复杂度达到O(n^3)</li><li>所以react在diff运算上基于以下三个策略上做了很大的提升</li></ul><ol><li>web UI中DOM节点跨层级的移动操作特别少,可以忽略不计</li><li>拥有同类的两个组件将会生成相似的树形结构,拥有不同类的两个组件将会生成不同的树形结构</li><li>对于同一层级的一组子节点,它们可以通过唯一 id(即key) 进行区分</li></ol><p>基于以上三个策略,react分别对应的 tree diff,component diff ,element diff 进行算法优化</p><ul><li><p>tree diff<br>基于策略一,React 对树进行分层比较,两棵树只会对同一层次的节点进行比较<br>那么如果出现了跨层级的移动和操作,那么将为以当前这个脏节点为根节点,根节点下的整个树将会被重新创建,这是一种影响React性能的操作,因此官方建议不要进行DOM节点跨层级的操作</p></li><li><p>component diff<br>基于策略二,对于同类型组件,则按照原策略继续比较 Virtrual DOM树,对于同类型的组件,有可能其虚拟DOM 没有任何变化,如何能够准确知道这点,那么就可以节省大量的diff运算时间;因此,react允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析<br>如果不是,则将该组件判断为 dirty component ,然后替换整个组件下的所有子节点</p></li><li><p>element diff<br>策略三,脏节点在同一类型组件,根据策略三,同一层级的节点,它们通过key进行区分,当我们遍历一遍待渲染的节点,就能确定要添加 / 删除 / 更新的节点 , 然后修改组件</p></li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><ul><li>状态管理的作用: 1.组件间的数据共享,数据变化组件间的页面也变化,2.做缓存<h2 id="Redux-的三个3原则"><a href="#Redux-的三个3原则" class="headerlink" title="Redux 的三个3原则"></a>Redux 的三个3原则</h2></li><li>三个api: createStore() / combineReducers() / applyMidleWare()</li><li>三个特点: Store 是只读的 / 单向数据流 / 修改state只能通过纯函数 reducer 来修改</li><li>三个概念: store/ reducer / action</li></ul><h2 id="Redux-的工作流程"><a href="#Redux-的工作流程" class="headerlink" title="Redux 的工作流程"></a>Redux 的工作流程</h2><blockquote><p>当用户在View 触发dispatch,dispatch会生成一个action()方法,将它发送给Store;Store接收到action方法后,会调用reducer函数,Store会传2两个参数给reducer,一个是初始化的state,另一个是收到的action,以此来修改State,当State变化时,View也发生变化,由此可以知道reducer是一个纯函数,它会返回一个新的state,即修改后的state</p></blockquote><h2 id="在Redux中调接口"><a href="#在Redux中调接口" class="headerlink" title="在Redux中调接口"></a>在Redux中调接口</h2><blockquote><p>redux只支持dispatch同步的action,并且要求action只能是一个plain object(普通对象)<br>当react组件中dispatch(fetch)触发调接口,此时,action不是一个plain object,是一个函数,而store中不支持接收函数,所以需要使用中间件 react-thunk</p></blockquote><p>完成一次异步的dispatch需要两次派发<br>第一次派发一个空的action<br>第二次才会将action派发到store中<br>第一次dispatch的action会被thunk这个中间件接收,thunk首先会判断,此时这个action是不是一个函数,如果不是,原封不动的将这个action转发到store中,如果此时这个action是一个函数,那么thunk会执行函数内部的代码,执行第二次派发 直接执行这个函数,执行完毕再将这个函数返回的结果转发到store中</p><h2 id="Redux中的中间件"><a href="#Redux中的中间件" class="headerlink" title="Redux中的中间件"></a>Redux中的中间件</h2><ul><li>thunk,dispatch一个函数</li><li>saga,以generator方式书写Redux</li><li>promise,也是解决异步,允许payload是一个promise对象</li></ul><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h3 id="1-什么是Hook"><a href="#1-什么是Hook" class="headerlink" title="1.什么是Hook?"></a>1.什么是Hook?</h3><blockquote><p>Hook是React新增的特性,它可以在你不使用类组件的情况下使用State和其他的react特性</p></blockquote><h4 id="1-1-常用的Hook"><a href="#1-1-常用的Hook" class="headerlink" title="1-1.常用的Hook"></a>1-1.常用的Hook</h4><p>如: </p><ol><li><p>useState  </p><blockquote><p>关于useState的用法是: 需要传入一个参数作为状态的初始值,当函数执行后会返回两个值,一个是当前状态的属性,一个是修改状态的方法</p></blockquote></li><li><p>useEffect</p><blockquote><p>副作用, 通常在副作用中进行ajax请求,事件的绑定和解绑,设置定时器和清除器等;<br>useEffect有两个参数<br>第一个参数是一个回调函数,这个回调函数相当于 React生命周期中 componentDidMount() 这个钩子函数(只是相当于这个生命周期,实际上并不是生命周期),在这个回调函数中,可以进行ajax请求,设置定时器,绑定事件等等 ; 这个回调函数的返回值是一个函数,这个返回值,它相当于是React生命周期中componentWillUnmount() 这个钩子函数,我们可以在这里清除定时器,清除缓存,对事件进行解绑等<br>useEffect的第二个参数是依赖项数组,如果数组中的依赖发送变化,那么该副作用就会重新执行,如果不设置第二个参数,那么当该组件每渲染一次,副作用就会执行一次;如果设置为空数组,那么该副作用只会在组件初次渲染时执行一次<br>在副作用中,不仅可以进行ajax请求,还可以通过调用的本地的State来进行页面更新</p></blockquote></li><li><p>useContext</p><blockquote><p>上下文</p></blockquote></li><li><p>useRef</p><blockquote><p>获取DOM节点,进行DOM操作</p></blockquote></li><li><p>useMemo</p><blockquote><p>useMemo,创建一个依赖函数,当其中一个依赖项更改时,useMemo重新计算机记忆的值,而不需要在每个组件渲染时进行diff运算<br>目的: 避免重复进行复杂耗时的代码计算,所以将计算的结果存起来. 只有在需要计算时使用<br>传入两个参数: 一个回调函数,一个依赖项数组<br>useMemo 的作用<br>useMemo其实创建了一种数据缓存机制,比如登录页面需要向后台发送含用户名&amp;密码的ajax请求,获取用户登录信息,useMemo可以设置成只有当有用户密码改变后才向后台重新发送ajax,而在组件重新渲染时使用缓存的用户信息<br>useMemo与useEffect区别<br>useMemo 与 useEffect 作用类似,都会在依赖值改变时重新执行,但useMemo有一个缓存的返回值, 因此在组件渲染生命周期中,很自然地会把useMemo放到渲染DOM前执行</p></blockquote></li></ol><p>  <strong>useMemo =&gt; 渲染DOM =&gt; useEffect</strong><br>  当我们遇到复杂的计算可以使用useMemo<br>6. useCallback</p><blockquote><p>与useMemo传入的参数是一样的,都是在其依赖项发送变化后才执行的,都是返回缓存的值,区别在于useMemo返回的是函数运行的结果,useCallback返回的是函数<br>  <strong>大部分时不用,可以在搭配shouldComponentUpdate()或有多个useEffect时使用</strong></p></blockquote><h1 id="React中context"><a href="#React中context" class="headerlink" title="React中context"></a>React中context</h1><ul><li>作用: 用于React组件树中传递数据,避免使用复杂的链式的props数据传递</li><li>上下文机制: 它的数据只能单向传输,从父组件向内部组件传递</li></ul><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="怎么理组合"><a href="#怎么理组合" class="headerlink" title="怎么理组合"></a>怎么理组合</h2><ol><li>组合在React中,是一种非常强大的组件复用的设计模式, react中组件复用的思想用的是组合的思想</li><li>建立的语法基础:props可传递任何数据类型,包括jsx对象</li></ol><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><ul><li>将组件需要共用的数据,提升到相同的父组件的props中,子组件通过props使用这些数据,以达到数据共用的效果</li></ul><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><ul><li>高阶组件实际上就是一个纯函数,即唯一的输入得到唯一的输出,所以高阶函数也叫高阶组件<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>是一种组件复用的技巧,用于修饰UI组件<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2></li><li>基础react组合的特性</li></ul><h1 id="React数据类型检查"><a href="#React数据类型检查" class="headerlink" title="React数据类型检查"></a>React数据类型检查</h1><ul><li>使用第三库props_types,对自定义属性执行类型检查</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React中的key的作用&quot;&gt;&lt;a href=&quot;#React中的key的作用&quot; class=&quot;headerlink&quot; title=&quot;React中的key的作用&quot;&gt;&lt;/a&gt;React中的key的作用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;key可以帮助React跟</summary>
      
    
    
    
    <category term="React" scheme="https://monthlygirl.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://monthlygirl.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Hook</title>
    <link href="https://monthlygirl.github.io/2021/02/Hook.html"/>
    <id>https://monthlygirl.github.io/2021/02/Hook.html</id>
    <published>2021-02-22T13:39:14.000Z</published>
    <updated>2021-02-22T13:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h3 id="1-什么是Hook"><a href="#1-什么是Hook" class="headerlink" title="1.什么是Hook?"></a>1.什么是Hook?</h3><blockquote><p>Hook是React新增的特性,它可以在你不使用类组件的情况下使用State和其他的react特性</p></blockquote><h4 id="1-1-常用的Hook"><a href="#1-1-常用的Hook" class="headerlink" title="1-1.常用的Hook"></a>1-1.常用的Hook</h4><p>如: </p><ol><li><p>useState  </p><blockquote><p>关于useState的用法是: 需要传入一个参数作为状态的初始值,当函数执行后会返回两个值,一个是当前状态的属性,一个是修改状态的方法</p></blockquote></li><li><p>useEffect</p><blockquote><p>副作用, 通常在副作用中进行ajax请求,事件的绑定和解绑,设置定时器和清除器等;<br>useEffect有两个参数<br>第一个参数是一个回调函数,这个回调函数相当于 React生命周期中 componentDidMount() 这个钩子函数(只是相当于这个生命周期,实际上并不是生命周期),在这个回调函数中,可以进行ajax请求,设置定时器,绑定事件等等 ; 这个回调函数的返回值是一个函数,这个返回值,它相当于是React生命周期中componentWillUnmount() 这个钩子函数,我们可以在这里清除定时器,清除缓存,对事件进行解绑等<br>useEffect的第二个参数是依赖项数组,如果数组中的依赖发送变化,那么该副作用就会重新执行,如果不设置第二个参数,那么当该组件每渲染一次,副作用就会执行一次;如果设置为空数组,那么该副作用只会在组件初次渲染时执行一次<br>在副作用中,不仅可以进行ajax请求,还可以通过调用的本地的State来进行页面更新</p></blockquote></li><li><p>useContext</p><blockquote><p>上下文</p></blockquote></li><li><p>useRef</p><blockquote><p>获取DOM节点,进行DOM操作</p></blockquote></li><li><p>useMemo</p><blockquote><p>useMemo,创建一个依赖函数,当其中一个依赖项更改时,useMemo重新计算机记忆的值,而不需要在每个组件渲染时进行diff运算<br>目的: 避免重复进行复杂耗时的代码计算,所以将计算的结果存起来. 只有在需要计算时使用<br>传入两个参数: 一个回调函数,一个依赖项数组<br>useMemo 的作用<br>useMemo其实创建了一种数据缓存机制,比如登录页面需要向后台发送含用户名&amp;密码的ajax请求,获取用户登录信息,useMemo可以设置成只有当有用户密码改变后才向后台重新发送ajax,而在组件重新渲染时使用缓存的用户信息<br>useMemo与useEffect区别<br>useMemo 与 useEffect 作用类似,都会在依赖值改变时重新执行,但useMemo有一个缓存的返回值, 因此在组件渲染生命周期中,很自然地会把useMemo放到渲染DOM前执行</p></blockquote></li></ol><p>  <strong>useMemo =&gt; 渲染DOM =&gt; useEffect</strong><br>  当我们遇到复杂的计算可以使用useMemo<br>6. useCallback</p><blockquote><p>与useMemo传入的参数是一样的,都是在其依赖项发送变化后才执行的,都是返回缓存的值,区别在于useMemo返回的是函数运行的结果,useCallback返回的是函数<br>  <strong>大部分时不用,可以在搭配shouldComponentUpdate()或有多个useEffect时使用</strong>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hook&quot;&gt;&lt;a href=&quot;#Hook&quot; class=&quot;headerlink&quot; title=&quot;Hook&quot;&gt;&lt;/a&gt;Hook&lt;/h1&gt;&lt;h3 id=&quot;1-什么是Hook&quot;&gt;&lt;a href=&quot;#1-什么是Hook&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="React" scheme="https://monthlygirl.github.io/categories/React/"/>
    
    
    <category term="Hook" scheme="https://monthlygirl.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Redux</title>
    <link href="https://monthlygirl.github.io/2021/02/redux.html"/>
    <id>https://monthlygirl.github.io/2021/02/redux.html</id>
    <published>2021-02-02T19:47:06.000Z</published>
    <updated>2021-02-02T19:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<font size=3><blockquote><font size=3 color=#5285C8> 什么时候用到 Redux ? <br/></font></blockquote><blockquote><p><font color=black>有人曾说过 :</font> <font size=4 color=#E7776C>“如果你不知道是否需要 Redux，那就是不需要它 “</font>  <br/></p></blockquote><blockquote><p><font color=black> 接着又有人补充 :</font> <font color=#E7776C>“只有遇到 React 实在解决不了的问题，你才需要 Redux 。” </font></p></blockquote><h1 id="Redux的流程"><a href="#Redux的流程" class="headerlink" title="Redux的流程"></a>Redux的流程</h1><p>先看图<br><a href="https://imgchr.com/i/yuJCxH"><img src="https://s3.ax1x.com/2021/02/02/yuJCxH.gif" alt="yuJCxH.gif"></a></p><h1 id="Redux-的三个3原则"><a href="#Redux-的三个3原则" class="headerlink" title="Redux 的三个3原则"></a>Redux 的三个3原则</h1><font size=4><p>1️⃣ 三个api: createStore()  / combineReducers() / applyMiddleware() </p><p>2️⃣ 三个特点: store是只读的  /  单向数据流  /  修改store只能通过纯函数reducer来修改</p><p>3️⃣ 三个概念: store / reducer / action </font></p><h1 id="Redux-的基本概念和API"><a href="#Redux-的基本概念和API" class="headerlink" title="Redux 的基本概念和API"></a>Redux 的基本概念和API</h1><h3 id="1-Store-就是保存数据的地方-可以把它看成是一个容器-整个应用只能有一个store"><a href="#1-Store-就是保存数据的地方-可以把它看成是一个容器-整个应用只能有一个store" class="headerlink" title="1. Store 就是保存数据的地方,可以把它看成是一个容器,整个应用只能有一个store"></a>1. Store 就是保存数据的地方,可以把它看成是一个容器,整个应用只能有一个store</h3><p>  Redux提供 createStore() 这个函数,用来生成store()</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125;  <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(fn)</span><br></pre></td></tr></table></figure><h3 id="2-State-如果把Store看成是一个仓库-那么State-就是仓库的中货物-每个货物对应一个State"><a href="#2-State-如果把Store看成是一个仓库-那么State-就是仓库的中货物-每个货物对应一个State" class="headerlink" title="2. State,如果把Store看成是一个仓库,那么State 就是仓库的中货物, 每个货物对应一个State;"></a>2. State,如果把Store看成是一个仓库,那么State 就是仓库的中货物, 每个货物对应一个State;</h3><p>  在Redux中,Store 对象包含着所有的数据,如果想要拿到期中的数据,就要对Store生成快照,此时生成的数据就叫State<br>  Redux规定,一个State对应一个View,只要State相同,View就相同</p><font color=#0000>🥖 State 的变化,会导致 页面 即View 的变化,但用户接触不到State,只能接触到View;所以State的变化必须是View导致的;而Action就是View 发出的通知,表示State应该要发生变化了</font><h3 id="3-Action"><a href="#3-Action" class="headerlink" title="3. Action"></a>3. Action</h3><p>  State的变化,会导致页面 即View的变化,但是用户接触不到State,只能接触到View;所以State 的变化必须是View 导致; 而Action就是 View 发出的通过,表示State 应该要发生变化了</p><p>  Action 是一个对象 ,其中type是必填属性</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> payload=&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>:<span class="string">&#x27;hello word&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-dispatch"><a href="#4-dispatch" class="headerlink" title="4. dispatch()"></a>4. dispatch()</h3><p>  dispath()是View发出Action的唯一方法,当用户在 View 触发 dispatch, dispatch会生成一个Action()方法, 将它发送给Store<br>  使用dispatch的方式有很多,可以使用高阶组件或hooks</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line"><span class="comment">//dispatch一个action方法</span></span><br><span class="line"><span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  <span class="attr">payloa</span>:<span class="string">&quot;hello word&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-Reducer"><a href="#5-Reducer" class="headerlink" title="5. Reducer"></a>5. Reducer</h3><p>  Store 收到Action 后,必须给出一个新的State,这样View才会发生变化,这种State的计算过程就叫Reducer;<br>  也就是说必须根据 View 的变化 修改Store,而Store是只读,只能使用纯函数,即只能在Reducer中修改–&gt; 得出 Reducer 是一个纯函数<br>  纯函数表示:只要是同样的输入，必定得到同样的输出。</p> <font color=#0000> 🥖 实际上 在 createStore()函数中, 接收另一函数作为参数,这个函数就是Reducer 函数<p> 🥖 Reducer 函数接收两个参数,一个是初始State,另一个是action<br> </font></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">initState=&#123;&#125;,ation</span>)&#123;</span><br><span class="line">  <span class="comment">//这里面根据action传来的参数修改store中的数据</span></span><br><span class="line">  <span class="comment">//Store 是只读的,并且是单向的,所以不能被直接修改</span></span><br><span class="line">  <span class="comment">//先进行一层深拷贝</span></span><br><span class="line">  <span class="keyword">let</span> newStore = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>,<span class="title function_">stringify</span>(store))</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">type</span>:</span><br><span class="line">      <span class="comment">//做一些操作,修改State</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在组件中使用-Redux"><a href="#在组件中使用-Redux" class="headerlink" title="在组件中使用 Redux"></a>在组件中使用 Redux</h1><h2 id="使用上下文Provider-将store传到App中"><a href="#使用上下文Provider-将store传到App中" class="headerlink" title="使用上下文Provider 将store传到App中"></a>使用上下文Provider 将store传到App中</h2><h2 id="在组件中-可以使用高阶组件或hooks将react和redux连接起来"><a href="#在组件中-可以使用高阶组件或hooks将react和redux连接起来" class="headerlink" title="在组件中,可以使用高阶组件或hooks将react和redux连接起来"></a>在组件中,可以使用高阶组件或hooks将react和redux连接起来</h2><ul><li>使用高阶组件 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect &#125;  <span class="keyword">from</span>  <span class="string">&#x27;react-redux&#x27;</span></span><br></pre></td></tr></table></figure><font color=#00000>    其中,connect(fn1,fn2)(UI)组件  中间接收两个函数作为参数,然后修饰到UI组件中      fn1 是 mapStateToProps 将state 中的数据 映射到组件的props中 ,组件通过props 获取store中的数据  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapStateToProps</span>(<span class="params">store</span>)&#123;</span><br><span class="line">  <span class="comment">//接收一个store参数</span></span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">msg</span>:store.<span class="property">msg</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  fn2 是 mapDispatchToProps  将View 中修改的数据 dispatch 到reducer 的action中 ,action通过dispatch中的数据修改state </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">changeMsg</span>:<span class="function">()=&gt;</span><span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,<span class="attr">payload</span>:<span class="string">&#x27;hello Word&#x27;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用hook</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector,useDispath &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">useSelector</span>(store.<span class="property">msg</span>)</span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">dipatch</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,<span class="attr">payload</span>:<span class="string">&#x27;hello word&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redux-中调接口"><a href="#Redux-中调接口" class="headerlink" title="Redux 中调接口"></a>Redux 中调接口</h1><p><strong>redux只支持 dispatch 同步的action,并且要求action只能使用plain object</strong></p><blockquote><p>当react组件中dispatch(fetch)触发调接口,此时fetch并不是一个plain object,是一个函数,redux的store收到一个plain object的action时就会报错</p></blockquote><p><strong>所以异步的action需要使用一个第三方库 redux-thunk</strong><br>creactStore 使用一个中间件, thunk<br>creactStore(reducer,applyMiddleware(thunk))</p><p>🦴 完成一次异步的action,需要两次派发<br>🦴 第一次派发一个空的action,<br>🦴 第二次才将action派发到store中</p><p>🟣 此时,第一次dispatch的action会被thunk这个中间件接收,thunk中首先会判断,此时这个action是不是一个函数,如果不是,原封不动的将这个action转发store中; 如果 此是这个action是一个函数,那么thunk会执行函数内部的代码,执行第二次派发,直接执行调接口这个异步操作,执行完毕再将结果转发到store中</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMusic = (payload)&#123;</span><br><span class="line">  <span class="comment">//2-第一次派发的是一个函数,</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">dispath</span>)&#123;</span><br><span class="line">    <span class="comment">//3-第二次派发</span></span><br><span class="line">    <span class="title function_">fetchMusic</span>(payload).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;music&#x27;</span>,</span><br><span class="line">        payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-在这里第一次派发</span></span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">getMusic</span>(payload))</span><br></pre></td></tr></table></figure><h1 id="分模块"><a href="#分模块" class="headerlink" title="分模块"></a>分模块</h1><ul><li>使用 combineReducers()函数进行模块划分,接收一个对象,存放的是每个子reducers,使用是需加上每个模块名,即命名空间</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">&#x27;./todo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span></span><br><span class="line"> <span class="keyword">const</span> rootRender = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">   todo,</span><br><span class="line">   test</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>action生成器<br>action.type </p></blockquote></font></font>]]></content>
    
    
      
      
    <summary type="html">&lt;font size=3&gt;

&lt;blockquote&gt;
&lt;font size=3 color=#5285C8&gt; 
什么时候用到 Redux ? &lt;br/&gt;&lt;/font&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=black&gt;有人曾说过 :</summary>
      
    
    
    
    <category term="React" scheme="https://monthlygirl.github.io/categories/React/"/>
    
    
    <category term="Redux" scheme="https://monthlygirl.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>JS的异步机制</title>
    <link href="https://monthlygirl.github.io/2021/02/JS_Async.html"/>
    <id>https://monthlygirl.github.io/2021/02/JS_Async.html</id>
    <published>2021-02-02T08:47:57.000Z</published>
    <updated>2021-02-02T08:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS的异步机制分为以下几种"><a href="#JS的异步机制分为以下几种" class="headerlink" title="JS的异步机制分为以下几种"></a>JS的异步机制分为以下几种</h3><p> 🌈 第一种是常见的回调函数的方式,但是使用这种方式有一个缺点就是 多个回调函数会造成回调地狱,上下两层函数间的代码耦合性太高,不利于代码维护<br> 🌈 第二种是 promise 对象的方式,使用promise的方式可以将嵌套的回调函数以链式方式调用,但使用这种方式有时会造成多个 then 的链式调用,可能造成语义不明确<br> 🌈 第三种是使用 generator 的方式 generator 它可以在函数的内部将函数的执行权转移出去,在函数的外部又可以将函数的执行权转移回来;所以,当我们遇到异步函数执行的时候,可以先将函数的执行权转移出去,当异步函数执行完毕后再将函数执行权转移回来;<br> 因此在generator内部对异步的操作可以用同步的顺序来书写;使用generator函数的方式,<br> 在使用generator的时候 我们需要考虑的一个问题是什么时候将函数的执行权转移回来,所以我们需要一个自动执行generator函数的机制,比如co模块等可以用来实现generator函数的自动执行<br> 🌈 第四种是 使用async函数,它是一个promise + generator 实现的一个自动执行的语法糖, 它内部自带执行器,当函数内部执行到一个await语句时,如果语句返回的是一个promise对象,那么它会等待这个promise对象的状态变成resolve后再继续向下执行,所以使用这种方式,我们也可以将异步的逻辑用同步的方式来书写,并且这个函数是自动执行的</p><p> 第一种是最常见的使用回调函数的方式,但使用这种方式有一个缺点就是,多个回调函数会造成回调地狱,上下两层函数间的代码耦合性太高,不利于代码维护</p><p> 第一种是 使用promise的方式 ,使用promise的方式它可以将嵌套的回调函数以链式的形式调用,使用这种方式,有时会造成 多个then 链式, 可能会造成代码的语义不明确</p><p> 第三中的使用generator的方式, generator函数它可以将函数的执行权转移出去,在函数的外部可以将函数的执行权转移回来,当我们遇到异步函数执行时,可以先将函数的执行权转移出去,异步函数执行完毕后,在将函数的执行权转移回来, 因此在generator内部 对异步操作可以用同步的顺序来书写,所以我们在使用generator函数的时候需要考虑一个问题,就是什么时候将函数的执行权转移回来,因此我们需要一个自动执行generator的机制,比如co模块就可以实现generator的自动执行</p><p> 第四种是async 函数,它是 promise + generator 一个自动执行的语法糖,它内部自带执行器,当函数内部执行到await语句时,如果语句返回的是一个promise对象,那么它会等待promise对象 的状态变成resolve后再继续向下执行,因此我们也可以使用async 函数来使用异步逻辑用同步的方式来书写,并且这个函数可以自动执行 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS的异步机制分为以下几种&quot;&gt;&lt;a href=&quot;#JS的异步机制分为以下几种&quot; class=&quot;headerlink&quot; title=&quot;JS的异步机制分为以下几种&quot;&gt;&lt;/a&gt;JS的异步机制分为以下几种&lt;/h3&gt;&lt;p&gt; 🌈 第一种是常见的回调函数的方式,但是使用这种方</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="JS的异步机制" scheme="https://monthlygirl.github.io/tags/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTML5有哪些的新特性</title>
    <link href="https://monthlygirl.github.io/2021/02/html5.html"/>
    <id>https://monthlygirl.github.io/2021/02/html5.html</id>
    <published>2021-02-01T21:48:02.000Z</published>
    <updated>2021-02-01T21:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5有哪些新特特性-移除了哪些元素"><a href="#HTML5有哪些新特特性-移除了哪些元素" class="headerlink" title="HTML5有哪些新特特性,移除了哪些元素"></a>HTML5有哪些新特特性,移除了哪些元素</h1><h2 id="新增的元素"><a href="#新增的元素" class="headerlink" title="新增的元素"></a>新增的元素</h2><ol><li>绘画canvas</li><li>用于媒介回档的 video 和 audio 元素</li><li>本地离线存储 localStorage 用于长期存储数据,浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语义化更好的内容元素,比如 article / footer / header / nav / section</li><li>表单控件,calendar / date / time / email / URL / search</li><li>新技术 webworker , websocket</li><li>新的文档属性 document.visibilityState</li></ol><h2 id="移除的元素"><a href="#移除的元素" class="headerlink" title="移除的元素"></a>移除的元素</h2><ol><li>纯表现的元素: basefont, big, center, font. s 等等</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML5有哪些新特特性-移除了哪些元素&quot;&gt;&lt;a href=&quot;#HTML5有哪些新特特性-移除了哪些元素&quot; class=&quot;headerlink&quot; title=&quot;HTML5有哪些新特特性,移除了哪些元素&quot;&gt;&lt;/a&gt;HTML5有哪些新特特性,移除了哪些元素&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="HTML" scheme="https://monthlygirl.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Css</title>
    <link href="https://monthlygirl.github.io/2021/01/Css.html"/>
    <id>https://monthlygirl.github.io/2021/01/Css.html</id>
    <published>2021-01-27T21:48:02.000Z</published>
    <updated>2021-01-27T21:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准的CSS-盒模型-和-低版本IE-盒模型的区别"><a href="#标准的CSS-盒模型-和-低版本IE-盒模型的区别" class="headerlink" title="标准的CSS 盒模型 和 低版本IE 盒模型的区别"></a>标准的CSS 盒模型 和 低版本IE 盒模型的区别</h2><p>👉 两种盒模型分为: W3C标准盒模型(content-box) 和 IE盒模型(border-box)<br>👉 盒模型: content(内容) padding(填充)  margin(边界)  border(边框)</p><p>💁🏼 IE盒模型和W3C标准盒模型的区别: </p><ol><li>w3c标准盒模型它的width和height 只包含 content 不包括padding 和border</li><li>IE盒模型它的width和height 包含content 和 padding 和 border,指的是content+padding+border</li></ol><p>🟣 在IE8+ 的浏览器中 我们可以通过box-sizing 改变盒模型,默认为content-box</p><h2 id="before-和-after-中的双冒号和单冒号有什么区别呢"><a href="#before-和-after-中的双冒号和单冒号有什么区别呢" class="headerlink" title="::before 和 :after 中的双冒号和单冒号有什么区别呢?"></a>::before 和 :after 中的双冒号和单冒号有什么区别呢?</h2><p>📌 单冒号(:) 用于css3伪类,双冒号(::)用于css3 伪元素(伪元素由双冒号和伪元素名称组成)</p><p>📌 双冒号是在当前规范中引入的,用于区分伪类和伪元素 伪类兼容已有的伪元素的写法,在一些浏览器中也可以使用单冒号的写法 ,新的css3中引入的伪元素则不允许单冒号的写法</p><p>🟡 伪类一般匹配的是元素的一些特殊状态,如hover / link 等,而伪元素一般匹配的特殊位置,比如 after / before等</p><h2 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h2><p>➜ 伪类用于当已有的元素处于某个状态时,为其添加对应的样式,这个状态时根据用户行为而动态变化的. 比如说,当用户悬停在指定的元素时,我们可以通过 :hover 来描述这个元素的状态</p><p>➜ 伪元素用于创建一些不在文档树中的元素,并为其添加样式, 它们允许我们为元素的某些部分设置样式. 比如说,我们可以通过 ::before 俩在一个元素前增加一些文本,并为这些文本添加样式. 虽然用户可以看到这些文本,但是这些文本实际上不在文档树中</p><p>🔵 总的来说: css引入伪类和伪元素概念是为了格式化文档树以外的信息. 也就是说,伪类和伪元素是用来修饰不在文档树中的部分</p><h2 id="css中哪些属性可以继承"><a href="#css中哪些属性可以继承" class="headerlink" title="css中哪些属性可以继承"></a>css中哪些属性可以继承</h2><p>🚩 每个css属性的定义中都给出了该属性默认是继承的,还是默认不继承的</p><p>1️⃣ 当一个属性默认是继承的,但没有给其默认值时: 默认继承父级元素 同属性的值<br>2️⃣ 当一个属性默认是不继承是,可以通过将它的值设置为inherit来使它从元素那获取同属性的值</p><p>🖌 有继承性的属性:</p><ol><li>字体系列属性:<br>font、font-family、font-weight、font-size、font-variant、font-stretch、font-size-adjust</li><li>文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</li><li>表格布局属性<br>caption-side、border-collapse empty-cells</li><li>列表属性<br>list-style-type、list-style-image、list-style-position、list-style</li><li>光标属性<br>cursor</li><li>元素可见性<br>visibility</li><li>不常用的：speak、page等等</li></ol><h1 id="CSS3-有哪些新特性"><a href="#CSS3-有哪些新特性" class="headerlink" title="CSS3 有哪些新特性"></a>CSS3 有哪些新特性</h1><ol><li>新增各种css选择器 nth-child(n)</li><li>圆角   (border-radius:8px)</li><li>多列布局   (multi-column layout)</li><li>阴影和反射  (Shadow / Reflect)</li><li>文字特效  (text-shadow)</li><li>线性渐变  (gradient)</li><li>旋转   (transform)</li><li>缩放,定位,倾斜,动画,多背景  transform:\scanle(0.85,0.9)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</li></ol><h1 id="渐进增强和优雅降级的定义"><a href="#渐进增强和优雅降级的定义" class="headerlink" title="渐进增强和优雅降级的定义"></a>渐进增强和优雅降级的定义</h1><ol><li>渐进增强: 针对低版本浏览器进行构建页面,保证最基本的功能,然后再针对高级浏览器进行效果 / 交互等改进和追加功能达到更好的用户体验</li><li>优雅降级: 一开始就根据高版本浏览器构建完整的功能,</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标准的CSS-盒模型-和-低版本IE-盒模型的区别&quot;&gt;&lt;a href=&quot;#标准的CSS-盒模型-和-低版本IE-盒模型的区别&quot; class=&quot;headerlink&quot; title=&quot;标准的CSS 盒模型 和 低版本IE 盒模型的区别&quot;&gt;&lt;/a&gt;标准的CSS 盒模型 </summary>
      
    
    
    
    
    <category term="CSS" scheme="https://monthlygirl.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个new</title>
    <link href="https://monthlygirl.github.io/2021/01/new.html"/>
    <id>https://monthlygirl.github.io/2021/01/new.html</id>
    <published>2021-01-25T09:05:55.000Z</published>
    <updated>2021-01-25T09:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-一个对象的时候发生了什么"><a href="#new-一个对象的时候发生了什么" class="headerlink" title="new 一个对象的时候发生了什么"></a>new 一个对象的时候发生了什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;guestljz&#x27;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p> new一个对象的四个过程</p><ol><li>创建一个空对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>让构造函数中的this指向新对象,并指向构造函数的函数体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = Person.call(obj)</span><br></pre></td></tr></table></figure></li><li>设置新对象的__proto__属性指向构造函数的原型对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__=Person.prototype</span><br></pre></td></tr></table></figure></li><li>判断构造函数的返回值类型,如果是值类型,则返回新对象,如果是引用类型,就返回这个引用类型的对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(typeof(result)==&#x27;Object&#x27;)</span><br><span class="line">  p = result;</span><br><span class="line">else</span><br><span class="line">  p = obj</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-一个对象的时候发生了什么&quot;&gt;&lt;a href=&quot;#new-一个对象的时候发生了什么&quot; class=&quot;headerlink&quot; title=&quot;new 一个对象的时候发生了什么&quot;&gt;&lt;/a&gt;new 一个对象的时候发生了什么&lt;/h3&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://monthlygirl.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://monthlygirl.github.io/2021/01/webpack.html"/>
    <id>https://monthlygirl.github.io/2021/01/webpack.html</id>
    <published>2021-01-19T10:17:17.000Z</published>
    <updated>2021-01-19T10:17:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何理解webpack"><a href="#如何理解webpack" class="headerlink" title="如何理解webpack"></a>如何理解webpack</h3><ol><li>是一个打包器,作用是把前端模块编译成浏览器能够识别的HTML+CSS+JS</li><li>在webpack眼中,一起皆模块</li><li>四个入门级的核心概念:入口entry / 出口output / loader / plugin</li><li>webpack可以做哪些事? 一是构建开发环境,一个上线打包</li></ol><h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><ul><li>npm install webpack -g   核心api包</li><li>npm install webpack -D</li><li>npm install webpack-cli -g    命令行包</li><li>npm install webpack-cli -D</li><li>执行命令 webpack  会自动读取webpack.config.js文件</li><li>默认情况,webpack会自动读取src目录下的index文件为入口文件,将dist作为出口文件</li><li>webpack –config xxx.js   手动指定配置文件</li><li>配置package.json  “build”: “webpack –config webpack.config.js”</li><li>mode 配置当前环境是生产环境还是开发环境   production  devlopment</li></ul><h1 id="适用于webpack5-15环境-随着官方文档的更新-配置内容也不一样"><a href="#适用于webpack5-15环境-随着官方文档的更新-配置内容也不一样" class="headerlink" title="适用于webpack5.15环境,随着官方文档的更新,配置内容也不一样"></a>适用于webpack5.15环境,随着官方文档的更新,配置内容也不一样</h1><h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><ul><li>建立文件夹 src/main.js</li><li>配置文件 webpack.config.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span></span><br><span class="line">  <span class="attr">entry</span>:&#123;</span><br><span class="line">   <span class="attr">app</span>: path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src/main.js&#x27;</span>)   <span class="comment">//入口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">output</span>:&#123;              <span class="comment">//出口文件</span></span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;[name].[chunkhash].js&#x27;</span>   </span><br><span class="line">    <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./abc&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构建本地服务器"><a href="#构建本地服务器" class="headerlink" title="构建本地服务器"></a>构建本地服务器</h3><ul><li>npm install webpack-dev-server -D</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">port</span>:<span class="number">8078</span>,</span><br><span class="line">  <span class="attr">contentBase</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./public&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在package.json中的 &quot;serve&quot;:&quot;webpack --open --config webpage.config.js&quot;</span><br><span class="line">运行时 webpack serve --open</span><br><span class="line">或者在devServer中 添加open:true</span><br></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><ul><li><p>HTMLwebpackplugin</p></li><li><p>作用:使用它把入口文件和public中的index.html结合起来</p></li><li><p>安装</p></li><li><p>npm  install html-webpack-plugin -D</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>:[</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;/public/index.html&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>plugin是一个数组,参数是个选项,</p><h3 id="每次打包自动清除dist文件下的文件"><a href="#每次打包自动清除dist文件下的文件" class="headerlink" title="每次打包自动清除dist文件下的文件"></a>每次打包自动清除dist文件下的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在src里面热更新</span><br><span class="line">在devServer中加上hot:true ,加上热更新</span><br><span class="line">原理:实际上是建立了一个webSocket长链接</span><br></pre></td></tr></table></figure><h3 id="Cross-env"><a href="#Cross-env" class="headerlink" title="Cross-env"></a>Cross-env</h3><p> 跨平台设置和使用环境变量的脚本(判断当前环境是生产环境还是开发环境)</p><ul><li><p>用法<br>在npm脚本中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   <span class="string">&quot;scripts&quot;</span>：&#123;</span><br><span class="line">      <span class="string">&quot;build&quot;</span>：<span class="string">&quot;cross-env NODE_ENV=development webpack --config build / webpack.config.js&quot;</span> ,</span><br><span class="line">      <span class="string">&quot;serve&quot;</span>:<span class="string">&quot;ross-env NODE_ENV=production webpack serve --config webpack.config.js &quot;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了一个NODE_ENV变量用于判断 当前环境<br>使用 process.env.NODE_ENV 获取<br>process.env.NODE_ENV === ‘development’</p></li><li><p>执行 npm run build  打包上线  生产环境</p></li><li><p>执行 npm run serve  本地服务   开发环境</p></li></ul><h3 id="babel-将es6-转换成es5"><a href="#babel-将es6-转换成es5" class="headerlink" title="babel 将es6 转换成es5"></a>babel 将es6 转换成es5</h3><ul><li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader -D   用于加载.js文件</span><br><span class="line">npm install @babel/core -D         babel核心库  </span><br><span class="line">npm install @babel/preset-env -D   一个具体的babel编译器  把es6转成es5</span><br></pre></td></tr></table></figure></li><li>使用 </li></ul><p>添加babel.config.json文件,给babel编译器使用的,用于更加精细地指定js编译细节<br>添加一下内容<br>preset  用于指定当前环境中所使用的js主版本/如:ts,jsx等/默认es6/<br>plugin  用于指定特殊的js语法的编译功能  配合修复主版本中的漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;esmodules&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在module中添加一条规则<br>test: 使用正则表达式匹配是否是.js文件<br>use:使用babel-loader编译<br>exclude: /(node_modules|bower_components)/, 排除node_modules里的文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">  <span class="attr">rules</span>:[</span><br><span class="line">    &#123; <span class="attr">test</span>:<span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">          <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-proposal-object-rest-spread&#x27;</span>]  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为babel分成许多版本,presets 中是使用哪个版本解析  plugins是修复版本的bug</p><h3 id="加载css-scss"><a href="#加载css-scss" class="headerlink" title="加载css / scss"></a>加载css / scss</h3><ul><li>安装 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装scss</span><br><span class="line"></span><br><span class="line">npm install sass-loader -D</span><br><span class="line">npm install sass -D     </span><br><span class="line"></span><br><span class="line">安装css-loader 和style-loader</span><br><span class="line"></span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure></li><li>使用 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">          <span class="string">&quot;sass-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">最后通过你喜欢的方式运行webpack。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="ts-loader-转换ts"><a href="#ts-loader-转换ts" class="headerlink" title="ts-loader  转换ts"></a>ts-loader  转换ts</h3><ul><li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add ts-loader --dev</span><br></pre></td></tr></table></figure></li><li>创建一个tsconfig.json文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;sourceMap&quot;: true   //找到ts文件代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>匹配规则<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test:&#123;/\.ts$/,loader:&#x27;ts-loader&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="eslint的使用"><a href="#eslint的使用" class="headerlink" title="eslint的使用"></a>eslint的使用</h3><ul><li><p>安装</p></li><li><p>使用<br>配置在开发环境中<br>追加一条规则<br>config.module.rules.push({<br>test:<br>use:<br>exforce:pre<br>})<br>exforce:pre  pre表示前置执行,代表Eslint最先执行,没有错误后材质西ing之后的打包工作</p></li><li><p>配置eslint 文件<br>在根目录下添加 .eslintrc.json </p></li></ul><p>eslint检测代码三种规则</p><ul><li><p>error  违背规则报错   简写2</p></li><li><p>warn   违背规则警告      1</p></li><li><p>off    违背规则关闭</p></li><li><p>在DevServer中加上覆盖层<br>使用overlay选项</p></li></ul><h3 id="忽略eslint的检查"><a href="#忽略eslint的检查" class="headerlink" title="忽略eslint的检查"></a>忽略eslint的检查</h3><p>两种种方案</p><ol><li>修改eslint规则</li><li>使用eslint的各种注释,临时关闭<br>例如:<br>/<em>eslint-disable</em>/<br>//在这中间的代码都不检查<br>/<em>eslint-enable</em>/</li></ol><h3 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h3><ul><li>resolve</li></ul><p>使用resolve下的属性<br>alias:{<br> ‘@’: path.resolve(__dirname,’./src’)<br>},<br>extensions:[‘.js’,’.jsx’]  //忽略后缀,导入时可以不写.js和.jsx的后缀</p><h3 id="搭建react环境"><a href="#搭建react环境" class="headerlink" title="搭建react环境"></a>搭建react环境</h3><ul><li>安装库  React  -S  React-Dom<br>ReactDom.render(,document.getElementById(“app”))</li></ul><p>jsx react官方语法糖</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何理解webpack&quot;&gt;&lt;a href=&quot;#如何理解webpack&quot; class=&quot;headerlink&quot; title=&quot;如何理解webpack&quot;&gt;&lt;/a&gt;如何理解webpack&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是一个打包器,作用是把前端模块编译成浏览器能够识别的HT</summary>
      
    
    
    
    <category term="webpack" scheme="https://monthlygirl.github.io/categories/webpack/"/>
    
    
    <category term="Webpack" scheme="https://monthlygirl.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://monthlygirl.github.io/2021/01/CSRF.html"/>
    <id>https://monthlygirl.github.io/2021/01/CSRF.html</id>
    <published>2021-01-14T08:56:17.000Z</published>
    <updated>2021-01-14T08:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h1><p>🍢  CSRF攻击指的是跨站请求伪造攻击,攻击者诱导用户进入一个第三方网站,然后网站向被攻击网站发送跨站请求,如果用户在被攻击网站中保存了登录状态,那么攻击者就可以利用这个登录状态,绕过后台的用户验证,冒充用户向服务器执行一些操作</p><p>🍢 CSRF攻击的本质是利用了cookie会在同源请求中携带发送给服务器的特点,以此来实现用户的冒充</p><h1 id="CSRF攻击的分类"><a href="#CSRF攻击的分类" class="headerlink" title="CSRF攻击的分类"></a>CSRF攻击的分类</h1><p>  一般的CSRF攻击类型有三种:</p><p>🍭 第一种是GET类型的CSRF攻击,比如在网站中的一个 img 标签里构建一个请求,当用户打开这个网站的时候就会自动发起提交</p><p>🍭 第二种是POST类型的CSRF攻击,比如说构建一个报单,然后隐藏它,当用户进入页面时,自动提交这个表单</p><p>🍭 第三种是链接类型的CSRF 攻击,比如说在a标签的href属性里构建一个请求,然后诱导用的去点击</p><h1 id="如何防护CSRF-攻击"><a href="#如何防护CSRF-攻击" class="headerlink" title="如何防护CSRF 攻击"></a>如何防护CSRF 攻击</h1><p>  CSRF攻击中,重要的一环就是cookie,这一份cookie模拟了用户的身份,所以防范CSRF攻击cookie是一个入手点,恰巧,cookie中有个字段,可以对请求中cookie的携带做一些限制</p><h2 id="第一种方法从-samSite-入手"><a href="#第一种方法从-samSite-入手" class="headerlink" title="第一种方法从 samSite 入手"></a>第一种方法从 samSite 入手</h2><p>  <strong>samSite</strong> ,可设为3个值: <strong>Strict / Lax / None</strong></p><p>🍧 Strict 模式: 浏览器完全禁止第三方请求携带cookie,比如当你访问 <code>https://guestljz.gitee.io/</code> 这个网站,那么你只能在访问 <code>https://guestljz.gitee.io/</code> 这个网站中携带cookie,其他网站都不能携带<br>🍨 Lax 模式: 相对松一点,只能在 get 方法请求表单或者a标签中发送请求时 携带cookie,其他情况不能<br>🍦 None 模式: 默认情况, 任何请求都会携带cookie</p><h2 id="第二种方法-验证站点来源"><a href="#第二种方法-验证站点来源" class="headerlink" title="第二种方法 验证站点来源"></a>第二种方法 验证站点来源</h2><p> 利用请求头中的 <strong>Origin</strong>和<strong>Refer</strong><br> Origin 中包含了域名信息, Refer中包含的详细的URL路径,以此来验证<br> 当然了,这些都可以伪造,通过AJAX中自定义请求</p><h2 id="第三种方法-CSRF-Token"><a href="#第三种方法-CSRF-Token" class="headerlink" title="第三种方法 CSRF Token"></a>第三种方法 CSRF Token</h2><p>首先,浏览器向服务器发送请求时,服务器生成一个字符串,将其植入到返回的页面中<br>然后浏览器如果要发生请求,就必须带上这个字符串,然后服务器来验证是否合法,如果不合法则不响应.<br>这个字符串就是CSRF Token 第三方网站无法拿到这个token,因此也就被服务器拒绝</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是CSRF攻击&quot;&gt;&lt;a href=&quot;#什么是CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;什么是CSRF攻击&quot;&gt;&lt;/a&gt;什么是CSRF攻击&lt;/h1&gt;&lt;p&gt;🍢  CSRF攻击指的是跨站请求伪造攻击,攻击者诱导用户进入一个第三方网站,然后网</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>强缓存_协商缓存</title>
    <link href="https://monthlygirl.github.io/2021/01/cache.html"/>
    <id>https://monthlygirl.github.io/2021/01/cache.html</id>
    <published>2021-01-05T08:43:25.000Z</published>
    <updated>2021-01-05T08:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><ol><li>首先通过 cache-control验证强缓存是否可用,如果可用直接只用</li><li>否则,进入协商缓存,即发送HTTP请求,服务器通过浏览器请求头中的相应字段来验证协商缓存是否可用,如果可用直接使用,否则,返回新的资源和200状态码</li></ol><blockquote><p>浏览器的缓存分为两种,一种是发送HTTP请求,一种是不发送请求</p></blockquote><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><ul><li><p> 强缓存(本地缓存),它不需要发送HTTP请求 ,如果命中缓存,浏览器直接从缓存中读取资源</p></li><li><p> 在HTTP/1.0 中检查强缓存的字段是expires, 在HTTP/1.1 中检查强缓存的字段是cache-control </p></li></ul><ol><li>EXpires<br>expires 即过期时间  存在服务端返回的响应头中,告诉浏览器在这个过期时间之前可以直接读取缓存,不需要再次请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Nov</span> <span class="number">2020</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure><blockquote><p>表示资源在2020年11月22号10点41分过期,过期了就必须重新发送请求<br>但~,这个方法有个小bug,那就是服务端的时间和浏览器的时间也许并不是一致<br>所以服务器返回的过期时间可能就是不准确的,所以这种方式在HTTP1.1版本中就被抛弃了</p></blockquote></li></ol><ol start="2"><li>Cache-Control<br>在HTTP1.1中采用 cache-control 字段,它和expires的区别是:expires采用的是具体的时间点来控制缓存,而cache-control采用的是时间时长来控制缓存</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-age=<span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>表示 这个响应在返回后的7600秒,也就是两个小时后过期,在这两个小时内可以直接使用缓存</p></blockquote><ol start="3"><li>cache-control除了max-age这个属性还有其他一些属性</li></ol><ul><li>public: 客户端和代理服务端都可以缓存,因为一个请求可能要经过不同的代理服务器才能到达目标服务器,那么结果不仅是在浏览器可以缓存,中间的任何代理节点都可以缓存</li><li>private: 只能浏览器缓存,中间代理不能缓存</li><li>no-cache: 跳过当前缓存,发送http请求,即进入协商缓存</li><li>no-store: 不以任何形式进行缓存</li><li>s-maxage: 和max-age相似,区别在于s-maxage是针对代理服务器的缓存时间</li></ul><blockquote><p> 如果expires和cache-control同时存在的时候,cache-control会被优先考虑<br>那么,当资源缓存时间超时了,也就是强缓存失效了,那该怎么办?       答案是:进入协商缓存 </p></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><ul><li><p>强缓存失效后,浏览器在请求头中携带相应的 缓存tag 来向服务器发请求,由服务器来根据这个tag,决定是否使用缓存</p><blockquote><p>缓存tag有两种</p></blockquote></li></ul><ol><li><p>last-modified,即最后修改时间<br>浏览器第一次向服务器发送请求时,服务器接收到后会在响应头中携带一个last-modified字段返回<br>浏览器接收到后,如果再次请求,会在请求头中携带一个if-modified-since的字段的值就是服务器返回last-modified字段的值(就是最后修改时间),服务器接收到后,会将两个值进行对比,<br>如果浏览器请求头中的值小于最后修改时间,表示该资源需要更新,即像正常的http请求一样返回资源<br>否则返回304,告诉浏览器直接使用缓存</p></li><li><p>etag<br>etag是服务器给文件生成的一个唯一标识,只要这个文件内容有改动,就会生成一个新的标识符,服务器就会通过响应头将这个值传给浏览器<br>浏览器接收到etag值后,会在下一次请求中,将etag的值,作为if-none-macth这个字段的值放在请求头中传给服务器,服务器接收到后,会将两个值进行对比<br>如果浏览器请求头中的值和服务器中的etag不同,表示需要返回新的资源了,<br>否则返回304,告诉浏览器直接使用缓存</p></li></ol><blockquote><p>总结:</p><p>浏览器的缓存机制,首先先通过cache-control验证强缓存是否可用,如果可以用,则直接使用强缓存,否则进入协商缓存,即发送http请求,服务器通过请求头中的if-none-match和if-modified-since字段检查资源更新,如果请求头中这个两个字段的值如果if-none-match的值跟服务器中的etag不一样或if-modifed-since的值小于服务器中last-modified,表示资源需要更新,返回新的资源,否则返回304,告诉浏览器直接使用缓存</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器的缓存机制&quot;&gt;&lt;a href=&quot;#浏览器的缓存机制&quot; class=&quot;headerlink&quot; title=&quot;浏览器的缓存机制&quot;&gt;&lt;/a&gt;浏览器的缓存机制&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;首先通过 cache-control验证强缓存是否可用,如果可用直接只用&lt;/li</summary>
      
    
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://monthlygirl.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>数组方法</title>
    <link href="https://monthlygirl.github.io/2020/12/array.html"/>
    <id>https://monthlygirl.github.io/2020/12/array.html</id>
    <published>2020-12-31T18:15:28.000Z</published>
    <updated>2020-12-31T18:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf()方法"></a>indexOf()方法</h3><ul><li>作用:查找数组或者有没有某一个数据(从左往右查找)</li><li>语法:<ul><li>数组.indexOf(要查找的数据)</li><li>数组.indexOf(要查找的数据,从哪个索引开始)  第二个参数不写默认从0开始</li></ul></li><li>返回值: 一个数字<ul><li>如果查找了数据,那么返回的是第一个找到数据的索引</li><li>如果没有,返回-1</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)   <span class="comment">//返回索引 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)   <span class="comment">//返回 -1</span></span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ul><li>作用:查找数组或者有没有某一个数据(从右往左查找),返回正常的索引值</li><li>语法:<ul><li>数组.lastIndexOf(要查找的数据)</li></ul></li><li>返回值: 一个数字<ul><li>如果查找了数据,那么返回的是第一个找到数据的索引</li><li>如果没有,返回-1</li></ul></li></ul><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ul><li>作用:在数据最后添加一个或多个元素(数组变大),返回添加后,数据的长度(arr.length)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把1-100中能被3与5整除的数放在数组中*/</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           arr.<span class="title function_">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ul><li>作用: 取出数组的最后一个元素,并返回这个元素(返回取出的这个元素),空数组使用pop方法,返回undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> a = arr.<span class="title function_">pop</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 返回 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)  <span class="comment">//返回 [1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="unshift-和push相反-从数组的最后一个位置的前面开始添加-返回数据的长度"><a href="#unshift-和push相反-从数组的最后一个位置的前面开始添加-返回数据的长度" class="headerlink" title="unshift 和push相反 从数组的最后一个位置的前面开始添加,返回数据的长度"></a>unshift 和push相反 从数组的最后一个位置的前面开始添加,返回数据的长度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&quot;新加的&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//返回 [&#x27;新加的&#x27;,1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="shift-和pop相反-从数组的第一个位置开始取-返回取出的值"><a href="#shift-和pop相反-从数组的第一个位置开始取-返回取出的值" class="headerlink" title="shift 和pop相反  从数组的第一个位置开始取,返回取出的值"></a>shift 和pop相反  从数组的第一个位置开始取,返回取出的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">shift</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//返回 1</span></span><br></pre></td></tr></table></figure><h3 id="reverse-反转方法-即调换数组的顺序-返回值-反转后的数组"><a href="#reverse-反转方法-即调换数组的顺序-返回值-反转后的数组" class="headerlink" title="reverse 反转方法  即调换数组的顺序  返回值:反转后的数组"></a>reverse 反转方法  即调换数组的顺序  返回值:反转后的数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//返回 [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><h3 id="sort排序方法-对数组排序-返回值-排序好的数组"><a href="#sort排序方法-对数组排序-返回值-排序好的数组" class="headerlink" title="sort排序方法 对数组排序  返回值:排序好的数组"></a>sort排序方法 对数组排序  返回值:排序好的数组</h3><ul><li><p>无参数 arr.sort() 不传参 ,从第一位开始比较ASCII码值</p></li><li><p>有参数 arr.sort(function(){}) ,如果想对数组大小进行正序或倒序进行排序,需要往sort方法内传入回调函数(sort每次排序的根据),根据每次返回的值决定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">val1,val2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 - val2 <span class="comment">//正序</span></span><br><span class="line">&#125;)</span><br><span class="line"> arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">val1,val2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> val2 - val1 <span class="comment">//倒序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="splice-方法-截取数组-截取以后再截取位置替换新的内容-改变原数组-返回新数组"><a href="#splice-方法-截取数组-截取以后再截取位置替换新的内容-改变原数组-返回新数组" class="headerlink" title="splice()方法  截取数组,截取以后再截取位置替换新的内容,改变原数组,返回新数组"></a>splice()方法  截取数组,截取以后再截取位置替换新的内容,改变原数组,返回新数组</h3></li><li><p>语法:<br>  数组 . splice(从哪个索引开始,截取多少个)<br>  返回值:新数组,数组内容是被截取出来的数据,如果都不截取,返回一个空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res=&#x27;</span>,res) <span class="comment">//返回 res=[&#x27;你好&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr=&#x27;</span>,arr) <span class="comment">//返回 arr=[&#x27;hello&#x27;,&#x27;world&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;indexOf-方法&quot;&gt;&lt;a href=&quot;#indexOf-方法&quot; class=&quot;headerlink&quot; title=&quot;indexOf()方法&quot;&gt;&lt;/a&gt;indexOf()方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;作用:查找数组或者有没有某一个数据(从左往右查找)&lt;/li&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="数组" scheme="https://monthlygirl.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>对象方法Object.keys</title>
    <link href="https://monthlygirl.github.io/2020/12/Object-keys.html"/>
    <id>https://monthlygirl.github.io/2020/12/Object-keys.html</id>
    <published>2020-12-31T17:37:18.000Z</published>
    <updated>2020-12-31T17:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-keys-方法"><a href="#Object-keys-方法" class="headerlink" title="Object.keys()方法"></a>Object.keys()方法</h3><ul><li>作用: 参数对象自身所有可遍历(可枚举)属性的键名</li><li>返回值:字符串数组,数组中包含着对象的键名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> str=<span class="string">&#x27;1234&#x27;</span></span><br><span class="line">  onsole.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(str)); <span class="comment">//返回 [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]  索引 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)); <span class="comment">// 返回 [&quot;name&quot;, &quot;age&quot;] 键名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(arr)); <span class="comment">//返回[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] 索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数返回空数组,或键名</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Basic</span>(<span class="params">name,age,address</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">address</span> = address;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27;/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">address</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Basic</span>));   <span class="comment">//[]</span></span><br><span class="line">  <span class="keyword">var</span> lily = <span class="keyword">new</span> <span class="title class_">Basic</span>(<span class="string">&#x27;li&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;fujian&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(lily));  <span class="comment">//[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;address&#x27;,&#x27;info&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">25</span>,<span class="attr">address</span>:<span class="string">&quot;深圳&quot;</span>,<span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(person).<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>)=&gt;</span>&#123;</span><br><span class="line">  person[key] <span class="comment">// 获取到属性对应的值，做一些处理</span></span><br><span class="line"></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="Object-value"><a href="#Object-value" class="headerlink" title="Object.value()"></a>Object.value()</h3><ul><li>和Object.keys()是相反的,把对象的值转为数组</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Object-keys-方法&quot;&gt;&lt;a href=&quot;#Object-keys-方法&quot; class=&quot;headerlink&quot; title=&quot;Object.keys()方法&quot;&gt;&lt;/a&gt;Object.keys()方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;作用: 参数对象自身所有可遍</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://monthlygirl.github.io/categories/JavaScript/"/>
    
    
    <category term="对象" scheme="https://monthlygirl.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
